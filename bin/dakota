#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_platform;
my $so_ext;
my $o_ext;
my $cc_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_platform = &platform("$gbl_prefix/lib/dakota/platform.yaml")
  or die "&platform(\"$gbl_prefix/lib/dakota/platform.yaml\") failed: $!" . $nl;
{
  $so_ext = &dakota::util::var($gbl_platform, 'so_ext', undef); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_platform, 'o_ext',  undef); # could also be .bc or .lto
  $cc_ext = &dakota::util::var($gbl_platform, 'cc_ext', undef);
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long qw(GetOptionsFromArray);
$Getopt::Long::ignorecase = 0;

sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?([^\s]+?)\.[^\s]+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub replace_dk_paths_with_cc_paths {
  my ($cmd, $ordered_cc_paths) = @_;
  return if @$ordered_cc_paths == 0;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if (&is_dk_path($arg)) {
      my $cc_path = &remove_first($ordered_cc_paths);
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
      return if @$ordered_cc_paths == 0;
    }
  }
}
sub parts_path {
  my $parts_path = &intmd_dir() . '/parts.txt';
  return $parts_path;
}
sub extract_dakota_opts {
  my ($cmd) = @_;
  my $opts = {};
  #  $var4opt_pat: rhs/value == 1 means opt is scalar
  my $var4opt_pat = {
                      'var=s' => 0,
                    };
  my $var4opt = {};
  my $scalar_opts = [];
  while (my ($opt_pat, $is_scalar) = each %$var4opt_pat) {
    if ($opt_pat =~ /^([\w-]+)=s$/) {
      my $key = $1;
      $$var4opt{$key} = 1;
      &add_last($scalar_opts, $key) if $is_scalar;
    } else {
      $$var4opt{$opt_pat} = 0;
    }
  }
  my $to_remove = [];
  my $cmd_len = scalar @$cmd;
  for (my $i = 0; $i < @$cmd; ) {
    my $opt = $$cmd[$i] =~ s/^--([\w-]+)(=.*)?$/$1/r;
    if (exists $$var4opt{$opt}) {
      my $opt_has_rhs = $$var4opt{$opt};
      if (0) {
      } elsif ($$cmd[$i] =~ /^--$opt=(.*)$/) { # --opt=rhs
        my $rhs = $1;
        die if ! $opt_has_rhs;
        die if $rhs eq '';
        $$opts{$opt} = [] if !exists $$opts{$opt};
        &add_last($$opts{$opt}, $rhs);
        &add_first($to_remove, $i);
      } elsif ($$cmd[$i] =~ /^--$opt$/) {
        $$opts{$opt} = [] if !exists $$opts{$opt};
        if ($opt_has_rhs) { # --opt rhs
          my $rhs = $$cmd[$i + 1];
          die if ! ($i + 1 < $cmd_len);
          die if $rhs =~ /^-/;
          &add_last($$opts{$opt}, $rhs);
          &add_first($to_remove, $i);
          &add_first($to_remove, $i + 1);
        } else { # --opt
          &add_first($to_remove, $i);
        }
      }
    }
    $i++;
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  foreach my $key (@$scalar_opts) {
    $$opts{$key} = $$opts{$key}[0];
  }
  return $opts;
}
sub ordered_dk_paths {
  my ($cmd) = @_;
  my $ordered_dk_paths = [];
  foreach my $arg (@$cmd) {
    if (&is_dk_path($arg)) {
      $arg = Cwd::abs_path($arg) if ! &is_abs($arg); # added for ninja build system
      &add_last($ordered_dk_paths, $arg);
    }
  }
  return $ordered_dk_paths;
}
sub intmd_dir_from_build_dir {
  my ($build_dir) = @_;
  my $dir = &dir_part(&dir_part($build_dir));
  my $name = &name_part($build_dir);
  my $intmd_dir = $dir . '/intmd/' . $name;
  return $intmd_dir;
}
sub current_source_dir_from_inputs {
  my ($inputs) = @_;
  my $tbl = {};
  foreach my $input (@$inputs) {
    if (&is_dk_path($input)) {
      my $dir = $input;
      while ($dir = &dir_part($dir)) {
        #print STDERR $dir . $nl;
        if (-e "$dir/CMakeLists.txt") {
          $$tbl{$dir} = 1;
          last;
        }
      }
    }
  }
  my $dirs = [keys %$tbl];
  if (scalar @$dirs == 1) {
    return $$dirs[0];
  } else {
    my $p1 = pop @$dirs;
    my $p1_len = length $p1;
    while (scalar @$dirs) {
      my $p2 = pop @$dirs;
      my $p2_len = length $p2;
      if ($p2_len < $p1_len) {
        $p1 = $p2;
        $p1_len = $p2_len
      } else { die if $p1_len == $p2_len; }
    }
    return $p1;
  }
}
sub set_env_vars {
  my ($kvs) = @_;
  foreach my $kv (@$kvs) {
    $kv =~ /^([\w-]+)=(.*)$/;
    my ($key, $val) = ($1, $2);
    $ENV{$key} = $val;
  }
}
sub cxx_argv_from_argv {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  my $dakota_opts = &extract_dakota_opts($cmd);
  &set_env_vars($$dakota_opts{'var'});
  delete $$dakota_opts{'var'};
  my $cxx_argv = [@$cmd];
  $$cxx_argv[0] = &cxx();
  my $ordered_dk_paths = &ordered_dk_paths($cxx_argv);
  if (@$ordered_dk_paths != 0) {
    my $ordered_cc_paths = &exec_cmd_info({ 'inputs' => $ordered_dk_paths });
    &replace_dk_paths_with_cc_paths($cxx_argv, $ordered_cc_paths);
  }
  return $cxx_argv;
}
sub has_target_action_opt {
  my ($argv) = @_;
  foreach my $arg (@$argv) {
    return 1 if $arg =~ /^--(target|action)(=.*)?$/;
  }
  return 0;
}
sub dakota_io {
  my ($root_cmd) = @_;
  my $source_dir = &source_dir();
  my $intmd_dir =  &intmd_dir();
  $$root_cmd{'io'} = $intmd_dir . '/dakota.io';
  my $dakota_io_path = $$root_cmd{'io'};
  if (! -e $dakota_io_path) {
    # dk2ast : $foo{'dk'}{$dk_path}{'ast'}{$ast_path}
    my $default_dakota_io = {
      'precompile' => {},
      'cwd' =>        &cwd(),
      'source-dir' => $source_dir,
      'intmd-dir' =>  $intmd_dir,
    };
    &dakota::util::dakota_io_to_file($dakota_io_path, $default_dakota_io);
  }
  my $dakota_io = &dakota::util::dakota_io_from_file($dakota_io_path);
  $$dakota_io{'intmd-dir'} = &intmd_dir();
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  return ($dakota_io_path, $dakota_io);
} # dakota_io
sub clean {
  my ($root_cmd, $dakota_io_path, $dakota_io) = @_;
  if ($dakota_io) {
    if (0) {
      if ($$dakota_io{'intmd-dir'} && $$dakota_io{'intmd-dir'} ne '.') {
        print "rm -r $$dakota_io{'intmd-dir'}" . $nl;
        `rm -r $$dakota_io{'intmd-dir'}`;
      }
    }
    if (1) { # cmake writes .o files in its own build dir
      &clean_paths($dakota_io, $dakota_io_path, 'precompile', 'target-src');
    }
  }
}
sub clean_paths {
  my ($dakota_io, $dakota_io_path, $key, $extra_key) = @_;
  my $values = [values %{$$dakota_io{$key}}];
  $$dakota_io{$key} = {};
  if ($extra_key && $$dakota_io{$extra_key}) {
    &add_last($values, $$dakota_io{$extra_key});
    delete $$dakota_io{$extra_key};
  }
  my $remove = {};
  foreach my $out_path (@$values) {
    if (-e $out_path) {
      $$remove{$out_path} = undef;
    }
  }
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  foreach my $path (sort keys %$remove) {
    print "rm $path" . $nl;
    unlink $path;
  }
}
sub cmd_info_from_argv {
  my ($argv) = @_;
  my $root_cmd = {
    'opts' => {
    'var' => [],
    }
  };
  &GetOptionsFromArray($argv, $$root_cmd{'opts'},
                       'path-only',
                       'action=s', 'output=s', # output only used for action=parse and action=merge
                       'target=s',
                       'var=s',
                       #'clean', # make target like
                      );
  $$root_cmd{'inputs'} = $argv;
  &set_env_vars($$root_cmd{'opts'}{'var'});
  delete $$root_cmd{'opts'}{'var'};
  return $root_cmd;
}
sub exec_cmd_info {
  my ($root_cmd) = @_;
  if (! $ENV{'intmd_dir'}) {
    $ENV{'intmd_dir'} = &intmd_dir_from_build_dir(&build_dir());
  }
  if (! $$root_cmd{'opts'}{'action'}) {
    &path_only($root_cmd) if $$root_cmd{'opts'}{'path-only'};
    $$root_cmd{'parts'} = &parts(&parts_path());
    &set_root_cmd($root_cmd);
    my ($dakota_io_path, $dakota_io) = &dakota_io($root_cmd);

    if ($$root_cmd{'opts'}{'clean'}) {
      &clean($root_cmd, $dakota_io_path, $dakota_io);
      exit 0;
    }
  }
  #print STDERR "root_cmd{'opts'}: " . &Dumper($$root_cmd{'opts'});
  my $ordered_cc_paths = &dakota::dakota::start_cmd($root_cmd);
  return $ordered_cc_paths;
}
sub start {
  my ($argv) = @_;
  if (&has_target_action_opt($argv)) { # --target=ast, --target=hdr, --target=src, --action=parse, --action=merge
    my $cmd_info = &cmd_info_from_argv($argv);
    my $ordered_cc_paths = &exec_cmd_info($cmd_info); # -> start_cmd()
  } else { # --output foo.dk.o foo.dk, --output <shared-library | executable> *.dk.o
    my $cxx_argv = &cxx_argv_from_argv($argv); # -> exec_cmd_info() -> start_cmd()
    my $exit_val = &verbose_exec($cxx_argv); # -> g++/clang++
    exit 1 if $exit_val;
  }
  exit 0;
}
&start(\@ARGV);
