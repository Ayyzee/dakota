#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007-2015 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_compiler;
my $so_ext;
my $o_ext;

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!\n";
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_compiler = do "$gbl_prefix/lib/dakota/compiler/command-line.json"
  or die "do $gbl_prefix/lib/dakota/compiler/command-line.json failed: $!\n";
{
  my $platform = do "$gbl_prefix/lib/dakota/platform.json"
    or die "do $gbl_prefix/lib/dakota/platform.json failed: $!\n";
  my ($key, $values);
  while (($key, $values) = each (%$platform)) {
    $$gbl_compiler{$key} = $values;
  }
  $so_ext = &dakota::util::var($gbl_compiler, 'so_ext', 'so'); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_compiler, 'o_ext', 'o'); # could be .bc or .lto
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $root_cmd = { 'reps' => [],
                 'opts' => { 'directory' => [],
                             'include-directory' => [ "$gbl_prefix/include" ],
                             'library-directory' => [],
                             'library' => [],
                             'define-macro' => [],
                             'var' => {} } };

&GetOptions($$root_cmd{'opts'},
            'clean',                # make target like
            'compile',              # gcc-like
            'define-macro=s',       # gcc-like
            'directory=s',          # make-like
            'include-directory=s',  # gcc-like (--include-directory=<> OR -I<>)
            'keep-going',           # make-like
            'library-directory=s',  # gcc-like (--library-directory=<> OR -L<>)
            'library=s',            # --library libdl.so equivalent to -ldl (or better -l:libdl.so on linux)
            'nodefaultlibs',        # gcc-like
            'output=s',             # gcc-like
            'precompile',           # gcc-ish (--compile)
            'project=s',
            'shared',               # gcc-like
            'silent',               #
            'soname=s',             # ld-like (-soname <>)
            'var=s',                # for env vars like MAKEFLAGS, etc.
           #'compiler-flags=s',     # similiar to env vars CXXFLAGS & EXTRA_CXXFLAGS
           #'compiler=s',           # similiar to env var CXX
           #'environment-overrides' # make-like
           #'for-compiler=s',       # gcc-like (--for-linker <>)
           #'for-linker=s',         # gcc-like
           #'jobs'                  # make-like
           #'linker-flags=s',       # similiar to env vars LDFLAGS & EXTRA_LDFLAGS
           #'linker=s',             # similiar to env var LD
           #'pie'                   # ld-like
           #'runpath=s',            # gcc-like (--for-linker -R|-rpath --for-linker <>), ld-like (-R|-rpath <>)
           #'touch'                 # make-like
           );
# --quiet
# --help
# --verbose

# 1/1: one  input,  one output
# 1/0: one  input,  no  output
# m/0: many inputs, no  output
# m/1: many inputs, one output (directory)

my $inputs = &clean_paths(\@ARGV);
my $project;
my $project_io;
my $project_io_path;

# create default project file when missing (when linking)
if (!exists $$root_cmd{'compile'} && !$$root_cmd{'opts'}{'project'}) {
  $$root_cmd{'opts'}{'project'} = &create_missing_project($root_cmd, $inputs);
}
if ($$root_cmd{'opts'}{'project'}) {
  ($project, $project_io) = &use_project($root_cmd);
}
if ($$root_cmd{'opts'}{'clean'}) {
  &project_clean($root_cmd, $project, $project_io);
  exit 0;
}
if ($project) {
  if (!$$root_cmd{'opts'}{'output'} && exists $$root_cmd{'opts'}{'compile'}) {
    if (1 == scalar @$inputs && &is_dk_path($$inputs[0])) {
      my $o_path = &o_path_from_dk_path($$inputs[0]);
      $$root_cmd{'opts'}{'output'} = $o_path; # setting default output (compile) path for single .dk input path
    }
  }
  if ($$root_cmd{'opts'}{'output'} && exists $$root_cmd{'opts'}{'compile'}) {
    if (1 == scalar @$inputs && &is_dk_path($$inputs[0])) {
      $$project_io{'compile'}{$$inputs[0]} = $$root_cmd{'opts'}{'output'};
      my $original_state;
      &scalar_to_file($project_io_path, $project_io, $original_state = 1);
    }
  }
}
if (!exists $$root_cmd{'opts'}{'compile'} && scalar values %{$$project_io{'compile'}}) {
  foreach my $input (@$inputs) {
    if ($$project_io{'compile'}{$input}) {
      delete $$project_io{'compile'}{$input};
    }
  }
  push @$inputs, values %{$$project_io{'compile'}};
  foreach my $input (@{$$project{'inputs'}}) {
    if ($input =~ /\.$so_ext$/) { # is_so_path()
      push @$inputs, $input;
    }
  }
}
$inputs = &clean_paths($inputs);

if (0 == scalar @$inputs) {
  $inputs = $$root_cmd{'project.inputs'};
}
if (0 == scalar @$inputs) {
  die "$0: error: arguments are requried\n";
} else {
  # should only reorder the dk files leaving the so files in the same place
  # so the inputs should be split into separate sublist (and then sorted)
  $inputs = [sort {&mtime($b) <=> &mtime($a)} @$inputs];
  $$root_cmd{'inputs'} = $inputs;
}

# dakota --compile --output <> {dk}
# dakota --shared  --output <> {o}+ {so}* [obj/rt/<>.cc.o]
# dakota           --output <> {o}+ {so}* [obj/rt/<>.cc.o]

if (!$$root_cmd{'opts'}{'output'} && !$$root_cmd{'opts'}{'compile'}) {
  $$root_cmd{'opts'}{'output'} = &canon_path(&default_output($root_cmd));
}
if ($$root_cmd{'opts'}{'output'}) {
  $$root_cmd{'opts'}{'output'} = &canon_path($$root_cmd{'opts'}{'output'});
}
if ($$root_cmd{'opts'}{'soname'}) {
  $$root_cmd{'opts'}{'soname'} = &canon_path($$root_cmd{'opts'}{'soname'});
}
if (!$$root_cmd{'opts'}{'nodefaultlibs'}) {
  my $libdakota = "$gbl_prefix/lib/libdakota.$so_ext";
  if (!$$root_cmd{'opts'}{'output'} || $$root_cmd{'opts'}{'output'} ne $libdakota) {
    &add_last($$root_cmd{'inputs'}, $libdakota);
  }
}
$ENV{'CXXFLAGS'} = &dakota::util::var($gbl_compiler, 'CXXFLAGS', undef);

&clean_paths($root_cmd, 'inputs');
&clean_paths($root_cmd, 'include-directory');
&clean_paths($root_cmd, 'library-directory');
&clean_paths($root_cmd, 'library');
&clean_paths($root_cmd, 'define-macro');

my $gcc_from_dakota = {
  '--include-directory' => '--include-directory', # yep, the same
  '--define-macro' =>      '--define-macro',      # yep, the same
};

if ($$root_cmd{'opts'}{'include-directory'}) {
  my $flags = '';
  foreach my $dir (@{$$root_cmd{'opts'}{'include-directory'}}) {
    $flags .= ' ' . $$gcc_from_dakota{'--include-directory'} . ' ' . $dir;
  }
  $ENV{'CXXFLAGS'} .= $flags;
}
if ($$root_cmd{'opts'}{'define-macro'}) {
  my $flags = '';
  foreach my $mcr (@{$$root_cmd{'opts'}{'define-macro'}}) {
    $flags .= ' ' . $$gcc_from_dakota{'--define-macro'} . ' ' . $mcr;
  }
  $ENV{'CXXFLAGS'} .= $flags;
}
if (scalar @{$$root_cmd{'opts'}{'directory'}}) {
  my $initial_workdir = &getcwd();
  foreach my $dir (@{$$root_cmd{'opts'}{'directory'}}) {
    if ($dir ne '.' &&
        $dir ne './') {
      chdir $dir;
      my $current_workdir = &getcwd();
      my $reldir = File::Spec->abs2rel($current_workdir, $initial_workdir);
      $ENV{'DKT_DIR'} = $reldir;
    }
  }
}
if ($$root_cmd{'opts'}{'precompile'}) {
  $ENV{'DKT_PRECOMPILE'} = 1;
}
my $result = &dakota::dakota::start_cmd($root_cmd);
exit $result;

sub create_missing_project {
  my ($root_cmd, $inputs) = @_;
  if (0 == scalar @$inputs) {
    die "error: missing both --project <file> and input files; at least one is required.";
  }
  if ($$root_cmd{'opts'}{'compile'}) {
    print "warning: missing --project <file> (creating default).\n";
  } else {
    print "info: missing --project <file> (creating default).\n";
  }
  # create and write a default project file
  $project = { 'output' => undef, 'inputs' => [],
               'objdir' => undef, 'io' => undef };
  foreach my $input (@$inputs) {
    if ($input =~ m/\.(dk|$so_ext)$/) {
      add_last($$project{'inputs'}, $input);
    } else {
      print __FILE__ . ":" . __LINE__ . ": skipping input $input\n";
    }
  }
  if ($ENV{'OBJDIR'}) {
    $$project{'objdir'} = $ENV{'OBJDIR'};
  } else {
    $$project{'objdir'} = 'obj';
  }
  my $project_base;
  my $project_path;

  if ($$root_cmd{'opts'}{'output'}) {
    $$project{'output'} = $$root_cmd{'opts'}{'output'};
    $project_base = $$project{'output'} =~ s/\.$so_ext$//r;
  } elsif (scalar @$inputs) {
    $project_base = &project_base($inputs);
    if ($$root_cmd{'opts'}{'shared'}) {
      $$project{'output'} = $project_base . ".$so_ext";
    } else {
      $$project{'output'} = $project_base;
    }
  }
  $$project{'io'} = $project_base . '.io';
  $project_path =   $project_base . '.project';
  if (-e $$project{'io'}) {
    die;
  }
  if (-e $project_path) {
    die;
  }
  my $original_state;
  &scalar_to_file($project_path, $project, $original_state = 1);
  return $project_path;
}
sub project_base {
  my ($inputs) = @_;
  my $dk_path = &first_dk_path($inputs);
  my $project_base = $dk_path =~ s/\.dk$//r;
  return $project_base;
}
sub first_dk_path {
  my ($inputs) = @_;
  foreach my $input (@$inputs) {
    if (&is_dk_path($input)) {
      return $input;
    }
  }
  die;
}
sub use_project {
  my ($root_cmd, $project) = @_;
  $project = &set_global_project($$root_cmd{'opts'}{'project'});
  if ($$project{'objdir'}) {
    $$root_cmd{'project.objdir'} = $$project{'objdir'};
  }
  $$root_cmd{'project.inputs'} = $$project{'inputs'};
  $$root_cmd{'project.output'} = $$project{'output'};
  if ($$project{'io'}) {
    $$root_cmd{'project.io'} = $$project{'io'};
  } else {
    $$root_cmd{'project.io'} = $$root_cmd{'opts'}{'project'} =~ s/\.project$/\.io/r;
    print "warning: missing 'io' path in project file; using $$root_cmd{'project.io'}\n";
  }
  $project_io_path = $$root_cmd{'project.io'};
  my $original_state;
  if (! -e $project_io_path) {
    # dk2json : $foo{'dk'}{$dk_path}{'json'}{$json_path}
    my $default_project_io = { 'all' => {}, 'compile' => {}, 'inputs' => {} };
    &scalar_to_file($project_io_path, $default_project_io, $original_state = 1);
  }
  $project_io = &scalar_from_file($project_io_path);
  $$project_io{'inputs'} = { map { $_ => 1 } @{$$project{'inputs'}} };
  if ($$project{'objdir'}) {
    $$project_io{'objdir'} = $$project{'objdir'};
  }
  &scalar_to_file($project_io_path, $project_io, $original_state = 1);
  return ($project, $project_io);
}
sub project_clean {
  my ($root_cmd, $project, $project_io) = @_;
  #print "project: " . &Dumper($project);
  #print "project.io: " . &Dumper($project_io);
  if (!$project_io && $$project{'io'}) {
    $project_io = &scalar_from_file($$project{'io'});
  }
  # {'all'}{$in}{$out} = 1
  if ($project_io) {
    while (my ($in_path, $out_paths) = each (%{$$project_io{'all'}})) {
      foreach my $out_path (keys %$out_paths) {
        if (-e $out_path) {
          print "rm $out_path\n";
          unlink $out_path;
        }
      }
      if (! $$project_io{'inputs'}{$in_path}) {
        if (-e $in_path) {
          print "rm $in_path\n";
          unlink $in_path;
        }
      }
    }
    $$project_io{'all'} = {};
    $$project_io{'compile'} = {};
    my $original_state;
    &scalar_to_file($project_io_path, $project_io, $original_state = 1);
  }
  if ($$project{'output'} && -e $$project{'output'}) {
    print "rm $$project{'output'}\n";
    unlink $$project{'output'};
  }
  if ($$project{'project.rep'} && -e $$project{'project.rep'}) {
    print "rm $$project{'project.rep'}\n";
    unlink $$project{'project.rep'};
  }
}
sub default_output {
  my ($root_cmd, $inputs) = @_;
  my $output;
  if ($$root_cmd{'project.output'}) {
    $output = $$root_cmd{'project.output'};
  } else {
    $output = &project_base($inputs);
    if ($$root_cmd{'opts'}{'shared'}) {
      $output .= ".$so_ext";
      print "using implicit lib name: $output\n";
    } else {
      print "using implicit exe name: $output\n";
    }
  }
  return $output;
}
