#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_compiler;
my $so_ext;
my $o_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
#use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_compiler = do "$gbl_prefix/lib/dakota/compiler/command-line.json"
  or die "do $gbl_prefix/lib/dakota/compiler/command-line.json failed: $!" . $nl;
{
  my $platform = do "$gbl_prefix/lib/dakota/platform.json"
    or die "do $gbl_prefix/lib/dakota/platform.json failed: $!" . $nl;
  my ($key, $values);
  while (($key, $values) = each (%$platform)) {
    $$gbl_compiler{$key} = $values;
  }
  $so_ext = &dakota::util::var($gbl_compiler, 'so_ext', 'so'); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_compiler, 'o_ext', 'o'); # could be .bc or .lto
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $default_project_path = 'dakota.project';

my $root_cmd = {
  'asts' => [],
  'inputs' => [],
  'opts' => {
    'define-macro' => [],
    'include-directory' => [ "$gbl_prefix/include" ],
    'library-directory' => [],
    'library' => [],

    'directory' => [],
    'found-library' => [],
    'var' => {},
  }
};
&GetOptions($$root_cmd{'opts'},
            'define-macro=s',       # gcc-like
            'include-directory=s',  # gcc-like (--include-directory=<> OR -I<>)
            'library-directory=s',  # gcc-like (--library-directory=<> OR -L<>)
            'library=s',            # --library libssl.so equivalent to -lssl (or better -l:libssl.so on linux)
            'output=s',             # gcc-like

            'compile',              # gcc-like
            'dynamic',              # gcc-like
            'shared',               # gcc-like

            'init',
            'parse',
            'path-only',
            'precompile',           # gcc-ish (--compile)
            'project=s',
            'target',

            'clean',                # make target like
            'create-project=s',
            'directory=s',          # make-like
            'echo-inputs',          #
            'found-library=s',
            'keep-going',           # make-like
            'silent',               #
            'soname=s',             # ld-like (-soname <>)
            'var=s',                # for env vars like MAKEFLAGS, etc.
           #'compiler-flags=s',     # similiar to env vars CXXFLAGS & EXTRA_CXXFLAGS
           #'compiler=s',           # similiar to env var CXX
           #'environment-overrides' # make-like
           #'for-compiler=s',       # gcc-like (--for-linker <>)
           #'for-linker=s',         # gcc-like
           #'jobs'                  # make-like
           #'linker-flags=s',       # similiar to env vars LDFLAGS & EXTRA_LDFLAGS
           #'linker=s',             # similiar to env var LD
           #'pie'                   # ld-like
           #'runpath=s',            # gcc-like (--for-linker -R|-rpath --for-linker <>), ld-like (-R|-rpath <>)
           #'touch'                 # make-like
           );
$$root_cmd{'opts'}{'precompile'} = 1 if $$root_cmd{'opts'}{'target'};
if ($$root_cmd{'opts'}{'project'}) {
  $$root_cmd{'opts'}{'project'} = &relpath($$root_cmd{'opts'}{'project'});
} elsif (-e $default_project_path) {
  $$root_cmd{'opts'}{'project'} = $default_project_path;
}
&set_root_cmd($root_cmd);

my $found_library = { 'order' => [] };
foreach my $pair (@{$$root_cmd{'opts'}{'found-library'}}) {
  my ($s, $l) = split('=', $pair);
  &add_last($$found_library{'order'}, $s);
  my $m = &lib_from_lib_name($s);
  # $m could also be created by basename
  # but the soname aspect comes into play
  $$found_library{'S2M'}{$s} = $m;
  $$found_library{'M2L'}{$m} = $l;
}
$$root_cmd{'opts'}{'found-library'} = $found_library;

# --quiet
# --help
# --verbose

# 1/1: one  input,  one output
# 1/0: one  input,  no  output
# m/0: many inputs, no  output
# m/1: many inputs, one output (directory)

my $rel_argv = [map { &relpath($_) } @ARGV];
my $inputs = &clean_paths($rel_argv);
my $project;
my $project_io;
my $project_io_path;

if ($$root_cmd{'opts'}{'create-project'}) {
  &create_missing_project($root_cmd, $inputs);
  exit;
}
# create default project file when missing (when linking)
if (!$$root_cmd{'compile'} && !$$root_cmd{'opts'}{'project'}) {
  $$root_cmd{'opts'}{'project'} = &create_missing_project($root_cmd, $inputs);
}
if ($$root_cmd{'opts'}{'project'}) {
  ($project, $project_io) = &use_project($root_cmd);
}
if ($$root_cmd{'opts'}{'clean'}) {
  &project_clean($root_cmd, $project, $project_io);
  exit 0;
}
if ($project) {
  if (!$$root_cmd{'opts'}{'output'} && $$root_cmd{'opts'}{'compile'}) {
    if (1 == scalar @$inputs && &is_dk_path($$inputs[0])) {
      my $o_path = &o_path_from_dk_path($$inputs[0]);
      $$root_cmd{'opts'}{'output'} = $o_path; # setting default output (compile) path for single .dk input path
    }
  }
  if ($$root_cmd{'opts'}{'output'} && $$root_cmd{'opts'}{'compile'}) {
    if (1 == scalar @$inputs && &is_dk_path($$inputs[0]) && !$$root_cmd{'opts'}{'precompile'}) {
      &dakota::util::project_io_add($$root_cmd{'project.io'}, 'compile', $$inputs[0], $$root_cmd{'opts'}{'output'});
      my $original_state;
      &dakota::util::project_io_to_file($project_io_path, $project_io);
    }
  }
}
if (!$$root_cmd{'opts'}{'compile'} && scalar values %{$$project_io{'compile'}}) {
  &dakota::util::project_io_remove($project_io, 'compile', $inputs);
  &add_last($inputs, values %{$$project_io{'compile'}});
  foreach my $input (@{$$project{'inputs'}}) {
    if ($input =~ /\.$so_ext$/) { # is_so_path()
      &add_last($inputs, $input);
    }
  }
}
$inputs = &clean_paths($inputs);

if (0) {
  my $stuff = {};
  $$stuff{'cwd'} = &getcwd();
  $$stuff{'project-dir'} = &dir_part($$root_cmd{'opts'}{'project'});
  $$stuff{'rel-dir'} = &relpath($$stuff{'project-dir'}, $$stuff{'cwd'});
  #&dmp($stuff);
  my $dir = $$stuff{'rel-dir'};
  if (! $dir) {
    $dir = &getcwd();
  } elsif (! &is_abs($dir)) {
    $dir = &getcwd() . '/' . $dir;
  }
  for (my $i = 0; $i < @{$$root_cmd{'project.inputs'}}; $i++) {
    my $project_input = $$root_cmd{'project.inputs'}[$i];
    if (! &is_abs($project_input)) {
      my $input = $dir . '/' . $project_input;
      if (! -e $input) {
        print STDERR $0 . ": error: no-such-file: $input" . $nl;
      }
      $$root_cmd{'project.inputs'}[$i] = $input;
    }
  }
}
if (!$$root_cmd{'opts'}{'compile'} && 1 >= scalar @$inputs) { # only the implied libdakota-core.so
  if (1 >= scalar $$root_cmd{'project.inputs'}) {
    die "$0: error: inputs are requried either in the project file or the command line." . $nl;
  } else {
    $inputs = $$root_cmd{'project.inputs'};
    $$root_cmd{'inputs'} = [];
  }
}
# should only reorder the .o files (between .so files) leaving the .so files in their
# original position so the inputs should be split into separate sublist (and then sorted).
# its OK to sort the .dk files, but we must link using the original positions.
if (1) {
  if (!$$root_cmd{'opts'}{'precompile'}) {
    $inputs = [sort {&mtime($b) <=> &mtime($a)} @$inputs];
  }
}
$$root_cmd{'inputs'} = [ @$inputs, @{$$root_cmd{'inputs'}} ];
# dakota --compile --output <> {dk}+
# dakota --shared  --output <> {o}+ [build/+rt/<>.o] {so}*
# dakota           --output <> {o}+ [build/+rt/<>.o] {so}*

if (!$$root_cmd{'opts'}{'output'} && !$$root_cmd{'opts'}{'compile'}) {
  if ($$project{'target'} =~ /\.$so_ext$/) { # is_so_path()
    $$root_cmd{'opts'}{'output'} = $$project{'target'};
  } elsif ($$project{'is-lib'}) {
    $$root_cmd{'opts'}{'output'} = &lib_from_lib_name($$project{'target'});
  } else {
    $$root_cmd{'opts'}{'output'} = &exe_from_exe_name($$project{'target'});
  }
}
if ($$root_cmd{'opts'}{'output'}) {
  $$root_cmd{'opts'}{'output'} = &canon_path($$root_cmd{'opts'}{'output'});
}
if ($$root_cmd{'opts'}{'soname'}) {
  $$root_cmd{'opts'}{'soname'} = &canon_path($$root_cmd{'opts'}{'soname'});
}
$ENV{'CXXFLAGS'} = &dakota::util::var($gbl_compiler, 'CXXFLAGS', undef);

&clean_paths($root_cmd, 'inputs');
&clean_paths($$root_cmd{'opts'}, 'include-directory');
&clean_paths($$root_cmd{'opts'}, 'library-directory');

my $gcc_from_dakota = {
  '--include-directory' => '--include-directory', # yep, the same
  '--define-macro' =>      '--define-macro',      # yep, the same
};

if ($$root_cmd{'opts'}{'include-directory'}) {
  my $flags = '';
  foreach my $dir (@{$$root_cmd{'opts'}{'include-directory'}}) {
    $flags .= ' ' . $$gcc_from_dakota{'--include-directory'} . '=' . $dir;
  }
  $ENV{'CXXFLAGS'} .= $flags;
}
my $env_vars = { 'DK_SRC_UNIQUE_HEADER' => undef,
                 'DK_INLINE_GENERIC_FUNCS' => undef,
                 'DK_INLINE_KLASS_FUNCS' => undef,
               };
if ($$root_cmd{'opts'}{'define-macro'}) {
  my $flags = '';
  foreach my $mcr (@{$$root_cmd{'opts'}{'define-macro'}}) {
    $flags .= ' ' . $$gcc_from_dakota{'--define-macro'} . '=' . $mcr;
    my ($lhs, $rhs) = split(/=/, $mcr);
    if (exists $$env_vars{$lhs}) {
      $ENV{$lhs} = $rhs;
    }
  }
  $ENV{'CXXFLAGS'} .= $flags;
}
if (scalar @{$$root_cmd{'opts'}{'directory'}}) {
  my $initial_workdir = &getcwd();
  foreach my $dir (@{$$root_cmd{'opts'}{'directory'}}) {
    if ($dir ne '.' &&
        $dir ne './') {
      chdir $dir;
      my $current_workdir = &getcwd();
      my $reldir = File::Spec->abs2rel($current_workdir, $initial_workdir);
      $ENV{'DKT_DIR'} = $reldir;
    }
  }
}
#print STDERR 'root_cmd: ' . &Dumper($root_cmd);
#print STDERR 'project: ' .  &Dumper($project);
die if ! $$root_cmd{'source-dir'};
die if ! $$project{'source-dir'};
my $result = &dakota::dakota::start_cmd($root_cmd, $project);
exit $result;

sub create_missing_project {
  my ($root_cmd, $inputs) = @_;
  if (0 == scalar @$inputs) {
    die "error: missing both --project <file> and input files; at least one is required.";
  }
  $project = { 'target' => undef, 'inputs' => [],
               'builddir' => &builddir() };
  my $project_path;

  if ($$root_cmd{'opts'}{'output'}) {
    $$project{'target'} = $$root_cmd{'opts'}{'output'};
  }
  if ($$root_cmd{'opts'}{'create-project'}) {
    $project_path = $$root_cmd{'opts'}{'create-project'};
  } else {
  my $project_base;
  if ($$project{'target'}) {
    $project_base = $$project{'target'} =~ s/\.$so_ext$//r; # remove ext if present
  } else {
    $project_base = &project_base($inputs);
    if (! &is_exe($root_cmd)) {
      $$project{'target'} = $project_base . ".$so_ext";
    } else {
      $$project{'target'} = $project_base;
    }
  }
  if (! &is_exe($root_cmd)) {
    $$project{'is-lib'} = 1;
  }
  $project_path = $default_project_path;
  if (-e $project_path) {
    print STDERR $0 . ": info: found $project_path; using for missing --project <>." . $nl;
    return $project_path;
  } elsif ($$root_cmd{'opts'}{'compile'}) {
    print STDERR $0 . ": warning: missing --project <file> (creating default $project_path)." . $nl;
  } else {
    print STDERR $0 . ": info: missing --project <file> (creating default $project_path)." . $nl;
  }
  }
  # create and write a default project file
  foreach my $input (@$inputs) {
    if ($input =~ m/\.(dk|$so_ext)$/) {
      &add_last($$project{'inputs'}, $input);
    } else {
      print STDERR __FILE__ . ':' . __LINE__ . ": skipping input $input" . $nl;
    }
  }
  &scalar_to_file($project_path, $project);
  return $project_path;
}
sub project_base {
  my ($inputs) = @_;
  my $dk_path = &first_dk_path($inputs);
  my $project_base = $dk_path =~ s/\.dk$//r;
  return $project_base;
}
sub first_dk_path {
  my ($inputs) = @_;
  foreach my $input (@$inputs) {
    if (&is_dk_path($input)) {
      return $input;
    }
  }
  die;
}
sub lib_from_lib_name {
  my ($name) = @_;
  # linux and darwin so-regexs are separate
  if ($name =~ m=^(.*/)?(lib([.\w-]+))\.$so_ext((\.\d+)+)?$= ||
      $name =~ m=^(.*/)?(lib([.\w-]+))((\.\d+)+)?\.$so_ext$=) { # so-regex
    return $name;
  }
  return 'lib' . $name . ".$so_ext";
}
sub exe_from_exe_name {
  my ($name) = @_;
  return $name;
}
sub project_adjust_paths {
  my ($project) = @_;
  return if $$project{'source-dir'} eq '.';
  my $force;
  $$project{'inputs'} =       &adjust_paths($$project{'source-dir'}, $$project{'inputs'});
  $$project{'srcs'} =         &adjust_paths($$project{'source-dir'}, $$project{'srcs'});
  $$project{'include-dirs'} = &adjust_paths($$project{'source-dir'}, $$project{'include-dirs'}, $force = 1);
  $$project{'builddir'} =     &adjust_path( $$project{'source-dir'}, $$project{'builddir'}, $force = 1);
}
sub use_project {
  my ($root_cmd) = @_;
  my $project = &set_global_project($$root_cmd{'opts'}{'project'});
  $$project{'source-dir'} = &dir_part(&relpath($$root_cmd{'opts'}{'project'}));
  if (! $$project{'builddir'}) {
    $$project{'builddir'} = &builddir();
  }
  if (! $$project{'inputs'} && $$project{'srcs'}) {
    $$project{'inputs'} = [ @{$$project{'srcs'}} ];
  }
  if ($$project{'libs'}) {
    $$project{'inputs'} = [ @{$$project{'inputs'}}, map { &lib_from_lib_name($_) } @{$$project{'libs'}} ];
  }
  if (! $$project{'target'}) {
    $$project{'target'} = &canon_path(&default_target($root_cmd, $project, $$project{'inputs'}));
  }
  if (! &is_exe($root_cmd)) {
    $$project{'is-lib'} = 1;
  }
  if (! $$project{'is-lib'} || $$project{'target'} ne 'dakota-core') {
    &add_last($$root_cmd{'inputs'}, &lib_from_lib_name('dakota-core'));
    &add_last($$project{'inputs'},  &lib_from_lib_name('dakota-core'));

    if (! $$project{'is-lib'} || $$project{'target'} ne 'dakota') {
      &add_last($$root_cmd{'inputs'}, &lib_from_lib_name('dakota'));
      &add_last($$project{'inputs'},  &lib_from_lib_name('dakota'));
    }
  }
  &project_adjust_paths($project);
  if (! -e $$project{'builddir'}) {
    &make_dir($$project{'builddir'});
  }
  $$root_cmd{'source-dir'} = $$project{'source-dir'}; # 'project.source-dir'?
  $$root_cmd{'project.inputs'} = $$project{'inputs'};
  $$root_cmd{'project.builddir'} = $$project{'builddir'};
  $$root_cmd{'project.target'} = $$project{'target'};
  $$root_cmd{'project.io'} = $$project{'builddir'} . '/dakota.io';
  $project_io_path = $$root_cmd{'project.io'};
  if (! -e $project_io_path) {
    # dk2ast : $foo{'dk'}{$dk_path}{'ast'}{$ast_path}
    my $default_project_io = { 'compile' => {},
                               'builddir' => undef };
    &dakota::util::project_io_to_file($project_io_path, $default_project_io);
  }
  $project_io = &dakota::util::project_io_from_file($project_io_path);
  if (1) {
    my $libs = [ map { &lib_from_lib_name($_) } @{$$project{'libs'}} ];
    $$project_io{'link'} = { map { &canon_path($_) => &find_library($_, $$root_cmd{'opts'}{'found-library'}) } @$libs };
  }
  if ($$project{'builddir'}) {
    $$project_io{'builddir'} = &canon_path($$project{'builddir'});
  }
  &dakota::util::project_io_to_file($project_io_path, $project_io);
  return ($project, $project_io);
} # use_project
sub project_clean {
  my ($root_cmd, $project, $project_io) = @_;
  my $remove = {};
  if ($project_io) {
    if ($$project_io{'builddir'}) {
      print "rm -r $$project_io{'builddir'}" . $nl;
      `rm -r $$project_io{'builddir'}`;
    }
    if (1) { # cmake writes .o files in its own build dir
      foreach my $out_path (values %{$$project_io{'compile'}}) {
        if (-e $out_path) {
          $$remove{$out_path} = undef;
        }
      }
      $$project_io{'compile'} = {};
      my $original_state;
      &dakota::util::project_io_to_file($project_io_path, $project_io);

      foreach my $path (sort keys %$remove) {
        print "rm $path" . $nl;
        unlink $path;
      }
    }
  }
}
sub default_target {
  my ($root_cmd, $project, $inputs) = @_;
  my $output;
  if ($$root_cmd{'project.target'}) {
    $output = $$root_cmd{'project.target'};
  } else {
    $output = &project_base($inputs);
    if ($$project{'is-lib'}) {
      $output .= ".$so_ext";
      print STDERR $0 . ": info: using implicit lib name: $output" . $nl;
    } else {
      print STDERR $0 . ": info: using implicit exe name: $output" . $nl;
    }
  }
  return $output;
}
