#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_compiler;
my $so_ext;
my $o_ext;
my $cc_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_compiler = &platform("$gbl_prefix/lib/dakota/platform.yaml")
  or die "&platform(\"$gbl_prefix/lib/dakota/platform.yaml\") failed: $!" . $nl;
{
  $so_ext = &dakota::util::var($gbl_compiler, 'so_ext', 'so'); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_compiler, 'o_ext', 'o'); # could be .bc or .lto
  $cc_ext = &dakota::util::var($gbl_compiler, 'cc_ext', 'cc');
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long qw(GetOptionsFromArray);
$Getopt::Long::ignorecase = 0;

sub path_opt {
  my ($cmd, $ir, $short, $long, $info) = @_;
  $short = 'no-such-short-opt' if !$short;
  my $arg = $$cmd[$$ir];
  my $pair;
  if (0) {
  } elsif ($arg =~ /^(-$short|--$long=)([^\s]+)$/) {
    $pair = [$$ir, $2];
  } elsif ($arg =~ /^-$short|--$long$/) {
    $pair = [$$ir + 1, $$cmd[$$ir + 1]];
    $$ir++;
  }
  if ($pair) {
    if (exists $$info{$long} && 'ARRAY' ne ref($$info{$long})) {
      $$info{$long} = $pair;
    } else {
      if (!defined $$info{$long}) {
        $$info{$long} = [];
      }
      &add_last($$info{$long}, $pair);
    }
  }
  return $pair;
}
sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?([^\s]+?)\.[^\s]+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub translate_dk_to_cc {
  my ($cmd, $cc_paths) = @_;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if ($arg =~ /\.dk$/) {
      my $cc_path = &remove_first($cc_paths);
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
    }
  }
}
sub build_precompile_cmd_info {
  my ($dakota_opts, $info, $ordered_input_args) = @_;
  my $parts = &parts($$dakota_opts{'parts'}[0]);
  my $root_cmd = {
    'opts'=> {
      'output' => undef,
    },
    'parts.build-dir' =>          $$parts{'build-dir'},
    'parts.source-dir' =>         $$parts{'source-dir'},
    'parts.current-source-dir' => $$parts{'current-source-dir'},
  };
  $$root_cmd{'args'} = $ordered_input_args;
  if ($$dakota_opts{'parts'}[0]) {
    $$root_cmd{'opts'}{'parts'} = $$dakota_opts{'parts'}[0];
  }
  if ($$info{'output'} && $$info{'output'}[1]) {
    $$root_cmd{'opts'}{'output'} = $$info{'output'}[1];
  }
  return $root_cmd;
}
sub extract_dakota_opts {
  my ($cmd) = @_;
  #  $var4opt_pat: rhs/value == 0 means do not extract
  my $var4opt_pat = { 'parts=s' => 1,
                      'cxx=s' => 1,
                    };
  my $var4opt = {};
  foreach my $opt_pat (keys %$var4opt_pat) {
    if ($opt_pat =~ /^(.+?)=s$/) {
      $$var4opt{$1} = 1;
    } else {
      $$var4opt{$opt_pat} = 0;
    }
  }
  my $info = {};
  my $to_remove = [];
  my $cmd_len = scalar @$cmd;
  for (my $i = 0; $i < @$cmd; ) {
    my $opt = $$cmd[$i] =~ s/^--(.+?)(=.*)?$/$1/r;
    if (exists $$var4opt{$opt}) {
      my $opt_has_rhs = $$var4opt{$opt};
      if (0) {
      } elsif ($$cmd[$i] =~ /^--$opt=(.*)$/) { # --opt=rhs
        my $rhs = $1;
        die if ! $opt_has_rhs;
        die if $rhs eq '';
        $$info{$opt} = [] if !exists $$info{$opt};
        &add_last($$info{$opt}, $rhs);
        &add_first($to_remove, $i);
      } elsif ($$cmd[$i] =~ /^--$opt$/) {
        $$info{$opt} = [] if !exists $$info{$opt};
        if ($opt_has_rhs) { # --opt rhs
          die if ! ($i + 1 < $cmd_len);
          die if $$cmd[$i +1] =~ /^-/;
          &add_last($$info{$opt}, $$cmd[$i + 1]);
          &add_first($to_remove, $i);
          &add_first($to_remove, $i + 1);
        } else { # --opt
          &add_first($to_remove, $i);
        }
      }
    }
    $i++;
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  return $info;
}
sub detect_cxx_opts {
  my ($cmd, $info) = @_;
  my $num_dk_files = 0;
  $$info{'output'} = undef;
  $$info{'input-pairs'} = [];
  my $ordered_input_args = [];
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    my $pair;
    if (&path_opt($cmd, \$i, 'o', 'output', $info)) {
    } elsif ($arg !~ /^-/) {
      if ($arg =~ /^([^\s]+?\.(dk|$cc_ext|$o_ext|$so_ext))$/) {
        $pair = [$i, $arg];
        &add_last($$info{'input-pairs'}, $pair);
        &add_last($ordered_input_args, $$pair[1]);
        if ($arg =~ /\.dk$/) {
          $num_dk_files++;
        }
      }
    }
  }
  return ($num_dk_files, $ordered_input_args);
}
sub dakota_io_path_from_parts_path {
  my ($parts_path) = @_;
  my $parts = &parts($parts_path);
  if (! $$parts{'build-dir'}) {
    $$parts{'build-dir'} = &build_dir();
  }
  my $current_source_dir = $$parts{'current-source-dir'};
  my $force;
  my $dakota_io_path = $$parts{'build-dir'} . '/dakota.io';
  return $dakota_io_path;
}
sub is_so_path {
  my ($name) = @_;
  # linux and darwin so-regexs are combined
  my $result = $name =~ m=^(.*/)?(lib([.\w-]+))(\.$so_ext((\.\d+)+)?|((\.\d+)+)?\.$so_ext)$=; # so-regex
  #my $libname = $2 . ".$so_ext";
  return $result;
}
sub cxx_argv_from_argv {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  my $dakota_opts = &extract_dakota_opts($cmd);
  my $cxx_argv = [@$cmd];
  $$cxx_argv[0] = $$dakota_opts{'cxx'}[0];
  my $info = {};
  my ($num_dk_files, $ordered_input_args) = &detect_cxx_opts($cxx_argv, $info);
  my $cc_paths = [];
  if ($num_dk_files) {
    my $precompile_cmd_info = &build_precompile_cmd_info($dakota_opts, $info, $ordered_input_args);
    if (0) {
      $Data::Dumper::Indent = 0;
      print '# ' . &Dumper($precompile_cmd_info) . $nl;
      $Data::Dumper::Indent = 1;
    }
    my $exit_val;
   #if ($$precompile_cmd_info{'opts'}{'parts'}) {
   #  my ($parts, $dakota_io) = &use_parts($precompile_cmd_info);
   #}
   #($exit_val, $cc_paths) = &start_cmd($precompile_cmd_info, $parts);
    ($exit_val, $cc_paths) = &exec_cmd_info($precompile_cmd_info);
    exit $exit_val if $exit_val;
  }
  if (0 != @$cc_paths) {
    &translate_dk_to_cc($cxx_argv, $cc_paths);
  }
  return $cxx_argv;
}
sub has_cxx_opt {
  my ($argv) = @_;
  foreach my $arg (@$argv) {
    return 1 if $arg =~ /^--cxx(=.*)?$/;
  }
  return 0;
}
sub use_parts {
  my ($root_cmd) = @_;
  my $parts = &set_global_parts($$root_cmd{'opts'}{'parts'});
  $$parts{'srcs'} = [] if ! $$parts{'srcs'};
  $$parts{'lib-files'} = [] if ! $$parts{'lib-files'};
  $$parts{'current-source-dir'} = &relpath($$parts{'current-source-dir'});
  $$parts{'source-dir'} =         &relpath($$parts{'source-dir'});
  if (! $$parts{'build-dir'}) {
    $$parts{'build-dir'} = &build_dir();
  }
  $$parts{'inputs'} = [ @{$$parts{'srcs'}}, @{$$parts{'lib-files'}} ];
  $$parts{'inputs'} = &adjust_paths($$parts{'current-source-dir'}, $$parts{'inputs'});
  $$parts{'srcs'} =   &adjust_paths($$parts{'current-source-dir'}, $$parts{'srcs'});
  if (! -e $$parts{'build-dir'}) {
    &make_dir($$parts{'build-dir'});
  }
  $$root_cmd{'parts.current-source-dir'} = $$parts{'current-source-dir'};
  $$root_cmd{'parts.source-dir'} =         $$parts{'source-dir'};
  $$root_cmd{'parts.inputs'} =             $$parts{'inputs'};
  $$root_cmd{'parts.build-dir'} =          $$parts{'build-dir'};
  $$root_cmd{'io'} =                       $$parts{'build-dir'} . '/dakota.io';
  my $dakota_io_path = $$root_cmd{'io'};
  if (! -e $dakota_io_path) {
    # dk2ast : $foo{'dk'}{$dk_path}{'ast'}{$ast_path}
    my $default_dakota_io = {
      'precompile' =>         {},
      'cwd' =>                &cwd(),
      'build-dir' =>          $$parts{'build-dir'},
      'current-source-dir' => $$parts{'current-source-dir'},
      'source-dir' =>         $$parts{'source-dir'},
    };
    &dakota::util::dakota_io_to_file($dakota_io_path, $default_dakota_io);
  }
  my $dakota_io = &dakota::util::dakota_io_from_file($dakota_io_path);
  if ($$parts{'build-dir'}) {
    $$dakota_io{'build-dir'} = &canon_path($$parts{'build-dir'});
  }
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  return ($parts, $dakota_io);
} # use_parts
sub clean {
  my ($root_cmd, $parts, $dakota_io, $dakota_io_path) = @_;
  if ($dakota_io) {
    if (0) {
      if ($$dakota_io{'build-dir'} && $$dakota_io{'build-dir'} ne '.') {
        print "rm -r $$dakota_io{'build-dir'}" . $nl;
        `rm -r $$dakota_io{'build-dir'}`;
      }
    }
    if (1) { # cmake writes .o files in its own build dir
      &clean_paths($dakota_io, $dakota_io_path, 'precompile', 'target-src');
    }
  }
}
sub clean_paths {
  my ($dakota_io, $dakota_io_path, $key, $extra_key) = @_;
  my $values = [values %{$$dakota_io{$key}}];
  $$dakota_io{$key} = {};
  if ($extra_key && $$dakota_io{$extra_key}) {
    &add_last($values, $$dakota_io{$extra_key});
    delete $$dakota_io{$extra_key};
  }
  my $remove = {};
  foreach my $out_path (@$values) {
    if (-e $out_path) {
      $$remove{$out_path} = undef;
    }
  }
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  foreach my $path (sort keys %$remove) {
    print "rm $path" . $nl;
    unlink $path;
  }
}
sub cmd_info_from_argv {
  my ($argv) = @_;
  my $root_cmd = {
    'asts' => [],
    'inputs' => [],
    'lib-files' => [],
    'opts' => {
    }
  };
  &GetOptionsFromArray($argv, $$root_cmd{'opts'},
              'output=s',  # gcc-like

              'path-only',
              'parts=s',
              'target-ast',
              'target-hdr',
              'target-src',

              'clean',          # make target like
              'echo-inputs',    #
              'silent',         #
              #'compiler-flags=s',     # similiar to env vars CXXFLAGS & EXTRA_CXXFLAGS
              #'compiler=s',           # similiar to env var CXX
              #'environment-overrides' # make-like
              #'for-compiler=s',       # gcc-like (--for-linker <>)
              #'for-linker=s',         # gcc-like
              #'jobs'                  # make-like
              #'linker-flags=s',       # similiar to env vars LDFLAGS & EXTRA_LDFLAGS
              #'linker=s',             # similiar to env var LD
              #'pie'                   # ld-like
              #'runpath=s',            # gcc-like (--for-linker -R|-rpath --for-linker <>), ld-like (-R|-rpath <>)
              #'touch'                 # make-like
            );
  $$root_cmd{'args'} = $argv;
  return $root_cmd;
}
sub exec_cmd_info {
  my ($root_cmd) = @_;
  &path_only($root_cmd) if $$root_cmd{'opts'}{'path-only'};
  $$root_cmd{'inputs'} = [] if ! $$root_cmd{'inputs'};
  if ($$root_cmd{'opts'}{'parts'}) {
    $$root_cmd{'opts'}{'parts'} = &relpath($$root_cmd{'opts'}{'parts'});
  }
  &set_root_cmd($root_cmd);

  # --quiet
  # --help
  # --verbose

  # 1/1: one  input,  one output
  # 1/0: one  input,  no  output
  # m/0: many inputs, no  output
  # m/1: many inputs, one output (directory)

  my $rel_argv = [map { &relpath($_) } @{$$root_cmd{'args'}}];
  my $inputs = &normalize_paths($rel_argv);
  my ($parts, $dakota_io);

  if ($$root_cmd{'opts'}{'parts'}) {
    ($parts, $dakota_io) = &use_parts($root_cmd);
  }
  my $dakota_io_path = &dakota_io_path_from_parts_path($$root_cmd{'opts'}{'parts'});
  if ($$root_cmd{'opts'}{'clean'}) {
    &clean($root_cmd, $parts, $dakota_io, $dakota_io_path);
    exit 0;
  }
  $inputs = &normalize_paths($inputs);

  if (0) {
    my $stuff = {};
    $$stuff{'cwd'} = &getcwd();
    $$stuff{'parts-dir'} = &dir_part($$root_cmd{'opts'}{'parts'});
    $$stuff{'rel-dir'} = &relpath($$stuff{'parts-dir'}, $$stuff{'cwd'});
    #&dmp($stuff);
    my $dir = $$stuff{'rel-dir'};
    if (! $dir) {
      $dir = &getcwd();
    } elsif (! &is_abs($dir)) {
      $dir = &getcwd() . '/' . $dir;
    }
    for (my $i = 0; $i < @{$$root_cmd{'parts.inputs'}}; $i++) {
      my $parts_input = $$root_cmd{'parts.inputs'}[$i];
      if (! &is_abs($parts_input)) {
        my $input = $dir . '/' . $parts_input;
        if (! -e $input) {
          print STDERR $0 . ": error: no-such-file: $input" . $nl;
        }
        $$root_cmd{'parts.inputs'}[$i] = $input;
      }
    }
  }
  $$root_cmd{'inputs'} = [ @$inputs, @{$$root_cmd{'inputs'}} ];

  &normalize_paths($root_cmd, 'inputs');
  #print STDERR 'root_cmd: ' . &Dumper($root_cmd);
  #print STDERR 'parts: ' .  &Dumper($parts);
  die if ! $$root_cmd{'parts.build-dir'};
  die if ! $$root_cmd{'parts.current-source-dir'};
  die if ! $$root_cmd{'parts.source-dir'};
  die if ! $$parts{'build-dir'};
  die if ! $$parts{'current-source-dir'};
  die if ! $$parts{'source-dir'};
  my ($exit_val, $cc_files) = &dakota::dakota::start_cmd($root_cmd, $parts);
  return ($exit_val, $cc_files);
}
sub verbose_exec {
  my ($argv, $should_echo) = @_;
  if ($should_echo) {
    print '# ' . join(' ', @$argv) . $nl;
  }
  my $exit_val = system(@$argv);
  return $exit_val;
}
sub start {
  my ($argv) = @_;
  if (&has_cxx_opt($argv)) {
    my $cxx_argv = &cxx_argv_from_argv($argv); # calls exec_cmd_info() => start_cmd()
    my $exit_val = &verbose_exec($cxx_argv, $ENV{'DAKOTA_VERBOSE'});
    exit $exit_val >> 8;
  } else {
    my $cmd_info =              &cmd_info_from_argv($argv);
    my ($exit_val, $cc_files) = &exec_cmd_info($cmd_info); # calls start_cmd()
    exit $exit_val;
  }
}
&start(\@ARGV);
