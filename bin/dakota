#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_platform;
my $so_ext;
my $o_ext;
my $cc_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_platform = &platform("$gbl_prefix/lib/dakota/platform.yaml")
  or die "&platform(\"$gbl_prefix/lib/dakota/platform.yaml\") failed: $!" . $nl;
{
  $so_ext = &dakota::util::var($gbl_platform, 'so_ext', undef); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_platform, 'o_ext',  undef); # could also be .bc or .lto
  $cc_ext = &dakota::util::var($gbl_platform, 'cc_ext', undef);
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long qw(GetOptionsFromArray);
$Getopt::Long::ignorecase = 0;

sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?([^\s]+?)\.[^\s]+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub translate_dk_to_cc {
  my ($cmd, $cc_paths) = @_;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if ($arg =~ /\.dk$/) {
      my $cc_path = &remove_first($cc_paths);
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
    }
  }
}
sub build_precompile_cmd_info {
  my ($dakota_opts, $ordered_input_args) = @_;
  my $parts = &parts($$dakota_opts{'parts'}[0]);
  my $root_cmd = {
    'parts.build-dir' =>  $$parts{'build-dir'},
    'parts.source-dir' => $$parts{'source-dir'},
  };
  $$root_cmd{'args'} = $ordered_input_args;
  if ($$dakota_opts{'parts'}[0]) {
    $$root_cmd{'opts'}{'parts'} = $$dakota_opts{'parts'}[0];
  }
  return $root_cmd;
}
sub extract_dakota_opts {
  my ($cmd) = @_;
  #  $var4opt_pat: rhs/value == 0 means do not extract
  my $var4opt_pat = { 'parts=s' => 1,
                      'cxx=s' => 1,
                    };
  my $var4opt = {};
  foreach my $opt_pat (keys %$var4opt_pat) {
    if ($opt_pat =~ /^(.+?)=s$/) {
      $$var4opt{$1} = 1;
    } else {
      $$var4opt{$opt_pat} = 0;
    }
  }
  my $info = {};
  my $to_remove = [];
  my $cmd_len = scalar @$cmd;
  for (my $i = 0; $i < @$cmd; ) {
    my $opt = $$cmd[$i] =~ s/^--(.+?)(=.*)?$/$1/r;
    if (exists $$var4opt{$opt}) {
      my $opt_has_rhs = $$var4opt{$opt};
      if (0) {
      } elsif ($$cmd[$i] =~ /^--$opt=(.*)$/) { # --opt=rhs
        my $rhs = $1;
        die if ! $opt_has_rhs;
        die if $rhs eq '';
        $$info{$opt} = [] if !exists $$info{$opt};
        &add_last($$info{$opt}, $rhs);
        &add_first($to_remove, $i);
      } elsif ($$cmd[$i] =~ /^--$opt$/) {
        $$info{$opt} = [] if !exists $$info{$opt};
        if ($opt_has_rhs) { # --opt rhs
          die if ! ($i + 1 < $cmd_len);
          die if $$cmd[$i +1] =~ /^-/;
          &add_last($$info{$opt}, $$cmd[$i + 1]);
          &add_first($to_remove, $i);
          &add_first($to_remove, $i + 1);
        } else { # --opt
          &add_first($to_remove, $i);
        }
      }
    }
    $i++;
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  return $info;
}
sub dk_src_files {
  my ($cmd) = @_;
  my $ordered_input_args = [];
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    if ($arg =~ /^([^\s]+?(\.dk))$/) {
      $arg = Cwd::abs_path($arg) if ! &is_abs($arg); # added for ninja build system
      &add_last($ordered_input_args, $arg);
    }
  }
  return $ordered_input_args;
}
sub dakota_io_path_from_parts_path {
  my ($parts_path) = @_;
  my $parts = &parts($parts_path);
  my $force;
  my $dakota_io_path = $$parts{'build-dir'} . '/dakota.io';
  return $dakota_io_path;
}
sub is_so_path {
  my ($name) = @_;
  # linux and darwin so-regexs are combined
  my $result = $name =~ m=^(.*/)?(lib([.\w-]+))(\.$so_ext((\.\d+)+)?|((\.\d+)+)?\.$so_ext)$=; # so-regex
  #my $libname = $2 . ".$so_ext";
  return $result;
}
sub cxx_argv_from_argv {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  my $dakota_opts = &extract_dakota_opts($cmd);
  my $cxx_argv = [@$cmd];
  $$cxx_argv[0] = $$dakota_opts{'cxx'}[0];
  my $ordered_dk_src_files = &dk_src_files($cxx_argv);
  my $cc_paths = [];
  if (scalar @$ordered_dk_src_files) {
    my $precompile_cmd_info = &build_precompile_cmd_info($dakota_opts, $ordered_dk_src_files);
    if (0) {
      $Data::Dumper::Indent = 0;
      print '# ' . &Dumper($precompile_cmd_info) . $nl;
      $Data::Dumper::Indent = 1;
    }
    my $exit_val;
   #if ($$precompile_cmd_info{'opts'}{'parts'}) {
   #  my ($parts, $dakota_io) = &use_parts($precompile_cmd_info);
   #}
   #($exit_val, $cc_paths) = &start_cmd($precompile_cmd_info, $parts);
    $cc_paths = &exec_cmd_info($precompile_cmd_info);
  }
  if (0 != @$cc_paths) {
    &translate_dk_to_cc($cxx_argv, $cc_paths);
  }
  return $cxx_argv;
}
sub has_cxx_opt {
  my ($argv) = @_;
  foreach my $arg (@$argv) {
    return 1 if $arg =~ /^--cxx(=.*)?$/;
  }
  return 0;
}
sub use_parts {
  my ($root_cmd) = @_;
  my $parts = &set_global_parts($$root_cmd{'opts'}{'parts'});
  $$parts{'srcs'} = [] if ! $$parts{'srcs'};
  $$parts{'lib-files'} = [] if ! $$parts{'lib-files'};
  if (! -e $$parts{'build-dir'}) {
    &make_dir($$parts{'build-dir'});
  }
  $$root_cmd{'parts.source-dir'} = $$parts{'source-dir'};
  $$root_cmd{'parts.inputs'} =             $$parts{'inputs'};
  $$root_cmd{'parts.build-dir'} =          $$parts{'build-dir'};
  $$root_cmd{'io'} =                       $$parts{'build-dir'} . '/dakota.io';
  my $dakota_io_path = $$root_cmd{'io'};
  if (! -e $dakota_io_path) {
    # dk2ast : $foo{'dk'}{$dk_path}{'ast'}{$ast_path}
    my $default_dakota_io = {
      'precompile' =>         {},
      'cwd' =>                &cwd(),
      'build-dir' =>          $$parts{'build-dir'},
      'source-dir' => $$parts{'source-dir'},
    };
    &dakota::util::dakota_io_to_file($dakota_io_path, $default_dakota_io);
  }
  my $dakota_io = &dakota::util::dakota_io_from_file($dakota_io_path);
  if ($$parts{'build-dir'}) {
    $$dakota_io{'build-dir'} = &canon_path($$parts{'build-dir'});
  }
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  return ($parts, $dakota_io);
} # use_parts
sub clean {
  my ($root_cmd, $parts, $dakota_io, $dakota_io_path) = @_;
  if ($dakota_io) {
    if (0) {
      if ($$dakota_io{'build-dir'} && $$dakota_io{'build-dir'} ne '.') {
        print "rm -r $$dakota_io{'build-dir'}" . $nl;
        `rm -r $$dakota_io{'build-dir'}`;
      }
    }
    if (1) { # cmake writes .o files in its own build dir
      &clean_paths($dakota_io, $dakota_io_path, 'precompile', 'target-src');
    }
  }
}
sub clean_paths {
  my ($dakota_io, $dakota_io_path, $key, $extra_key) = @_;
  my $values = [values %{$$dakota_io{$key}}];
  $$dakota_io{$key} = {};
  if ($extra_key && $$dakota_io{$extra_key}) {
    &add_last($values, $$dakota_io{$extra_key});
    delete $$dakota_io{$extra_key};
  }
  my $remove = {};
  foreach my $out_path (@$values) {
    if (-e $out_path) {
      $$remove{$out_path} = undef;
    }
  }
  &dakota::util::dakota_io_to_file($dakota_io_path, $dakota_io);
  foreach my $path (sort keys %$remove) {
    print "rm $path" . $nl;
    unlink $path;
  }
}
sub cmd_info_from_argv {
  my ($argv) = @_;
  my $root_cmd = {
    'asts' => [],
    'inputs' => [],
    'lib-files' => [],
    'opts' => {
    }
  };
  &GetOptionsFromArray($argv, $$root_cmd{'opts'},
              'output=s',  # gcc-like

              'path-only',
              'parts=s',
              'target-ast', # mainly for debugging
              'target-hdr',
              'target-src',

              #'clean',          # make target like
            );
  $$root_cmd{'args'} = $argv;
  return $root_cmd;
}
sub exec_cmd_info {
  my ($root_cmd) = @_;
  &path_only($root_cmd) if $$root_cmd{'opts'}{'path-only'};
  $$root_cmd{'inputs'} = [] if ! $$root_cmd{'inputs'};
  &set_root_cmd($root_cmd);

  my $inputs = &normalize_paths($$root_cmd{'args'});
  my ($parts, $dakota_io);

  if ($$root_cmd{'opts'}{'parts'}) {
    ($parts, $dakota_io) = &use_parts($root_cmd);
  }
  my $dakota_io_path = &dakota_io_path_from_parts_path($$root_cmd{'opts'}{'parts'});
  if ($$root_cmd{'opts'}{'clean'}) {
    &clean($root_cmd, $parts, $dakota_io, $dakota_io_path);
    exit 0;
  }
  $inputs = &normalize_paths($inputs);
  $$root_cmd{'inputs'} = [ @$inputs, @{$$root_cmd{'inputs'}} ];
  &normalize_paths($root_cmd, 'inputs');
  #print STDERR 'root_cmd: ' . &Dumper($root_cmd);
  #print STDERR 'parts: ' .  &Dumper($parts);
  die if ! $$root_cmd{'parts.build-dir'};
  die if ! $$root_cmd{'parts.source-dir'};
  die if ! $$parts{'build-dir'};
  die if ! $$parts{'source-dir'};
  my $cc_files = &dakota::dakota::start_cmd($root_cmd, $parts);
  return (0, $cc_files);
}
sub start {
  my ($argv) = @_;
  if (&has_cxx_opt($argv)) {
    my $cxx_argv = &cxx_argv_from_argv($argv); # calls exec_cmd_info() => start_cmd()
    my $exit_val = &verbose_exec($cxx_argv); # g++/clang++
    exit 1 if $exit_val;
  } else {
    my $cmd_info = &cmd_info_from_argv($argv);
    my $cc_files = &exec_cmd_info($cmd_info); # calls start_cmd()
  }
  exit 0;
}
&start(\@ARGV);
