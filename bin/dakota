#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
use sort 'stable';
use Cwd;

my $gbl_prefix;
my $gbl_compiler;
my $so_ext;
my $o_ext;
my $cc_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
#use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };

use dakota::dakota;
use dakota::parse;
use dakota::util;

my ( $id,  $mid,  $bid,  $tid,
    $rid, $rmid, $rbid, $rtid) = &ident_regex();

$gbl_compiler = do "$gbl_prefix/lib/dakota/compiler-command-line.json"
  or die "do $gbl_prefix/lib/dakota/compiler-command-line.json failed: $!" . $nl;
{
  my $platform = do "$gbl_prefix/lib/dakota/platform.json"
    or die "do $gbl_prefix/lib/dakota/platform.json failed: $!" . $nl;
  my ($key, $values);
  while (($key, $values) = each (%$platform)) {
    $$gbl_compiler{$key} = $values;
  }
  $so_ext = &dakota::util::var($gbl_compiler, 'so_ext', 'so'); # default dynamic shared object/library extension
  $o_ext =  &dakota::util::var($gbl_compiler, 'o_ext', 'o'); # could be .bc or .lto
  $cc_ext = &dakota::util::var($gbl_compiler, 'cc_ext', 'cc');
}
use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1; # default = 2

use Getopt::Long qw(GetOptionsFromArray);
$Getopt::Long::ignorecase = 0;

my $default_project_path = 'dakota.project';

sub path_opt {
  my ($cmd, $ir, $short, $long, $info) = @_;
  $short = 'no-such-short-opt' if !$short;
  my $arg = $$cmd[$$ir];
  my $pair;
  if (0) {
  } elsif ($arg =~ /^(-$short|--$long=)([^\s]+)$/) {
    $pair = [$$ir, $2];
  } elsif ($arg =~ /^-$short|--$long$/) {
    $pair = [$$ir + 1, $$cmd[$$ir + 1]];
    $$ir++;
  }
  if ($pair) {
    if (exists $$info{$long} && 'ARRAY' ne ref($$info{$long})) {
      $$info{$long} = $pair;
    } else {
      if (!defined $$info{$long}) {
        $$info{$long} = [];
      }
      &add_last($$info{$long}, $pair);
    }
  }
  return $pair;
}
sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?([^\s]+?)\.[^\s]+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub translate_dk_to_cc {
  my ($cmd, $cc_paths) = @_;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if ($arg =~ /\.dk$/) {
      my $cc_path = &remove_first($cc_paths);
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
    }
  }
}
sub build_precompile_cmd_info {
  my ($dakota_opts, $info, $ordered_input_args) = @_;
  my $root_cmd = {
    'opts'=> {
      'found-library' => [],
      'output' => undef,
    },
    'inputs' => [],
  };
  $$root_cmd{'opts'}{'precompile'} = 1;
  $$root_cmd{'args'} = $ordered_input_args;
  if ($$dakota_opts{'project'}[0]) {
    $$root_cmd{'opts'}{'project'} = $$dakota_opts{'project'}[0];
  }
  if ($$dakota_opts{'found-library'}) {
    $$root_cmd{'opts'}{'found-library'} = $$dakota_opts{'found-library'}; # deep_copy
  }
  if ($$info{'major-mode'} && $$info{'major-mode'}[1]) {
    $$root_cmd{'opts'}{$$info{'major-mode'}[1]} = 1;
  }
  if ($$info{'output'} && $$info{'output'}[1]) {
    $$root_cmd{'opts'}{'output'} = $$info{'output'}[1];
  }
  return $root_cmd;
}
sub extract_dakota_opts {
  my ($cmd) = @_;
  #  $var4opt_pat: rhs/value == 0 means do not extract
  my $var4opt_pat = { 'project=s' => 1,
                      'cxx=s' => 1,
                      'found-library=s' => 1,
                    };
  my $var4opt = {};
  foreach my $opt_pat (keys %$var4opt_pat) {
    if ($opt_pat =~ /^(.+?)=s$/) {
      $$var4opt{$1} = 1;
    } else {
      $$var4opt{$opt_pat} = 0;
    }
  }
  my $info = {};
  my $to_remove = [];
  my $cmd_len = scalar @$cmd;
  for (my $i = 0; $i < @$cmd; ) {
    my $opt = $$cmd[$i] =~ s/^--(.+?)(=.*)?$/$1/r;
    if (exists $$var4opt{$opt}) {
      my $opt_has_rhs = $$var4opt{$opt};
      if (0) {
      } elsif ($$cmd[$i] =~ /^--$opt=(.*)$/) { # --opt=rhs
        my $rhs = $1;
        die if ! $opt_has_rhs;
        die if $rhs eq '';
        $$info{$opt} = [] if !exists $$info{$opt};
        &add_last($$info{$opt}, $rhs);
        &add_first($to_remove, $i);
      } elsif ($$cmd[$i] =~ /^--$opt$/) {
        $$info{$opt} = [] if !exists $$info{$opt};
        if ($opt_has_rhs) { # --opt rhs
          die if ! ($i + 1 < $cmd_len);
          die if $$cmd[$i +1] =~ /^-/;
          &add_last($$info{$opt}, $$cmd[$i + 1]);
          &add_first($to_remove, $i);
          &add_first($to_remove, $i + 1);
        } else { # --opt
          &add_first($to_remove, $i);
        }
      }
    }
    $i++;
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  return $info;
}
my $major_mode_tbl = {
  '-c'        => 'compile',
  '--compile' => 'compile',
  '-shared'   => 'shared',
  '--shared'  => 'shared',
  '-dynamic'  => 'dynamic',
  '--dynamic' => 'dynamic',
};
sub detect_cxx_opts {
  my ($cmd, $info) = @_;
  my $num_dk_files = 0;
  $$info{'output'} = undef;
  $$info{'input-pairs'} = [];
  my $ordered_input_args = [];
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    my $pair;
    if (0) {
    } elsif ($$major_mode_tbl{$arg}) {
      $$info{'major-mode'} = [$i, $$major_mode_tbl{$arg}];
    #} elsif ($pair = &path_opt($cmd, \$i, 'L', 'library-directory', $info)) {
    #  &add_last($ordered_input_args, ('--library-directory', $$pair[1]));
    #} elsif ($pair = &path_opt($cmd, \$i, 'l', 'library',           $info)) {
    #  &add_last($ordered_input_args, ('--library', $$pair[1]));
    #} elsif (&path_opt($cmd, \$i, 'D', 'define-macro',      $info)) {
    } elsif (&path_opt($cmd, \$i, 'o', 'output',            $info)) {
    } elsif ($arg !~ /^-/) {
      if ($arg =~ /^([^\s]+?\.(dk|$cc_ext|$o_ext|$so_ext))$/) {
        $pair = [$i, $arg];
        &add_last($$info{'input-pairs'}, $pair);
        &add_last($ordered_input_args, $$pair[1]);
        if ($arg =~ /\.dk$/) {
          $num_dk_files++;
        }
      }
    }
  }
  return ($num_dk_files, $ordered_input_args);
}
sub project_io_path_from_project_path {
  my ($project_path) = @_;
  my $project = &dakota::util::scalar_from_file($project_path);
  if (! $$project{'builddir'}) {
    $$project{'builddir'} = &builddir();
  }
  my $source_dir = &dir_part(&relpath($project_path));
  my $force;
  my $builddir = &adjust_path($source_dir, $$project{'builddir'}, $force = 1);
  my $project_io_path = $builddir . '/dakota.io';
  return $project_io_path;
}
sub is_so_path {
  my ($name) = @_;
  # linux and darwin so-regexs are combined
  my $result = $name =~ m=^(.*/)?(lib([.\w-]+))(\.$so_ext((\.\d+)+)?|((\.\d+)+)?\.$so_ext)$=; # so-regex
  #my $libname = $2 . ".$so_ext";
  return $result;
}
sub cxx_argv_from_argv {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  my $dakota_opts = &extract_dakota_opts($cmd);
  my $cxx_argv = [@$cmd];
  $$cxx_argv[0] = $$dakota_opts{'cxx'}[0];
  my $info = {};
  my ($num_dk_files, $ordered_input_args) = &detect_cxx_opts($cxx_argv, $info);
  my $cc_paths = [];
  if ($num_dk_files) {
    my $precompile_cmd_info = &build_precompile_cmd_info($dakota_opts, $info, $ordered_input_args);
    if (0) {
      $Data::Dumper::Indent = 0;
      print '# ' . &Dumper($precompile_cmd_info) . $nl;
      $Data::Dumper::Indent = 1;
    }
    my $exit_val;
   #if ($$precompile_cmd_info{'opts'}{'project'}) {
   #  my ($project, $project_io) = &use_project($precompile_cmd_info);
   #}
   #($exit_val, $cc_paths) = &start_cmd($precompile_cmd_info, $project);
    ($exit_val, $cc_paths) = &exec_cmd_info($precompile_cmd_info);
    exit $exit_val if $exit_val;
  }
  if (0 != @$cc_paths) {
    &translate_dk_to_cc($cxx_argv, $cc_paths);
  }
  return $cxx_argv;
}
sub has_cxx_opt {
  my ($argv) = @_;
  foreach my $arg (@$argv) {
    return 1 if $arg =~ /^--cxx(=.*)?$/;
  }
  return 0;
}
sub create_missing_project {
  my ($root_cmd, $inputs) = @_;
  if (0 == scalar @$inputs) {
    die "error: missing both --project <file> and input files; at least one is required.";
  }
  my $project = { 'target' => undef, 'inputs' => [], 'lib-dirs' => [], 'libs' => [],
                  'builddir' => &builddir() };
  foreach my $lib_dir (@{$$root_cmd{'opts'}{'library-directory'}}) {
    &add_last($$project{'lib-dirs'}, $lib_dir);
  }
  foreach my $library (@{$$root_cmd{'opts'}{'library'}}) {
    &add_last($$project{'libs'}, $library);
  }
  my $project_path;

  if ($$root_cmd{'opts'}{'output'}) {
    $$project{'target'} = $$root_cmd{'opts'}{'output'};
  }
  if ($$root_cmd{'opts'}{'create-project'}) {
    $project_path = $$root_cmd{'opts'}{'create-project'};
  } else {
  my $project_base;
  if ($$project{'target'}) {
    $project_base = $$project{'target'} =~ s/\.$so_ext$//r; # remove ext if present
  } else {
    $project_base = &project_base($inputs);
    if (! &is_exe($root_cmd)) {
      $$project{'target'} = $project_base . ".$so_ext";
    } else {
      $$project{'target'} = $project_base;
    }
  }
  if (! &is_exe($root_cmd)) {
    $$project{'is-lib'} = 1;
  }
  $project_path = $default_project_path;
  if (-e $project_path) {
    print STDERR $0 . ": info: found $project_path; using for missing --project <>." . $nl;
    return $project_path;
  } elsif ($$root_cmd{'opts'}{'compile'}) {
    print STDERR $0 . ": warning: missing --project <file> (creating default $project_path)." . $nl;
  } else {
    print STDERR $0 . ": info: missing --project <file> (creating default $project_path)." . $nl;
  }
  }
  # create and write a default project file
  foreach my $input (@$inputs) {
    if ($input =~ m/\.(dk|$so_ext)$/) {
      &add_last($$project{'inputs'}, $input);
    } else {
      print STDERR __FILE__ . ':' . __LINE__ . ": skipping input $input" . $nl;
    }
  }
  &scalar_to_file($project_path, $project);
  return $project_path;
}
sub project_base {
  my ($inputs) = @_;
  my $dk_path = &first_dk_path($inputs);
  my $project_base = $dk_path =~ s/\.dk$//r;
  return $project_base;
}
sub first_dk_path {
  my ($inputs) = @_;
  foreach my $input (@$inputs) {
    if (&is_dk_path($input)) {
      return $input;
    }
  }
  die;
}
sub lib_from_lib_name {
  my ($name) = @_;
  # linux and darwin so-regexs are separate
  if ($name =~ m=^(.*/)?(lib([.\w-]+))\.$so_ext((\.\d+)+)?$= ||
      $name =~ m=^(.*/)?(lib([.\w-]+))((\.\d+)+)?\.$so_ext$=) { # so-regex
    return $name;
  }
  return 'lib' . $name . ".$so_ext";
}
sub exe_from_exe_name {
  my ($name) = @_;
  return $name;
}
sub project_adjust_paths {
  my ($project) = @_;
  return if $$project{'source-dir'} eq '.';
  my $force;
  $$project{'inputs'} =       &adjust_paths($$project{'source-dir'}, $$project{'inputs'});
  $$project{'srcs'} =         &adjust_paths($$project{'source-dir'}, $$project{'srcs'});
  $$project{'include-dirs'} = &adjust_paths($$project{'source-dir'}, $$project{'include-dirs'}, $force = 1);
  $$project{'builddir'} =     &adjust_path( $$project{'source-dir'}, $$project{'builddir'}, $force = 1);
}
sub use_project {
  my ($root_cmd) = @_;
  my $project = &set_global_project($$root_cmd{'opts'}{'project'});
  $$project{'source-dir'} = &dir_part(&relpath($$root_cmd{'opts'}{'project'}));
  if (! $$project{'builddir'}) {
    $$project{'builddir'} = &builddir();
  }
  if (! $$project{'inputs'} && $$project{'srcs'}) {
    $$project{'inputs'} = [ @{$$project{'srcs'}} ];
  }
  if ($$project{'libs'}) {
    $$project{'inputs'} = [ @{$$project{'inputs'}}, map { &lib_from_lib_name($_) } @{$$project{'libs'}} ];
  }
  if (! $$project{'target'}) {
    $$project{'target'} = &canon_path(&default_target($root_cmd, $project, $$project{'inputs'}));
  }
  if (! &is_exe($root_cmd)) {
    $$project{'is-lib'} = 1;
  }
  if (! $$project{'is-lib'} || $$project{'target'} ne 'dakota-core') {
    &add_last($$root_cmd{'inputs'}, &lib_from_lib_name('dakota-core'));
    &add_last($$project{'inputs'},  &lib_from_lib_name('dakota-core'));

    if (! $$project{'is-lib'} || $$project{'target'} ne 'dakota') {
      &add_last($$root_cmd{'inputs'}, &lib_from_lib_name('dakota'));
      &add_last($$project{'inputs'},  &lib_from_lib_name('dakota'));
    }
  }
  &project_adjust_paths($project);
  if (! -e $$project{'builddir'}) {
    &make_dir($$project{'builddir'});
  }
  $$root_cmd{'source-dir'} = $$project{'source-dir'}; # 'project.source-dir'?
  $$root_cmd{'project.inputs'} = $$project{'inputs'};
  $$root_cmd{'project.builddir'} = $$project{'builddir'};
  $$root_cmd{'project.target'} = $$project{'target'};
  $$root_cmd{'project.io'} = $$project{'builddir'} . '/dakota.io';
  my $project_io_path = $$root_cmd{'project.io'};
  if (! -e $project_io_path) {
    # dk2ast : $foo{'dk'}{$dk_path}{'ast'}{$ast_path}
    my $default_project_io = { 'compile' => {},
                               'builddir' => undef };
    &dakota::util::project_io_to_file($project_io_path, $default_project_io);
  }
  my $project_io = &dakota::util::project_io_from_file($project_io_path);
  if (1) {
    $$project_io{'link'} = $$root_cmd{'link'};
  }
  # my $l4s = $$link{'M2L'}{$$link{'S2M'}};
  if ($$project{'builddir'}) {
    $$project_io{'builddir'} = &canon_path($$project{'builddir'});
  }
  &dakota::util::project_io_to_file($project_io_path, $project_io);
  return ($project, $project_io);
} # use_project
sub project_clean {
  my ($root_cmd, $project, $project_io, $project_io_path) = @_;
  if ($project_io) {
    if (0) {
      if ($$project_io{'builddir'} && $$project_io{'builddir'} ne '.') {
        print "rm -r $$project_io{'builddir'}" . $nl;
        `rm -r $$project_io{'builddir'}`;
      }
    }
    if (1) { # cmake writes .o files in its own build dir
      if (! $$root_cmd{'opts'}{'precompile'}) {
        &project_clean_paths($project_io, $project_io_path, 'compile');
      }
      &project_clean_paths($project_io, $project_io_path, 'precompile', 'target-src');
    }
  }
}
sub project_clean_paths {
  my ($project_io, $project_io_path, $key, $extra_key) = @_;
  my $values = [values %{$$project_io{$key}}];
  $$project_io{$key} = {};
  if ($extra_key && $$project_io{$extra_key}) {
    &add_last($values, $$project_io{$extra_key});
    delete $$project_io{$extra_key};
  }
  my $remove = {};
  foreach my $out_path (@$values) {
    if (-e $out_path) {
      $$remove{$out_path} = undef;
    }
  }
  &dakota::util::project_io_to_file($project_io_path, $project_io);
  foreach my $path (sort keys %$remove) {
    print "rm $path" . $nl;
    unlink $path;
  }
}
sub default_target {
  my ($root_cmd, $project, $inputs) = @_;
  my $output;
  if ($$root_cmd{'project.target'}) {
    $output = $$root_cmd{'project.target'};
  } else {
    $output = &project_base($inputs);
    if ($$project{'is-lib'}) {
      $output .= ".$so_ext";
      print STDERR $0 . ": info: using implicit lib name: $output" . $nl;
    } else {
      print STDERR $0 . ": info: using implicit exe name: $output" . $nl;
    }
  }
  return $output;
}
sub cmd_info_from_argv {
  my ($argv) = @_;
  my $root_cmd = {
    'asts' => [],
    'inputs' => [],
    'opts' => {
      'define-macro' => [],
      'include-directory' => [ "$gbl_prefix/include" ],
      'library-directory' => [],
      'library' => [],

      'directory' => [],
      'found-library' => [],
      'var' => {},
    }
  };
  &GetOptionsFromArray($argv, $$root_cmd{'opts'},
              'define-macro=s', # gcc-like
              'include-directory=s', # gcc-like (--include-directory=<> OR -I<>)
              'library-directory=s', # gcc-like (--library-directory=<> OR -L<>)
              'library=s', # --library libssl.so equivalent to -lssl (or better -l:libssl.so on linux)
              'output=s',  # gcc-like

              'compile',        # gcc-like
              'dynamic',        # gcc-like
              'shared',         # gcc-like

              'init',
              'parse',
              'path-only',
              'precompile',     # gcc-ish (--compile)
              'project=s',
              'target',

              'clean',          # make target like
              'create-project=s',
              'directory=s',    # make-like
              'echo-inputs',    #
              'found-library=s',
              'silent',         #
              'soname=s',       # ld-like (-soname <>)
              'var=s',          # for env vars like MAKEFLAGS, etc.
              #'compiler-flags=s',     # similiar to env vars CXXFLAGS & EXTRA_CXXFLAGS
              #'compiler=s',           # similiar to env var CXX
              #'environment-overrides' # make-like
              #'for-compiler=s',       # gcc-like (--for-linker <>)
              #'for-linker=s',         # gcc-like
              #'jobs'                  # make-like
              #'linker-flags=s',       # similiar to env vars LDFLAGS & EXTRA_LDFLAGS
              #'linker=s',             # similiar to env var LD
              #'pie'                   # ld-like
              #'runpath=s',            # gcc-like (--for-linker -R|-rpath --for-linker <>), ld-like (-R|-rpath <>)
              #'touch'                 # make-like
            );
  $$root_cmd{'args'} = $argv;
  return $root_cmd;
}
sub exec_cmd_info {
  my ($root_cmd) = @_;
  $$root_cmd{'opts'}{'precompile'} = 1 if $$root_cmd{'opts'}{'target'};
  if ($$root_cmd{'opts'}{'project'}) {
    $$root_cmd{'opts'}{'project'} = &relpath($$root_cmd{'opts'}{'project'});
  } elsif (-e $default_project_path) {
    $$root_cmd{'opts'}{'project'} = $default_project_path;
  }
  &set_root_cmd($root_cmd);

  my $link = { 'order' => [] };
  foreach my $pair (@{$$root_cmd{'opts'}{'found-library'}}) {
    my ($s, $l) = split('=', $pair);
    &add_last($$link{'order'}, $s);
    my $m = &lib_from_lib_name($s);
    # $m could also be created by basename
    # but the soname aspect comes into play
    $$link{'S2M'}{$s} = $m;
    $$link{'M2L'}{$m} = $l;
  }
  $$root_cmd{'link'} = $link;
  if (0) {
  foreach my $name (@{$$root_cmd{'opts'}{'library'}}) {
    foreach my $lib_dir (@{$$root_cmd{'opts'}{'library-directory'}}) {
      # use &find_library() to resolve --library=<> that are not resolved in
      # 'found-library' above. Always use the above info over anything we do
      # here since that comes from cmake and cmake will be building the link
      # cmd so its best if we use what it gives us.
    }
  }
  }

  # --quiet
  # --help
  # --verbose

  # 1/1: one  input,  one output
  # 1/0: one  input,  no  output
  # m/0: many inputs, no  output
  # m/1: many inputs, one output (directory)

  my $rel_argv = [map { &relpath($_) } @{$$root_cmd{'args'}}];
  my $inputs = &clean_paths($rel_argv);
  my ($project, $project_io);

  if ($$root_cmd{'opts'}{'create-project'}) {
    &create_missing_project($root_cmd, $inputs);
    exit;
  }
  # create default project file when missing (when linking)
  if (!$$root_cmd{'compile'} && !$$root_cmd{'opts'}{'project'}) {
    $$root_cmd{'opts'}{'project'} = &create_missing_project($root_cmd, $inputs);
  }
  if ($$root_cmd{'opts'}{'project'}) {
    ($project, $project_io) = &use_project($root_cmd);
  }
  my $project_io_path = &project_io_path_from_project_path($$root_cmd{'opts'}{'project'});
  if ($$root_cmd{'opts'}{'clean'}) {
    &project_clean($root_cmd, $project, $project_io, $project_io_path);
    exit 0;
  }
  if ($project) {
    if (!$$root_cmd{'opts'}{'output'} && $$root_cmd{'opts'}{'compile'}) {
      if (1 == scalar @$inputs && &is_dk_path($$inputs[0])) {
        my $o_path = &o_path_from_dk_path($$inputs[0]);
        $$root_cmd{'opts'}{'output'} = $o_path; # setting default output (compile) path for single .dk input path
      }
    }
    if ($$root_cmd{'opts'}{'output'} && $$root_cmd{'opts'}{'compile'}) {
      if (1 == scalar @$inputs && &is_dk_path($$inputs[0]) && !$$root_cmd{'opts'}{'precompile'}) {
        &dakota::util::project_io_add($$root_cmd{'project.io'}, 'compile', $$inputs[0], $$root_cmd{'opts'}{'output'});
        my $original_state;
        &dakota::util::project_io_to_file($project_io_path, $project_io);
      }
    }
  }
  if (!$$root_cmd{'opts'}{'compile'} && scalar values %{$$project_io{'compile'}}) {
    &dakota::util::project_io_remove($project_io, 'compile', $inputs);
    &add_last($inputs, values %{$$project_io{'compile'}});
    foreach my $input (@{$$project{'inputs'}}) {
      if ($input =~ /\.$so_ext$/) { # is_so_path()
        &add_last($inputs, $input);
      }
    }
  }
  $inputs = &clean_paths($inputs);

  if (0) {
    my $stuff = {};
    $$stuff{'cwd'} = &getcwd();
    $$stuff{'project-dir'} = &dir_part($$root_cmd{'opts'}{'project'});
    $$stuff{'rel-dir'} = &relpath($$stuff{'project-dir'}, $$stuff{'cwd'});
    #&dmp($stuff);
    my $dir = $$stuff{'rel-dir'};
    if (! $dir) {
      $dir = &getcwd();
    } elsif (! &is_abs($dir)) {
      $dir = &getcwd() . '/' . $dir;
    }
    for (my $i = 0; $i < @{$$root_cmd{'project.inputs'}}; $i++) {
      my $project_input = $$root_cmd{'project.inputs'}[$i];
      if (! &is_abs($project_input)) {
        my $input = $dir . '/' . $project_input;
        if (! -e $input) {
          print STDERR $0 . ": error: no-such-file: $input" . $nl;
        }
        $$root_cmd{'project.inputs'}[$i] = $input;
      }
    }
  }
  if (!$$root_cmd{'opts'}{'compile'} && 1 >= scalar @$inputs) { # only the implied libdakota-core.so
    if (1 >= scalar $$root_cmd{'project.inputs'}) {
      die "$0: error: inputs are requried either in the project file or the command line." . $nl;
    } else {
      $inputs = $$root_cmd{'project.inputs'};
      $$root_cmd{'inputs'} = [];
    }
  }
  # should only reorder the .o files (between .so files) leaving the .so files in their
  # original position so the inputs should be split into separate sublist (and then sorted).
  # its OK to sort the .dk files, but we must link using the original positions.
  if (1) {
    if (!$$root_cmd{'opts'}{'precompile'}) {
      $inputs = [sort {&mtime($b) <=> &mtime($a)} @$inputs];
    }
  }
  $$root_cmd{'inputs'} = [ @$inputs, @{$$root_cmd{'inputs'}} ];
  # dakota --compile --output <> {dk}+
  # dakota --shared  --output <> {o}+ [build/+rt/<>.o] {so}*
  # dakota           --output <> {o}+ [build/+rt/<>.o] {so}*

  if (!$$root_cmd{'opts'}{'output'} && !$$root_cmd{'opts'}{'compile'}) {
    if ($$project{'target'} =~ /\.$so_ext$/) { # is_so_path()
      $$root_cmd{'opts'}{'output'} = $$project{'target'};
    } elsif ($$project{'is-lib'}) {
      $$root_cmd{'opts'}{'output'} = &lib_from_lib_name($$project{'target'});
    } else {
      $$root_cmd{'opts'}{'output'} = &exe_from_exe_name($$project{'target'});
    }
  }
  if ($$root_cmd{'opts'}{'output'}) {
    $$root_cmd{'opts'}{'output'} = &canon_path($$root_cmd{'opts'}{'output'});
  }
  if ($$root_cmd{'opts'}{'soname'}) {
    $$root_cmd{'opts'}{'soname'} = &canon_path($$root_cmd{'opts'}{'soname'});
  }
  $ENV{'CXXFLAGS'} = &dakota::util::var($gbl_compiler, 'CXXFLAGS', undef);

  &clean_paths($root_cmd, 'inputs');
  &clean_paths($$root_cmd{'opts'}, 'include-directory');
  &clean_paths($$root_cmd{'opts'}, 'library-directory');

  my $gcc_from_dakota = {
    '--include-directory' => '--include-directory', # yep, the same
    '--define-macro' =>      '--define-macro',      # yep, the same
  };

  if ($$root_cmd{'opts'}{'include-directory'}) {
    my $flags = '';
    foreach my $dir (@{$$root_cmd{'opts'}{'include-directory'}}) {
      $flags .= ' ' . $$gcc_from_dakota{'--include-directory'} . '=' . $dir;
    }
    $ENV{'CXXFLAGS'} .= $flags;
  }
  my $env_vars = { 'DK_SRC_UNIQUE_HEADER' => undef,
                   'DK_INLINE_GENERIC_FUNCS' => undef,
                   'DK_INLINE_KLASS_FUNCS' => undef,
                 };
  if ($$root_cmd{'opts'}{'define-macro'}) {
    my $flags = '';
    foreach my $mcr (@{$$root_cmd{'opts'}{'define-macro'}}) {
      $flags .= ' ' . $$gcc_from_dakota{'--define-macro'} . '=' . $mcr;
      my ($lhs, $rhs) = split(/=/, $mcr);
      if (exists $$env_vars{$lhs}) {
        $ENV{$lhs} = $rhs;
      }
    }
    $ENV{'CXXFLAGS'} .= $flags;
  }
  if ($$root_cmd{'opts'}{'directory'} && scalar @{$$root_cmd{'opts'}{'directory'}}) {
    my $initial_workdir = &getcwd();
    foreach my $dir (@{$$root_cmd{'opts'}{'directory'}}) {
      if ($dir ne '.' &&
            $dir ne './') {
        chdir $dir;
        my $current_workdir = &getcwd();
        my $reldir = File::Spec->abs2rel($current_workdir, $initial_workdir);
        $ENV{'DKT_DIR'} = $reldir;
      }
    }
  }
  #print STDERR 'root_cmd: ' . &Dumper($root_cmd);
  #print STDERR 'project: ' .  &Dumper($project);
  die if ! $$root_cmd{'source-dir'};
  die if ! $$project{'source-dir'};
  my ($exit_val, $cc_files) = &dakota::dakota::start_cmd($root_cmd, $project);
  return ($exit_val, $cc_files);
}
sub verbose_exec {
  my ($argv, $should_echo) = @_;
  if ($should_echo) {
    print '# ' . join(' ', @$argv) . $nl;
  }
  my $exit_val = system(@$argv);
  return $exit_val;
}
sub start {
  my ($argv) = @_;
  if (&has_cxx_opt($argv)) {
    my $cxx_argv = &cxx_argv_from_argv($argv); # calls exec_cmd_info() => start_cmd()
    my $exit_val = &verbose_exec($cxx_argv, $ENV{'DAKOTA_VERBOSE'});
    exit $exit_val;
  } else {
    my $cmd_info =              &cmd_info_from_argv($argv);
    my ($exit_val, $cc_files) = &exec_cmd_info($cmd_info); # calls start_cmd()
    exit $exit_val;
  }
}
&start(\@ARGV);
