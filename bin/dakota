#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

# Copyright (C) 2007-2015 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

my $gbl_prefix;

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!\n";
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};

use dakota::dakota;
use dakota::util;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1;   # default = 2

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $sysname = lc(`uname -s`);
chop $sysname;

my $CXX;
my $so_ext;

if (defined $ENV{'CXX'}) {
  $CXX = $ENV{'CXX'};
} else {
  $CXX = 'g++'; #  default
}

if (defined $ENV{'so_ext'}) {
  $so_ext = $ENV{'so_ext'};
} elsif ('darwin' eq $sysname) {
  $so_ext = 'dylib'; # darwin default
} else {
  $so_ext = 'so'; # non-darwin default
}

#if (!exists $ENV{'so_ext'}) {
  $ENV{'so_ext'} = $so_ext;
#}

#if (!exists $ENV{'CXX'}) {
  $ENV{'CXX'} = $CXX;
#} # default CXX

if (!exists $ENV{'CXXFLAGS'}) {
  $ENV{'CXXFLAGS'} = '';
} # default CXXFLAGS
if (!exists $ENV{'EXTRA_CXXFLAGS'}) {
  $ENV{'EXTRA_CXXFLAGS'} = '';
} # default EXTRA_CXXFLAGS
if (!exists $ENV{'LDFLAGS'}) {
  $ENV{'LDFLAGS'} = '';
} # default LDFLAGS
if (!exists $ENV{'EXTRA_LDFLAGS'}) {
  $ENV{'EXTRA_LDFLAGS'} = '';
} # default EXTRA_LDFLAGS

my $root_cmd = { 'reps' => [],
                 'opts' => { 'include-directory' => [],
                             'define-macro' => [],
                             'var' => {} } };

&GetOptions($$root_cmd{'opts'},
            'precompile',          # gcc-ish (--compile)
            'compile',             # gcc-like
            'shared',              # gcc-like
            'dynamic',             # gcc-like
            'soname=s',            # ld-like (-soname <>)
            'keep-going',          # make-like
            'define-macro=s',      # gcc-like
            'include-directory=s', # gcc-like
            'directory=s',         # make-like
            'output=s',            # gcc-like
            'nodefaultlibs',       # gcc-like
            'var=s',               # for env vars like MAKEFLAGS, etc.
            #'compiler=s',          # similiar to env var CXX
            #'compiler-flags=s',    # similiar to env vars EXTRA_CXXFLAGS & CXXFLAGS
            #'linker=s',            # similiar to env var LD
            #'linker-flags=s',      # similiar to env vars EXTRA_LDFLAGS & LDFLAGS
           );
# --jobs=
# --quiet
# --help
# --verbose

$$root_cmd{'inputs'} = \@ARGV;

if (!defined $$root_cmd{'opts'}{'output'} || 0 == @ARGV) {
  #`dakota --help`;
  exit 1;
}

if (!$$root_cmd{'opts'}{'compile'} && !$$root_cmd{'opts'}{'nodefaultlibs'}) {
  my $libdakota = "$gbl_prefix/lib/libdakota.$ENV{'so_ext'}";
  if ($$root_cmd{'opts'}{'output'} ne $libdakota) {
    &_add_last($$root_cmd{'inputs'}, $libdakota);
  }
}
if ($$root_cmd{'opts'}{'include-directory'}) {
  my $flags = '';
  foreach my $dir (@{$$root_cmd{'opts'}{'include-directory'}}) {
    $flags .= " --include-directory $dir";
  }
  $ENV{'EXTRA_CXXFLAGS'} .= $flags;
}
if ($$root_cmd{'opts'}{'define-macro'}) {
  my $flags = '';
  foreach my $mcr (@{$$root_cmd{'opts'}{'define-macro'}}) {
    $flags .= " --define-macro $mcr";
  }
  $ENV{'EXTRA_CXXFLAGS'} .= $flags;
}
if ($$root_cmd{'opts'}{'directory'} &&
      $$root_cmd{'opts'}{'directory'} ne '.' &&
      $$root_cmd{'opts'}{'directory'} ne './') {
  chdir $$root_cmd{'opts'}{'directory'};
  $ENV{'DKT_DIR'} = "$$root_cmd{'opts'}{'directory'}";
}
my $result = &dakota::dakota::start($root_cmd);
exit $result;
