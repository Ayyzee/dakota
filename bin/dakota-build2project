#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

use strict;
use warnings;
use Cwd;

use Fcntl qw(:DEFAULT :flock);

use Data::Dumper;
#$Data::Dumper::Pair =      ' : '
$Data::Dumper::Indent =    1; # default = 2
$Data::Dumper::Purity =    1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Sortkeys  = 1;
$Data::Dumper::Terse =     1;

my $so_ext;
my $nl = "\n";

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!\n";
  }
}
BEGIN {
  my $prefix = &dk_prefix($0);
  my $platform = do "$prefix/lib/dakota/platform.json"
    or die "do $prefix/lib/dakota/platform.json failed: $!\n";
  if ($$platform{'so_ext'}) {
    $so_ext = $$platform{'so_ext'};
  } else {
    $so_ext = 'so'; # default dynamic shared object/library extension
  }
};
sub start {
  my ($argv) = @_;
  my $build = &scalar_from_file($$argv[0]);
  my $file = $$argv[1];
  if (3 == scalar @ARGV) {
    my $name = $$argv[2];
    $build = $$build{$name};
  }
  my $opts = { 'var' => { 'DEST' =>   '',
                          'srcdir' => '.',
                          'so_ext' => $so_ext,
                        }
            };
  my $result = {};
  $$result{'inputs'} = [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'inputs'}} ] if $$build{'inputs'};
  $$result{'srcs'} =   [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'srcs'}}   ] if $$build{'srcs'};
  $$result{'libs'} =   [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'libs'}}   ] if $$build{'libs'};
  $$result{'lib-dirs'} =     [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'lib-dirs'}}     ] if $$build{'lib-dirs'};
  $$result{'include-dirs'} = [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'include-dirs'}} ] if $$build{'include-dirs'};
  $$result{'macros'} =       [ map { &canon_path(&subst($_, $$opts{'var'})) } @{$$build{'macros'}}       ] if $$build{'macros'};
  $$result{'builddir'} = &canon_path(&subst($$build{'builddir'}, $$opts{'var'})) if $$build{'builddir'};
  $$result{'output'} =   &canon_path(&subst($$build{'output'},   $$opts{'var'})) if $$build{'output'};
  $$result{'target'} =   &canon_path(&subst($$build{'target'},   $$opts{'var'})) if $$build{'target'};
  $$result{'is-lib'} =   &canon_path(&subst($$build{'is-lib'},   $$opts{'var'})) if $$build{'is-lib'};
  my $original_state;
  &scalar_to_file($file, $result, $original_state = 0);
}
sub canon_path {
  my ($path) = @_;
  if ($path) {
    $path =~ s|//+|/|g; # replace multiple /s with single /s
    $path =~ s|/+\./+|/|g; # replace /./s with single /
    $path =~ s|^\./(.+)|$1|g; # remove leading ./
    $path =~ s|(.+)/\.$|$1|g; # remove trailing /.
    $path =~ s|/+$||g; # remove trailing /s
  }
  return $path;
}
sub subst {
  my ($string, $var) = @_;
  if (! $string) {
    return $string;
  }
  while (my ($key, $element) = each %$var) {
    $string =~ s/\$$key\b/$element/g;   # support $ident   style variable
    $string =~ s/\$\($key\)/$element/g; # support $(ident) style variable
   #$string =~ s/\$\{$key\}/$element/g; # support ${ident} style variable
  }
  return $string
}
sub deep_copy {
  my ($ref, $var) = @_;
  my $result = eval &subst(&Dumper($ref), $var);
  return $result;
}
sub scalar_to_file {
  my ($file, $ref, $original_state) = @_;
  if (!defined $ref) {
    print STDERR __FILE__, ":", __LINE__, ": ERROR: scalar_to_file($ref)\n";
  }
  my $refstr = &Dumper($ref);
  if (!$original_state) {
    #$refstr =~ s/($main::seq)/&unwrap_seq($1)/ges; # unwrap sequences so they are only one line long (or one long line) :-)
  }
  if ($file) {
    open(FILE, '>', $file) or die __FILE__, ':', __LINE__, ": ERROR: $file: $!\n";
    flock FILE, 2; # LOCK_EX
    truncate FILE, 0;
  } else {
    *FILE = *STDOUT;
  }
  print FILE '# -*- mode: perl -*-' . $nl;
  print FILE $refstr;
  close FILE or die __FILE__, ":", __LINE__, ": ERROR: $file: $!\n";
}
sub scalar_from_file {
  my ($file) = @_;
  my $filestr = &filestr_from_file($file);
  $filestr = eval $filestr;

  if (!defined $filestr) {
    print STDERR __FILE__, ":", __LINE__, ": ERROR: scalar_from_file(\"$file\")\n";
  }
  return $filestr;
}
sub filestr_from_file {
  my ($file) = @_;
  undef $/; ## force files to be read in one slurp
  open FILE, "<$file" or die __FILE__, ":", __LINE__, ": ERROR: $file: $!\n";
  flock FILE, LOCK_SH;
  my $filestr = <FILE>;
  close FILE;
  return $filestr;
}
unless (caller) {
  &start(\@ARGV);
}
