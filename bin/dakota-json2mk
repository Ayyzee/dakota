#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

use strict;
use warnings;

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

#use Data::Dumper;
#$Data::Dumper::Terse =    1;
#$Data::Dumper::Useqq =    1;
#$Data::Dumper::Sortkeys = 1;

# gnu make variable assignment operators
# = or := or ::= or ?= or !=
my $EQ = '=';

sub is_scalar {
  my ($v) = @_;
  my $result = 0;
  if ('' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub is_tbl {
  my ($v) = @_;
  my $result = 0;
  if ('HASH' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub is_seq {
  my ($v) = @_;
  my $result = 0;
  if ('ARRAY' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub first_char {
  my ($str) = @_;
  return substr($str, 0, 1);
}
sub last_char {
  my ($str) = @_;
  return substr($str, -1, 1);
}
sub is_protected_name {
  my ($name) = @_;
  my $result = 0;
  if ('-' eq &first_char($name)) {
    $result = 1;
  }
  return $result;
}
sub lhs {
  my ($scopes, $opts) = @_;
  my $result;
  my $prefix = $$opts{'prefix'};

  if ($prefix) {
    $prefix =~ s/\s+//g; # warn about whitespace in prefix?
    $prefix = undef if '' eq $prefix;
  }
  if ($prefix) {
    $result = join('.', ($prefix, @$scopes));
  } else {
    $result = join('.', @$scopes);
  }
  $result = &convert($result);
  return $result;
}
sub convert {
  my ($str) = @_;
  my $result = $str;
  if (1) {
    my $trans_tbl = { '\-' => '_',
                      '\.' => '_', };
    while (($a, $b) = each (%$trans_tbl)) {
      $result =~ s/$a/$b/g;
    }
  }
  return $result;
}
sub is_valid {
  my ($str) = @_;
  my $result = 0;
  if ($str =~ /^\w+$/) {
    $result = 1;
  }
  return $result;
}
sub process_tbl {
  my ($data, $opts, $scopes) = @_;
  my $result = '';

  foreach my $name (sort keys %$data) {
    if (&is_protected_name($name)) {
      next;
    } elsif (!&is_valid(&convert($name))) {
      print STDERR "$0: warning: skipping key $name\n";
      next;
    } else {
      push @$scopes, $name;
      $_ = ref($$data{$name});
      SWITCH: {
          /^HASH$/  and $result .= &process_tbl(        $$data{$name}, $opts, $scopes), last SWITCH;
          /^ARRAY$/ and $result .= &process_seq_expr(   $$data{$name}, $opts, $scopes), last SWITCH;
                        $result .= &process_scalar_expr($$data{$name}, $opts, $scopes);
      }
      pop @$scopes;
    }
  }
  return $result;
}
# scalar is member of rhs seq
sub process_scalar {
  my ($data, $opts) = @_;
  my $result = ' ' . $data;
  return $result;
}
# scalar is rhs of expr (lhs = rhs)
sub process_scalar_expr {
  my ($data, $opts, $scopes) = @_;
  my $result = &lhs($scopes, $opts) . ' ' . $EQ . ' ' . $data . "\n"; # EOL
  return $result;
}
# seq is rhs of expr (lhs = rhs ...)
sub process_seq_expr {
  my ($data, $opts, $scopes) = @_;
  my $result = &lhs($scopes, $opts) . ' ' . $EQ;

  foreach my $element (@$data) {
    if (&is_scalar($element)) {
      $result .= &process_scalar($element, $opts);
    }
  }
  $result .= "\n"; # EOL
  return $result;
}
sub start {
  my ($argv) = @_;
  my $opts = {};
  my $scopes = [];
  &GetOptions($opts,
              'output=s',
              'prefix=s',
            );
  my $fh;

  if ($$opts{'output'}) {
    open($fh, ">", $$opts{'output'})
      or die "cannot open > $$opts{'output'}: $!";
  } else {
    open($fh, '>&', \*STDOUT)
      or die "cannot open >& STDOUT: $!";
  }
  foreach my $file (@$argv) {
    my $data = do $file or die;
    #print &Dumper($data);
    my $result =
      "# auto-generated from $file\n" .
      &process_tbl($data, $opts, $scopes);
    print $fh $result;
  }
  close($fh);
}
unless (caller) {
  &start(\@ARGV);
}
