#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

use strict;
use warnings;

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $pair_sep =    ' : ';
my $assign_sep =  ' := ';
my $rassign_sep = ' = ';

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Useqq     = 1;
$Data::Dumper::Sortkeys =  1;
$Data::Dumper::Indent =    0;
$Data::Dumper::Pair = $pair_sep;

# gnu make variable assignment operators
# = or := or ::= or ?=

sub is_scalar {
  my ($v) = @_;
  my $result = 0;
  if ('' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub is_tbl {
  my ($v) = @_;
  my $result = 0;
  if ('HASH' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub is_seq {
  my ($v) = @_;
  my $result = 0;
  if ('ARRAY' eq ref($v)) {
    $result = 1;
  }
  return $result;
}
sub first_char {
  my ($str) = @_;
  return substr($str, 0, 1);
}
sub last_char {
  my ($str) = @_;
  return substr($str, -1, 1);
}
sub is_protected_name {
  my ($name) = @_;
  my $result = 0;
  if (&first_char($name) !~ /[_a-zA-Z]/) {
    $result = 1;
  }
  return $result;
}
sub lhs {
  my ($scopes, $prefix) = @_;
  my $result;

  if ($prefix) {
    $result = join('.', ($prefix, @$scopes));
  } else {
    $result = join('.', @$scopes);
  }
  $result = &convert($result);
  return $result;
}
sub prefix {
  my ($opts) = @_;
  my $prefix = $$opts{'prefix'};

  if ($prefix) {
    $prefix =~ s/\s+//g; # warn about whitespace in prefix?
    $prefix = undef if '' eq $prefix;
  }
  return $prefix;
}
sub convert {
  my ($str) = @_;
  my $result = $str;
  if (0) { # never convert
    my $trans_tbl = {
      '\-' => '_',
      '\.' => '_',
      '\/' => '_',
      '\:' => '_',
    };
    while (($a, $b) = each (%$trans_tbl)) {
      $result =~ s|$a+|$b|g;
    }
  }
  return $result;
}
sub is_valid {
  my ($str) = @_;
  my $result = 0;
  if ($str =~ /^\w+$/) {
    $result = 1;
  }
  return 1; # always return true (is valid name)
}
sub process_tbl {
  my ($data, $opts, $scopes, $out) = @_;

  foreach my $name (sort keys %$data) {
    if (&is_protected_name($name)) {
      next;
    } elsif (!&is_valid(&convert($name))) {
      print STDERR "$0: warning: skipping key $name\n";
      next;
    } else {
      push @$scopes, $name;
      $_ = ref($$data{$name});
      SWITCH: {
          /^HASH$/  and &process_tbl(        $$data{$name}, $opts, $scopes, $out), last SWITCH;
          /^ARRAY$/ and &process_seq_expr(   $$data{$name}, $opts, $scopes, $out), last SWITCH;
                        &process_scalar_expr($$data{$name}, $opts, $scopes, $out);
      }
      pop @$scopes;
    }
  }
}
sub tsv_set {
  my ($opts, $scopes, $out) = @_;
  my $prefix = &prefix($opts);
  if ($prefix) {
    $$out{'tsv'}{$prefix}{&lhs($scopes, undef)} = &lhs($scopes, $prefix);
  }
  my $lhs = &lhs($scopes, $prefix);
  return $lhs;
}
# scalar is member of rhs seq
sub process_scalar {
  my ($data, $opts, $lhs, $out) = @_;
  push @{$$out{'mk'}{$lhs}}, $data;
}
# scalar is rhs of expr (lhs = rhs)
sub process_scalar_expr {
  my ($data, $opts, $scopes, $out) = @_;
  my $lhs = &tsv_set($opts, $scopes, $out);
  my $style;
  if ($data) {
    $$out{'mk'}{$lhs} = &mydump($data, $style = 'mk');
  }
}
# seq is rhs of expr (lhs = rhs ...)
sub process_seq_expr {
  my ($data, $opts, $scopes, $out) = @_;
  my $lhs = &tsv_set($opts, $scopes, $out);
  my $style;
  if ($data) {
    $$out{'mk'}{$lhs} = &mydump($data, $style = 'mk');
  }
}
sub mkstr {
  my ($out, $sep) = @_;
  my $result = '';
  foreach my $lhs (sort keys %{$$out{'mk'}}) {
    my $rhs = $$out{'mk'}{$lhs};
    my $style;
    if ($rhs) {
      $result .= $lhs . $sep . &mydump($rhs, $style = 'mk') . "\n";
    }
  }
  return $result;
}
sub mydump {
  my ($ref, $style) = @_;
  my $result = '';
  $result = &Dumper($ref);
  $result =~ s/\\"//g;
  $result =~ s/"//g;
  if ($style && 'mk' eq $style) {
    $result =~ s/^\[(.*)\]$/$1/;
    $result =~ s/\s*,\s*/ /g;
    $result =~ s/\\(.)/$1/g;
  }
  return $result;
}
sub start {
  my ($argv) = @_;
  my $opts = {};
  my $scopes = [];
  &GetOptions($opts,
              'key=s',
              'output=s',
              'prefix=s',
            );
  die if $$opts{'key'} && $$opts{'prefix'}; # these are mutually exclusive
  my $fh;

  if ($$opts{'output'}) {
    open($fh, ">", $$opts{'output'})
      or die "cannot open > $$opts{'output'}: $!";
  } else {
    open($fh, '>&', \*STDOUT)
      or die "cannot open >& STDOUT: $!";
  }
  my $style = 'mk';
  my $sep_from_style = {
    'mk' =>   $rassign_sep,
    'json' => $pair_sep,
  };
  foreach my $file (@$argv) {
    my $data = do $file or die;

    if ($$opts{'key'}) {
      $data = $$data{$$opts{'key'}} or die;
      $$opts{'prefix'} = $$opts{'key'};
      delete $$opts{'key'};
    }
    if (!$$opts{'prefix'}) {
      my $keys = [ keys %$data ];

      if (1 == scalar @$keys) {
        my $key = $$keys[0];

        if (&is_tbl($$data{$key}) && exists $$data{$key}{'srcs'} && exists $$data{$key}{'output'}) { # min requirements
          $$opts{'prefix'} = $key;
          $data = $$data{$key};
        }
      }
    }
    #print &Dumper($data);
    my $out = { 'mk' => {}, 'tsv' => {}, };
    &process_tbl($data, $opts, $scopes, $out);
    #print &Dumper($out);
    print $fh
      "# generated by $0 from $file\n" .
      &mkstr($out, $$sep_from_style{$style});
    if ('mk' eq $style) {
      print $fh &tsv($data, $opts, $out);
    }
  }
  close($fh);
  if ($$opts{'output'}) {
    print $$opts{'output'} . "\n";
  }
}
sub install_bnames {
  my ($data) = @_;
  my $result = [];
  foreach my $name (sort keys %{$$data{'install'} ||= {}}) {
    if (!&is_protected_name($name)) {
      if (0 < @{$$data{'install'}{$name}}) {
        push @$result, $name;
      }
    }
  }
  return $result;
}
sub tsv_install{
  my ($data, $key, $prefix) = @_;
  my $result = '';
  #my $output = &lhs(['output'], $prefix);
  my $install_elements = $$data{'install'}{$key};

  for (my $i = 0; $i < @$install_elements; $i++) {
    my $install_element = $$install_elements[$i];
    if (&is_scalar($install_element)) {
      my $info = $$install_elements[$i + 1];
      if (&is_tbl($info)) {
        my ($bname, $name); while (($bname, $name) = each (%$info)) {
          $result .= $install_element . $pair_sep . $bname . ' = ' . $name . "\n";
          $i++;
        }
      }
    }
  }
  return $result;
}
sub tsv {
  my ($data, $opts, $out) = @_;
  #print STDERR &Dumper($out);
  my $prefix = &prefix($opts);
  my $result = '';
  my $output = &lhs(['output'], $prefix);

  if ($$data{'output'}) {
    $result .= "\n";
    $result .= 'output-files' . ' += ' . "\$($output)"  . "\n";

    if ($prefix) {
      $result .= "\n";
      foreach my $bname (sort keys %{$$out{'tsv'}{$prefix}}) {
        my $name = $$out{'tsv'}{$prefix}{$bname};
        $result .= "\$($output)" . $pair_sep . $bname . ' = ' . "\$($name)" . "\n";
      }
    }
  }
  if ($$data{'install'}{'files'}) {
    my $install = &lhs(['install', 'files'], $prefix);
    $result .=  "\n";
    $result .= 'install-files' . ' += ' . "\$($install)" . "\n";
    my $bnames = &install_bnames($data);
    if (0 < @$bnames) {
      $result .= "\n";
      foreach my $name (@$bnames) {
        $result .= &tsv_install($data, $name, $prefix);
      }
    }
  }
  if ($$data{'output'}) {
    $result .= "\n";
    $result .= 'all' . $pair_sep . "\$($output)" . "\n"; # must be first target
    $result .= "\n";
    $result .= "\$($output)" . ' :';

    for my $name ('srcs', 'libs') {
      my $var = &lhs([$name], $prefix);
      $result .= ' ' . "\$($var)";
    }
    $result .=  "\n";
  }
  #print STDERR $result;
  return $result;
}
unless (caller) {
  &start(\@ARGV);
}
