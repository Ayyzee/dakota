#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

use strict;
use Cwd;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1;   # default = 2

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $opts = {};

my $subcmd_tbl = {
  'init' =>     \&subcmd_init,
  'add' =>      \&subcmd_add,
  'remove' =>   \&subcmd_remove,
  'files' =>    \&subcmd_files,
  'name' =>     \&subcmd_name,
  'set-name' => \&subcmd_set_name,
};

&GetOptions($opts,
            'repository=s',
            'var=s',
            'directory=s',
            'abs-path');

my $default_project_file = 'project.rep';

&start(\@ARGV);
sub start {
  my ($args) = @_;
  my $rep_file = $default_project_file;
  if ($$opts{'repository'}) {
    $rep_file = $$opts{'repository'};
  }
  if ($$opts{'directory'}) {
    chdir $$opts{'directory'};
  }
  if (!-e $rep_file) {
    print STDERR "missing default project file $default_project_file\n";
    exit 1;
  }
  my $rep = &rep_from_file($rep_file);
  if (0 != @$args) {
    &subcmd($rep, $args);
  } else {
    my $subcmds = [sort keys %$subcmd_tbl];
    print STDERR "missing subcmd. subcmds are: @$subcmds\n";
    exit 1;
  }
}
sub subcmd {
  my ($rep, $args) = @_;
  my $subcmd_name = shift @$args;
  my $subcmd = $$subcmd_tbl{$subcmd_name};
  if ($subcmd) {
    &$subcmd($rep, $args);
  } else {
    print STDERR "not a subcmd: $subcmd_name\n";
    exit 1;
  }
}
sub subcmd_init {
  my ($rep, $args) = @_;
  $$rep{'name'} = shift @$args;
  $$rep{'files'} = $args;
  &rep_to_file($rep, $default_project_file);
}
sub subcmd_add {
  my ($rep, $args) = @_;
  die if !defined $$rep{'files'};
  my $tbl = {};
  foreach my $file (@{$$rep{'files'}}) {
    $$tbl{$file} = 1;
  }
  foreach my $arg (@$args) {
    $$tbl{$arg} = 1;
  }
  $$rep{'files'} = [sort keys %$tbl];
  &rep_to_file($rep);
}
sub subcmd_remove {
  my ($rep, $args) = @_;
  die if !defined $$rep{'files'};
  my $tbl = {};
  foreach my $file (@{$$rep{'files'}}) {
    $$tbl{$file} = 1;
  }
  foreach my $arg (@$args) {
    delete $$tbl{$arg};
  }
  $$rep{'files'} = [sort keys %$tbl];
  &rep_to_file($rep);
}
sub subst {
  my ($string, $var) = @_;
  if ($var) {
    #print STDERR "<$string\n";
    $var =~ m|(\w+)=(.*)|;
    my $key = $1;
    my $element = $2;
    $string =~ s|\$$key\b|$element|;
    #print STDERR ">$string\n";
  }
  return $string
}
sub subcmd_files {
  my ($rep, $args) = @_;
  my $files = '';
  if ($$rep{'files'}) {
    my $cwd = '';
    if ($$opts{'abs-path'}) {
      $cwd = getcwd;
      $cwd .= '/';
    }

    foreach my $file (@{$$rep{'files'}}) {
      $file = &subst($file, $$opts{'var'});
      if ($file !~ "^/") {
        $files .= $cwd;
      }
      $files .= "$file\n";
    }
  }
  print $files;
}
sub subcmd_name {
  my ($rep, $args) = @_;
  my $name = '';
  if ($$rep{'name'}) {
    if ($$opts{'abs-path'}) {
      $name = getcwd;
      $name .= '/';
    }
    $name .= $$rep{'name'};
  }
  $name = &subst($name, $$opts{'var'});
  print "$name\n";
}
sub subcmd_set_name {
  my ($rep, $args) = @_;
  die if !defined $$rep{'name'};
  $$rep{'name'} = shift @$args;
  &rep_to_file($rep);
}
sub rep_from_file {
  my ($file) = @_;
  my $rep = do $file or die;
  $$rep{'**file**'} = $file;
  return $rep;
}
sub rep_to_file {
  my ($rep, $file) = @_;
  if (!$file) {
    $file = $$rep{'**file**'};
  }
  delete $$rep{'**file**'};
  open FILE, ">$file" or die __FILE__, ":", __LINE__, ": ERROR: $file: $!\n";
  print FILE &Dumper($rep);
  close FILE;
}
