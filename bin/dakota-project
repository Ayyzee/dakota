#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-

use strict;
use Cwd;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 1;   # default = 2

use Getopt::Long;
$Getopt::Long::ignorecase = 0;

my $opts = { 'var' => {} };

my $subcmd_tbl = {
  'init' =>     \&subcmd_init,
  'add' =>      \&subcmd_add,
  'remove' =>   \&subcmd_remove,
  'files' =>    \&subcmd_files,
  'libs' =>     \&subcmd_libs,
  'name' =>     \&subcmd_name,
  'set-name' => \&subcmd_set_name,
  'soname' =>     \&subcmd_soname,
  'set-soname' => \&subcmd_set_soname,
};

&GetOptions($opts,
            'repository=s',
            'var=s',
            'directory=s',
            'abs-path');

my $default_project_file = 'project.rep';

&start(\@ARGV);
sub start {
  my ($args) = @_;
  my $rep_file;
  if ($$opts{'repository'}) {
    $rep_file = $$opts{'repository'};
  } else {
    $rep_file = $default_project_file;
  }
  if ($$opts{'directory'}) {
    chdir $$opts{'directory'};
  }
  my $rep;
  if (-e $rep_file) {
    $rep = &rep_from_file($rep_file);
  } else {
    $rep = { '**file**' => $rep_file };
  }
  if (0 != @$args) {
    &subcmd($rep, $args);
  } else {
    my $subcmds = [sort keys %$subcmd_tbl];
    print STDERR "missing subcmd. subcmds are: @$subcmds\n";
    exit 1;
  }
}
sub subcmd {
  my ($rep, $args) = @_;
  my $subcmd_name = shift @$args;
  my $subcmd = $$subcmd_tbl{$subcmd_name};
  if ($subcmd) {
    &$subcmd($rep, $args);
  } else {
    print STDERR "not a subcmd: $subcmd_name\n";
    exit 1;
  }
}

sub subcmd_init {
  my ($rep, $args) = @_;
  $$rep{'name'} = shift @$args;
  $$rep{'files'} = [];
  $$rep{'libs'} = [];
  &subcmd_add($rep, $args);
  &rep_to_file($rep, $default_project_file);
}
sub subcmd_add_files {
  my ($rep, $args) = @_;
  die if !defined $$rep{'files'};
  my $tbl = {};
  foreach my $file (@{$$rep{'files'}}) {
    $$tbl{$file} = 1;
  }
  foreach my $arg (@$args) {
    $$tbl{$arg} = 1;
  }
  $$rep{'files'} = [sort keys %$tbl];
}
sub subcmd_add_libs {
  my ($rep, $args) = @_;
  die if !defined $$rep{'libs'};
  push @{$$rep{'libs'}}, @$args; # must maintain input order!
}
sub is_file {
  my ($arg) = @_;
  if ($arg =~ /\.(dk|c|cc|cxx|c\+\+)$/) {
    return 1;
  } else {
    return 0;
  }
}
sub subcmd_add {
  my ($rep, $args) = @_;
  my $files = [];
  my $libs = [];
  foreach my $arg (@$args) {
    if (&is_file($arg)) {
      push @$files, $arg;
    } else {
      push @$libs, $arg; # must maintain input order!
    }
  }
  &subcmd_add_files($rep, $files);
  &subcmd_add_libs($rep, $libs);
  &rep_to_file($rep);
}
sub remove_from_seq {
  my ($seq, $sarg) = @_;
  for (my $i = @$seq - 1; $i >= 0; $i--) {
    my $element = $$seq[$i];
    my $selement = &subst($element, $$opts{'var'});

    if ($selement eq $sarg) {
      splice(@$seq, $i ,1)
    }
  }
}
sub subcmd_remove {
  my ($rep, $args) = @_;
  die if !defined $$rep{'files'};
  die if !defined $$rep{'libs'};
  my $tbl = {};
  foreach my $file (@{$$rep{'files'}}) {
    my $sfile = &subst($file, $$opts{'var'});
    $$tbl{$sfile} = $file;
  }
  foreach my $arg (@$args) {
    my $sarg = &subst($arg, $$opts{'var'});

    if (&is_file($sarg)) {
      delete $$tbl{$sarg};
    } else {
      &remove_from_seq($$rep{'libs'}, $arg);
    }
  }
  $$rep{'files'} = [sort values %$tbl];
  &rep_to_file($rep);
}
sub subst {
  my ($string, $var) = @_;
  my ($key, $element);
  while (($key, $element) = each %$var) {
    #print STDERR "<$string\n";
    $string =~ s|\$$key\b|$element|;
    #print STDERR ">$string\n";
  }
  return $string
}
sub subcmd_files {
  my ($rep, $args) = @_;
  my $files = '';
  if ($$rep{'files'}) {
    my $cwd = '';
    if ($$opts{'abs-path'}) {
      $cwd = getcwd;
      $cwd .= '/';
    }

    foreach my $file (@{$$rep{'files'}}) {
      $file = &subst($file, $$opts{'var'});
      if ($file !~ "^/") {
        $files .= $cwd;
      }
      $files .= "$file\n";
    }
  }
  print $files;
}
sub subcmd_libs {
  my ($rep, $args) = @_;
  my $libs = '';
  if ($$rep{'libs'}) {
    my $cwd = '';
    if ($$opts{'abs-path'}) {
      $cwd = getcwd;
      $cwd .= '/';
    }
    foreach my $lib (@{$$rep{'libs'}}) {
      $lib = &subst($lib, $$opts{'var'});

      if ($lib !~ "^/") {
        $libs .= $cwd;
      }
      $libs .= "$lib\n";
    }
  }
  print $libs;
}
sub subcmd_name {
  my ($rep, $args) = @_;
  my $name = '';
  if ($$rep{'name'}) {
    if ($$opts{'abs-path'}) {
      $name = getcwd;
      $name .= '/';
    }
    $name .= $$rep{'name'};
  }
  if ($$opts{'var'}) {
    $name = &subst($name, $$opts{'var'});
  }
  print "$name\n";
}
sub subcmd_set_name {
  my ($rep, $args) = @_;
  die if !defined $$rep{'name'};
  $$rep{'name'} = shift @$args;
  &rep_to_file($rep);
}
sub subcmd_soname {
  my ($rep, $args) = @_;
  my $name;
  if ($$rep{'soname'}) {
    $name = $$rep{'soname'};
  } else {
    die if !$$rep{'name'};
    $name = $$rep{'name'};
  }
  if ($$opts{'var'}) {
    $name = &subst($name, $$opts{'var'});
  }
  print "$name\n";
}
sub subcmd_set_soname {
  my ($rep, $args) = @_;
  # info msg if changing existing soname?
  $$rep{'soname'} = shift @$args;
  &rep_to_file($rep);
}
sub rep_from_file {
  my ($file) = @_;
  my $rep = do $file or die;
  $$rep{'**file**'} = $file;
  return $rep;
}
sub rep_to_file {
  my ($rep, $file) = @_;
  if (!$file) {
    $file = $$rep{'**file**'};
  }
  delete $$rep{'**file**'};
  open FILE, ">$file" or die __FILE__, ":", __LINE__, ": ERROR: $file: $!\n";
  print FILE &Dumper($rep);
  close FILE;
}
