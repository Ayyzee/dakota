#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007-2015 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 0; # default = 2

my $nl = "\n";
my $o_ext =   'o';
my $so_ext = 'so';
my $major_mode_tbl = {
  '-c'        => 'compile',
  '--compile' => 'compile',
  '-shared'   => 'shared',
  '--shared'  => 'shared',
  '-dynamic'  => 'dynamic',
  '--dynamic' => 'dynamic',
};
sub path_opt {
  my ($cmd, $ir, $short, $long, $info) = @_;
  my $arg = $$cmd[$$ir];
  my $pair;
  if (0) {
  } elsif ($arg =~ /^(-$short|--$long=)(.+)$/) {
    $pair = [$$ir, $2];
  } elsif ($arg =~ /^-$short|--$long$/) {
    $pair = [$$ir + 1, $$cmd[$$ir + 1]];
    $$ir++;
  }
  if ($pair) {
    if ('ARRAY' eq ref($$info{$long})) {
      push @{$$info{$long}}, $pair;
    } else {
      $$info{$long} = $pair;
    }
  }
  return $pair;
}
sub cc_from_dk {
  my ($path) = @_;
  $path =~ s=^(.+\.dk)$=build/$1.cc=;
  return $path;
}
sub translate_dk_to_cc {
  my ($args, $pairs) = @_;
  foreach my $pair (@$pairs) {
    die if $$pair[1] ne $$args[$$pair[0]];
    $$args[$$pair[0]] = &cc_from_dk($$pair[1]);
  }
}
sub build_precompile_cmd {
  my ($info) = @_;
  my $cmd = [ 'dakota', '--precompile' ];
  if ($$info{'major-mode'}) {
    push @$cmd, '--' . $$info{'major-mode'}[1];
  }
  if ($$info{'project'}) {
    push @$cmd, ('--project', $$info{'project'});
  } else {
    if ($ENV{'DK_PROJECT'}) {
      push @$cmd, ('--project', $ENV{'DK_PROJECT'});
    } else {
      die $0 . ': error: environment variable DK_PROJECT required' . $nl;
    }
  }
  push @$cmd, ('--output', $$info{'output'}[1]);
  push @$cmd, (@{$$info{'ordered-input-args'}});
  return $cmd;
}
sub get_dakota_opts {
  my ($cmd, $info) = @_;
  my $to_remove = [];
  for (my $i = 0; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    foreach my $key ('cxx', 'project') {
      if ($arg =~ /^--$key=(.+)$/) {
        $$info{$key} = $1;
        unshift @$to_remove, $i;
        last;
      }
    }
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
}
sub get_gcc_opts {
  my ($cmd, $info) = @_;
  for (my $i = 0; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    my $pair;
    if (0) {
    } elsif ($$major_mode_tbl{$arg}) {
      $$info{'major-mode'} = [$i, $$major_mode_tbl{$arg}];
    } elsif ($pair = &path_opt($cmd, \$i, 'L', 'library-directory', $info)) {
      push @{$$info{'ordered-input-args'}}, '--library-directory=' . $$pair[1];
    } elsif ($pair = &path_opt($cmd, \$i, 'l', 'library',           $info)) {
      push @{$$info{'ordered-input-args'}}, '--library=' . $$pair[1];
    } elsif (&path_opt($cmd, \$i, 'o', 'output',            $info)) {
    } elsif ($arg !~ /^-/) {
      if ($arg =~ /^(.+?\.(dk|$so_ext|$o_ext))$/) {
        $pair = [$i, $arg];
        push @{$$info{'inputs'}}, $pair;
        push @{$$info{'ordered-input-args'}}, $$pair[1];
      }
    }
  }
}
sub start {
  my ($argv) = @_;
  my $cmd = [@$argv];
  my $info = {
    'library-directory' => [],
    'library'           => [],
    'inputs'            => [],
    'ordered-input-args' => [],
  };
  &get_dakota_opts($cmd, $info);
  my $gcc_cmd = [@$cmd];
  &get_gcc_opts($gcc_cmd, $info);
  &translate_dk_to_cc($gcc_cmd, $$info{'inputs'});
  if ($$info{'cxx'}) {
    unshift @$gcc_cmd, $$info{'cxx'};
  } else {
    if ($ENV{'DK_CXX'}) {
      unshift @$gcc_cmd, $ENV{'DK_CXX'};
    } elsif ($ENV{'CXX'}) {
      unshift @$gcc_cmd, $ENV{'DK_CXX'};
    } else {
      die $0 . ': error: environment variables DK_CXX or CXX required' . $nl;
    }
  }
  my $dakota_cmd = &build_precompile_cmd($info);
  # executing the precompile cmd should return on stdout
  # the list of cc files that correspond to the dk files (in order)

  print '{' . $nl;
  foreach my $key (sort keys %$info) {
    print '  ' . "'$key'" . ' => ' . &Dumper($$info{$key}) . $nl;
  }
  print '}' . $nl;
  if (1) {
    print '# ' . join(' ', ($0, @$argv)) . $nl;
    print '# ' . join(' ', ($0, @$cmd)) . $nl;
    print '# ' . join(' ', @$gcc_cmd) . $nl;
    print '# ' . join(' ', @$dakota_cmd) . $nl;
  }
}
&start(\@ARGV);
# dakota --precompile ...
# gcc|clang ...
