#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007-2015 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 0; # default = 2

my $nl = "\n";
my $cc_ext = 'cc';
my $o_ext =   'o';
my $so_ext = 'so';
sub path_opt {
  my ($cmd, $ir, $short, $long, $info) = @_;
  my $arg = $$cmd[$$ir];
  my $pair;
  if (0) {
  } elsif ($arg =~ /^(-$short|--$long=)(.+)$/) {
    $pair = [$$ir, $2];
  } elsif ($arg =~ /^-$short|--$long$/) {
    $pair = [$$ir + 1, $$cmd[$$ir + 1]];
    $$ir++;
  }
  if ($pair) {
    if ('ARRAY' eq ref($$info{$long})) {
      push @{$$info{$long}}, $pair;
    } else {
      $$info{$long} = $pair;
    }
  }
  return $pair;
}
sub cc_from_dk {
  my ($path) = @_;
  my $builddir = 'dkt';
  $path =~ s=^(.+\.dk)$=$builddir/$1.$cc_ext=;
  return $path;
}
sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?(.+?)\..+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub translate_dk_to_cc {
  my ($cmd, $cc_paths) = @_;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if ($arg =~ /\.dk$/) {
      my $cc_path = shift @$cc_paths;
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
    }
  }
}
sub build_precompile_cmd {
  my ($project, $info, $ordered_input_args) = @_;
  my $cmd = [ 'dakota', '--precompile' ];
  if ($$info{'major-mode'}) {
    push @$cmd, '--' . $$info{'major-mode'}[1];
  }
  if ($project) {
    push @$cmd, ('--project', $project);
  }
  push @$cmd, ('--output', $$info{'output'}[1]);
  push @$cmd, (@$ordered_input_args);
  return $cmd;
}
sub get_dakota_opts {
  my ($cmd) = @_;
  my $var4opt = { 'cxx'     => 'DK_CXX',
                  'project' => 'DK_PROJECT' };
  my $info = {};
  my $to_remove = [];
  for (my $i = 0; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    foreach my $opt (keys %$var4opt) {
      $$info{$opt} = undef if !exists $$info{$opt};
      if ($arg =~ /^--$opt=(.+)$/) {
        $$info{$opt} = $1;
        unshift @$to_remove, $i;
        last;
      }
    }
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  foreach my $opt (keys %$var4opt) {
    if (!$$info{$opt}) {
      if ($ENV{$$var4opt{$opt}}) {
        $$info{$opt} = $ENV{$$var4opt{$opt}};
      } else {
        die $0 . ': error: option --' . $opt .
          ' not used, so environment variable ' .
          $$var4opt{$opt} . ' required' . $nl;
      }
    }
  }
  return ($$info{'cxx'},
          $$info{'project'});
}
my $major_mode_tbl = {
  '-c'        => 'compile',
  '--compile' => 'compile',
  '-shared'   => 'shared',
  '--shared'  => 'shared',
  '-dynamic'  => 'dynamic',
  '--dynamic' => 'dynamic',
};
sub detect_gcc_opts {
  my ($cmd, $info) = @_;
  $$info{'library-directory'} = [];
  $$info{'library'} = [];
  $$info{'inputs'} = [];
  my $ordered_input_args = [];
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    my $pair;
    if (0) {
    } elsif ($$major_mode_tbl{$arg}) {
      $$info{'major-mode'} = [$i, $$major_mode_tbl{$arg}];
    } elsif ($pair = &path_opt($cmd, \$i, 'L', 'library-directory', $info)) {
      push @$ordered_input_args, '--library-directory=' . $$pair[1];
    } elsif ($pair = &path_opt($cmd, \$i, 'l', 'library',           $info)) {
      push @$ordered_input_args, '--library=' . $$pair[1];
    } elsif (&path_opt($cmd, \$i, 'o', 'output',            $info)) {
    } elsif ($arg !~ /^-/) {
      if ($arg =~ /^(.+?\.(dk|$cc_ext|$o_ext|$so_ext))$/) {
        $pair = [$i, $arg];
        push @{$$info{'inputs'}}, $pair;
        push @$ordered_input_args, $$pair[1];
      }
    }
  }
  return $ordered_input_args;
}
sub start {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  print '# 1/3 ' . join(' ', @$cmd) . $nl;
  my ($cxx, $project) = &get_dakota_opts($cmd);
  my $gcc_cmd = [@$cmd];
  $$gcc_cmd[0] = $cxx;
  my $info = {};
  my $ordered_input_args = &detect_gcc_opts($gcc_cmd, $info);
  my $precompile_cmd = &build_precompile_cmd($project, $info, $ordered_input_args);
  my $precompile_cmd_str = join(' ', @$precompile_cmd) ;
  print '# 2/3 ' . $precompile_cmd_str . $nl;
  my $outstr = `$precompile_cmd_str`;
  my $val = $? >> 8;
  if (0 != $val) {
    #print $outstr;
    exit $val;
  }
  if (!defined $outstr) {
    die $0 . ': error: cmd: ' . $precompile_cmd_str . $nl;
  }
  my $cc_paths = [split $nl, $outstr];
  if (0 != @$cc_paths) {
    &translate_dk_to_cc($gcc_cmd, $cc_paths);
  }
  print '# 3/3 ' . join(' ', @$gcc_cmd) . $nl;
  return system @$gcc_cmd;
}
exit &start(\@ARGV);
