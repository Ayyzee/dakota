#!/usr/bin/perl -w
# -*- mode: cperl -*-
# -*- cperl-close-paren-offset: -2 -*-
# -*- cperl-continued-statement-offset: 2 -*-
# -*- cperl-indent-level: 2 -*-
# -*- cperl-indent-parens-as-block: t -*-
# -*- cperl-tab-always-indent: t -*-
# -*- tab-width: 2
# -*- indent-tabs-mode: nil

# Copyright (C) 2007-2015 Robert Nielsen <robert@dakota.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

my $gbl_prefix;
my $nl = "\n";
my $cc_ext = 'cc';
my $o_ext =   'o';
my $so_ext = 'so';

sub dk_prefix {
  my ($path) = @_;
  $path =~ s|//+|/|;
  $path =~ s|/\./+|/|;
  $path =~ s|^./||;
  if (-d "$path/bin" && -d "$path/lib") {
    return $path
  } elsif ($path =~ s|^(.+?)/+[^/]+$|$1|) {
    &dk_prefix($path);
  } else {
    die "Could not determine \$prefix from executable path $0: $!" . $nl;
  }
}

BEGIN {
  $gbl_prefix = &dk_prefix($0);
  unshift @INC, "$gbl_prefix/lib";
};
use dakota::util;

use Data::Dumper;
$Data::Dumper::Terse     = 1;
$Data::Dumper::Deepcopy  = 1;
$Data::Dumper::Purity    = 1;
$Data::Dumper::Quotekeys = 1;
$Data::Dumper::Indent    = 0; # default = 2

sub path_opt {
  my ($cmd, $ir, $short, $long, $info) = @_;
  $short = 'no-such-short-opt' if !$short;
  my $arg = $$cmd[$$ir];
  my $pair;
  if (0) {
  } elsif ($arg =~ /^(-$short|--$long=)([^\s]+)$/) {
    $pair = [$$ir, $2];
  } elsif ($arg =~ /^-$short|--$long$/) {
    $pair = [$$ir + 1, $$cmd[$$ir + 1]];
    $$ir++;
  }
  if ($pair) {
    if ('ARRAY' eq ref($$info{$long})) {
      &add_last($$info{$long}, $pair);
    } else {
      $$info{$long} = $pair;
    }
  }
  return $pair;
}
sub cc_from_dk {
  my ($path) = @_;
  my $builddir = 'dkt';
  $path =~ s=^([^\s]+\.dk)$=$builddir/$1.$cc_ext=;
  return $path;
}
sub bname {
  my ($path) = @_;
  my $bname = $path =~ s=^(.*/)?([^\s]+?)\.[^\s]+$=$2=r;
  return $bname;
}
sub check_paths {
  my ($dk_path, $cc_path) = @_;
  if (&bname($dk_path) ne &bname($cc_path)) {
    die $0 . ': error: ' . $cc_path . ' does not correspond to ' . $dk_path . $nl;
  }
}
sub translate_dk_to_cc {
  my ($cmd, $cc_paths) = @_;
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    die if ! $arg || '' eq $arg;
    if ($arg =~ /\.dk$/) {
      my $cc_path = &remove_first($cc_paths);
      die if ! $cc_path || '' eq $cc_path;
      &check_paths($arg, $cc_path);
      $$cmd[$i] = $cc_path;
    }
  }
}
sub build_precompile_cmd {
  my ($dakota_opts, $info, $ordered_input_args) = @_;
  my $project = $$dakota_opts{'project'};
  my $cmd = [ 'dakota' ];
  if ($project) {
    &add_last($cmd, ('--project', $project));
  }
  if ($$info{'define-macro'}) {
    foreach my $macro (@{$$info{'define-macro'}}) {
      &add_last($cmd, ('--define-macro', $$macro[1]));
    }
  }
  &add_last($cmd, '--precompile');
  if ($$info{'major-mode'}) {
    &add_last($cmd, '--' . $$info{'major-mode'}[1]);
  }
  &add_last($cmd, ('--output', $$info{'output'}[1]));
  &add_last($cmd, (@$ordered_input_args));
  return $cmd;
}
sub get_dakota_opts {
  my ($cmd) = @_;
  my $var4opt = { 'project' => 'DK_PROJECT',
                  'cxx'     => 'DK_CXX' };
  my $info = {};
  my $to_remove = [];
  for (my $i = 0; $i < @$cmd; ) {
    my $arg = $$cmd[$i];
    foreach my $opt (keys %$var4opt) {
      $$info{$opt} = undef if !exists $$info{$opt};
      if ($arg =~ /^--$opt$/) {
        $$info{$opt} = $$cmd[$i + 1];
        &add_first($to_remove, $i);
        &add_first($to_remove, $i + 1);
        last;
      }
    }
    $i++;
  }
  foreach my $i (@$to_remove) {
    splice @$cmd, $i, 1;
  }
  foreach my $opt (keys %$var4opt) {
    if (!$$info{$opt}) {
      if ($ENV{$$var4opt{$opt}}) {
        $$info{$opt} = $ENV{$$var4opt{$opt}};
      } else {
        die $0 . ': error: option --' . $opt .
          ' not used, so environment variable ' .
          $$var4opt{$opt} . ' required' . $nl;
      }
    }
  }
  return $info;
}
my $major_mode_tbl = {
  '-c'        => 'compile',
  '--compile' => 'compile',
  '-shared'   => 'shared',
  '--shared'  => 'shared',
  '-dynamic'  => 'dynamic',
  '--dynamic' => 'dynamic',
};
sub detect_gcc_opts {
  my ($cmd, $info) = @_;
  my $num_dk_files = 0;
  $$info{'library-directory'} = [];
  $$info{'library'} = [];
  $$info{'define-macro'} = [];
  $$info{'inputs'} = [];
  my $ordered_input_args = [];
  for (my $i = 1; $i < @$cmd; $i++) {
    my $arg = $$cmd[$i];
    my $pair;
    if (0) {
    } elsif ($$major_mode_tbl{$arg}) {
      $$info{'major-mode'} = [$i, $$major_mode_tbl{$arg}];
    } elsif ($pair = &path_opt($cmd, \$i, 'L', 'library-directory', $info)) {
      &add_last($ordered_input_args, ('--library-directory', $$pair[1]));
    } elsif ($pair = &path_opt($cmd, \$i, 'l', 'library',           $info)) {
      &add_last($ordered_input_args, ('--library', $$pair[1]));
    } elsif (&path_opt($cmd, \$i, 'D', 'define-macro',      $info)) {
    } elsif (&path_opt($cmd, \$i, 'o', 'output',            $info)) {
    } elsif ($arg !~ /^-/) {
      if ($arg =~ /^([^\s]+?\.(dk|$cc_ext|$o_ext|$so_ext))$/) {
        $pair = [$i, $arg];
        &add_last($$info{'inputs'}, $pair);
        &add_last($ordered_input_args, $$pair[1]);
        if ($arg =~ /\.dk$/) {
          $num_dk_files++;
        }
      }
    }
  }
  return ($num_dk_files, $ordered_input_args);
}
sub project_io_path_from_project_path {
  my ($project_path) = @_;
  my $project = &dakota::util::scalar_from_file($project_path);
  my $builddir = 'dkt';
  $builddir = $$project{'builddir'} if $$project{'builddir'};
  my $project_io_path = $builddir . '/' . $project_path;
  $project_io_path =~ s/\.project$/.io/;
  return $project_io_path;
}
sub is_so_path {
  my ($name) = @_;
  # linux and darwin so-regexs are combined
  my $result = $name =~ m=^(.*/)?(lib([.\w-]+))(\.$so_ext((\.\d+)+)?|((\.\d+)+)?\.$so_ext)$=; # so-regex
  #my $libname = $2 . ".$so_ext";
  return $result;
}
my $verbose = $ENV{'DK_VERBOSE'};
sub convert_and_exec_cmd {
  my ($argv) = @_;
  my $cmd = [$0, @$argv];
  if ($verbose) {
    print '# 1/3 ' . join(' ', @$cmd) . $nl;
  }
  my $dakota_opts = &get_dakota_opts($cmd);
  my $gcc_cmd = [@$cmd];
  $$gcc_cmd[0] = $$dakota_opts{'cxx'};
  my $info = {};
  my ($num_dk_files, $ordered_input_args) = &detect_gcc_opts($gcc_cmd, $info);
  my $cc_paths;
  if ($num_dk_files) {
    my $precompile_cmd = &build_precompile_cmd($dakota_opts, $info, $ordered_input_args);
    my $precompile_cmd_str = join(' ', @$precompile_cmd) ;
    if ($verbose) {
      print '# 2/3 ' . $precompile_cmd_str . $nl;
    }
    my $outstr = `$precompile_cmd_str`;
    my $val = $? >> 8;
    if (0 != $val) {
      print $outstr;
      exit $val;
    }
    if (!defined $outstr) {
      die $0 . ': error: cmd: ' . $precompile_cmd_str . $nl;
    }
    $cc_paths = [split /\s+/, $outstr];
  } else {
    if ($verbose) {
      print '# 2/3 (skipped)' . $nl;
    }
    $cc_paths = [];
  }
  if (0 != @$cc_paths) {
    &translate_dk_to_cc($gcc_cmd, $cc_paths);
  }
  if ($verbose) {
    print '# 3/3 ' . join(' ', @$gcc_cmd) . $nl;
  }
  my $exit_val = system @$gcc_cmd;
  if (!$exit_val) {
    my $inputs = [];
    my $output = $$info{'output'}[1];
    foreach my $pair (@{$$info{'inputs'}}) {
      my $input = &relpath($$pair[1]);
      if ($input =~ /\.(dk|$cc_ext)$/) {
        &add_last($inputs, $input);
      }
    }
    if (0 != @$inputs && !&is_so_path($output)) {
      my $project_io_path = &project_io_path_from_project_path($$dakota_opts{'project'});
      &dakota::util::project_io_add($project_io_path, 'compile', $inputs, $output);
    }
  }
  return $exit_val;
}
exit &convert_and_exec_cmd(\@ARGV);
