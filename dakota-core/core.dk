// -*- mode: dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

# include <cxxabi.h>

# include <sys/mman.h>
# include <syslog.h>
# include <unistd.h>
# include <mach-o/loader.h> // struct mach-header-64, MH-EXECUTE, MH-DYLIB

# include <cassert>
# include <cerrno>
# include <cinttypes>
# include <csignal>
# include <cstdarg>
# include <cstdio>
# include <cstdlib>
# include <cstring>
# include <exception>

include-for <sys/stat.h> struct stat;

# include "dakota-os.h"

# include "private.h"
# include "dakota-rt-private.h"
# include "dakota-dso.h" // dso-*()
# include "sorted-set-core.h"

module dakota-core;

klass bit-vector;
klass const-info;
klass enum-info;
klass exception;
klass finalize-func;
klass illegal-klass-exception;
klass initialize-func;
klass intptr;
klass named-enum-info;
klass named-info-compare;
klass named-info;
klass property-compare;
klass property;
klass resource-usage;
klass result;
klass selector-node;
klass sigbus-exception;
klass sigsegv-exception;
klass signal-exception;
klass singleton-klass;
klass sorted-set-core;
klass std-compare;
klass str128;
klass stream;
klass super;
klass symbol-compare;
klass symbol;
klass unbox-illegal-klass-exception;

static const char-t gbl-delimiter = '/'; // unix path delimiter

// all symbols are strings, but all strings are not symbols
inline func valid-str?(str_t str) -> bool-t { return str != nullptr && str[0] != NUL; }
# define assert-valid-str(str) assert(valid-str?(str))

klass core-node {
  slots {
    slots-t*  next;
    object-t* item-ptr;
  }
  method set-all(slots-t* slots, object-t item) -> object-t {
    slots-t* node = slots;
    while (node != nullptr) {
      *(node->item-ptr) = item;
      node = node->next;
    }
    return item;
  }
}
klass named-core-node-compare {
  slots (*)(const named-core-node-t*, const named-core-node-t*) -> cmp-t;
}
klass named-core-node {
  slots {
    symbol-t     name;
    core-node-t* node;
  }
  method compare(const slots-t* s, const slots-t* other-s) -> cmp-t {
    assert(s != nullptr);
    assert(other-s != nullptr);
    cmp-t result = 0;
    if (s != other-s)
      result = symbol::compare(s->name, other-s->name);
    return result;
  }
//   method dump(const slots-t* s) -> const slots-t* {
//     printf("\"%s\"\n", s->name);
//     core-node-t* node = s->node;
//     while (node != nullptr) {
//       printf("  item=%p, next=%p\n", node->item, node->next);
//       node = node->next;
//     }
//     return s;
//   }
}
static sorted-set-core-t* gbl-imported-klasses-table;
static sorted-set-core-t* gbl-klass-defns-table;
static sorted-set-core-t* gbl-interposers-table;
static sorted-set-core-t* gbl-imported-klasses-file-table;

static func symbol-str-compare(symbol-t s1, str-t s2) -> cmp-t {
  cmp-t result = 0;
  if (s1 != s2) {
    result = cast(cmp-t)safe-strcmp(s1, s2);
  }
  //fprintf(stderr, "%s(\"%s\" (%p), \"%s\" (%p)) = %i\n", __func__, s, s, other-s, other-s, result);
  return result;
}
static func init-runtime-ds() -> void {
  const ssize-t num-klses = 256;

  bool-t is-ptr;
  gbl-imported-klasses-table =
    sorted-set-core::create(num-klses,
                            ssizeof(named-core-node::slots-t),
                            cast(std-compare-t)
                            cast(named-core-node-compare-t)named-core-node::compare,
                            is-ptr = false);
  gbl-klass-defns-table =
    sorted-set-core::create(num-klses,
                            ssizeof(named-info::slots-t*),
                            cast(std-compare-t)
                            cast(named-info-compare-t)named-info::compare,
                            is-ptr = true);
  gbl-interposers-table =
    sorted-set-core::create(num-klses,
                            ssizeof(property::slots-t),
                            cast(std-compare-t)
                            cast(property-compare-t)property::compare,
                            is-ptr = false);
  gbl-imported-klasses-file-table =
    sorted-set-core::create(num-klses,
                            ssizeof(symbol-t),
                            cast(std-compare-t)
                            cast(symbol-compare-t)symbol-str-compare,
                            is-ptr = true);
  return;
}
# if defined DKT-DUMP-MEM-FOOTPRINT
extern resource-usage::slots-t gbl-ru;
# endif

object-t null =       nullptr;
object-t std-input =  nullptr;
object-t std-output = nullptr;
object-t std-error =  nullptr;

klass x::stat {
  slots struct stat;
}
// this is quick and dirty!!!!!!!!!!!!!!!!
static func init-imported-klasses() -> void {
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[]", __func__);
  symbol-t imported-kls-name;
  while ((imported-kls-name = cast(symbol-t)sorted-set-core::remove-last(gbl-imported-klasses-file-table)) != nullptr)
    dk-klass-for-name(imported-kls-name);
  return;
}
static func file-name-from-klass-name(symbol-t kls-name) -> str-t {
  char-t* file-name = cast(char-t*)dkt::alloc(ssizeof(char-t) * (symbol::length(kls-name) + 1));
  file-name[0] = NUL;
  ssize-t kn = 0;
  ssize-t fn = 0;

  while (kls-name[kn] == ':')
    kn++;
  while (kls-name[kn] != NUL) {
    if (kls-name[kn] == ':') {
      do {
        kn++;
      } while (kls-name[kn] == ':');

      if (kls-name[kn] != NUL) {
        file-name[fn] = gbl-delimiter;
        fn++;
      }
    } else {
      file-name[fn] = kls-name[kn];
      kn++;
      fn++;
    }
  }
  file-name[fn] = NUL;
  return file-name;
}
static func find-file(str-t path, str-t file-name, str-t suffix) -> str-t {
  char-t* file = cast(char-t*)dkt::alloc(ssizeof(char-t) * (FILENAME-MAX + 1));
  file[0] = NUL;
  ssize-t j1 = 0;
  ssize-t j2 = 0;
  str-t rtn = nullptr;

  while (j1 <= cast(ssize-t)safe-strlen(path)) {
    if (path[j1] == NUL || path[j1] == ':') {
      if (j2 != 0 && gbl-delimiter != file[j2 - 1]) {
        file[j2] = gbl-delimiter;
        j2++;
      }
      file[j2] = NUL;
      strcat(file, file-name);
      strcat(file, ".");
      strcat(file, suffix);
      x::stat-t status;
      int-t err = stat(file, &status);

      if (err == 0) {
        if (S-ISREG(status.st-mode) == 0) { // NOT a regular file
          fprintf(stderr, "%s:%i: ERROR: %s: not a regular file.\n", __FILE__, __LINE__, file);
        }
        else if ((S-IRUSR & status.st-mode) == 0) { // user DOES NOT have read permission
          fprintf(stderr, "%s:%i: ERROR: %s: user does not have read permission.\n", __FILE__, __LINE__, file);
        } else {
          //fprintf(stdout, "%s: IS a regular file AND user DOES have read permission\n", file);
          rtn = file;
          break;
        }
      } else {
        fprintf(stderr, "%s:%i: ERROR: %s: %s\n", __FILE__, __LINE__, file, strerror(errno));
        throw $make(exception::klass(), #msg: "bummer");
      }
      j1++;
      j2 = 0;
    } else {
      file[j2] = path[j1];
      j1++;
      j2++;
    }
  }
  return rtn;
}
/*LOCAL*/ func default-klass-name() -> symbol-t {
  return #klass;
}
static func alloc-klass(symbol-t name) -> object-t {
  named-info-t* info = info-for-name(name);
  symbol-t kls-name = klass-name-from-info(info);
  if (kls-name == nullptr)
    kls-name = default-klass-name();
  named-info-t* kls-info = info-for-name(kls-name);

  ssize-t offset = offset-from-info(kls-info);
  ssize-t size =   size-from-info(kls-info);
  ssize-t total-size = offset + size;
  //fprintf(stderr, "%s(#%s):\toffset=%i + size=%i\n", __func__, name, offset, size);

# if defined DKT-DUMP-MEM-FOOTPRINT
  resource-usage::add-alloc(&gbl-ru, total-size);
  resource-usage::log-alloc(&gbl-ru, total-size, name);
# endif
  object::slots-t* kls-slots = alloc-instance(total-size, kls-name, name); // instance-name
  kls-slots->kls =     klass::_klass_;
  kls-slots->ref-count = 0;
  object-t kls = object-t{kls-slots};
  if (kls->kls == nullptr)
    kls->kls = kls; // klass klass's klass is klass klass
  return kls;
}
static func init-klass(object-t kls, symbol-t name) -> object-t {
  kls = klass::core-init(kls, name); // calling to what $init() would resolve, but not doing super dispatch
  return kls;
}
KLASS-NS ostream { [[format-va-printf(2)]] static func print-format(slots-t, str-t, va-list-t) -> slots-t; }
klass ostream {
  slots {
    stream-t output;
    ssize-t col;
  }
  static func col-incr(slots-t& s) -> slots-t& {
    s.col++;
    return s;
  }
  static func col-decr(slots-t& s) -> slots-t& {
    if (s.col != 0) {
      s.col--;
    }
    return s;
  }
  static func pad(const slots-t& s) -> const slots-t& {
    fprintf(s.output, "%*s", cast(int-t)s.col * 2, ""); // two spaces per column:-) [my way]
    return s;
  }
  [[format-va-printf(2)]] static func print-format(slots-t s, str-t format, va-list-t args) -> slots-t {
    pad(s);
    vfprintf(s.output, format, args);
    return s;
  }
  [[format-printf(2)]] static func print-format(slots-t s, str-t format, ...) -> slots-t {
    va-list-t args;
    va-start(args, format);
    print-format(s, format, args);
    va-end(args);
    return s;
  }
  static func fopen(str-t path, str-t mode = "w") -> slots-t {
    slots-t s = { .output = stdout, .col = 0 };
    if (path == nullptr)
      return s;
    errno = 0;
    s.output = ::fopen(path, mode);
    if (s.output == nullptr)
      exit-fail-with-msg("ERROR: %s: \"%s\"", path, strerror(errno));
    return s;
  }
  static func fclose(slots-t& s) -> slots-t& {
    s.col = 0;
    if (s.output == nullptr)
      s.output = stdout;
    if (s.output == stdout)
      return s;
    errno = 0;
    int n = ::fclose(s.output);
    if (n == -1)
      non-exit-fail-with-msg("ERROR: %s: \"%s\"", "fclose", strerror(errno));
    return s;
  }
}
static func klass-exported?(named-info-t* kls-info,
                            bool-t*       is-exported-ptr =           nullptr,
                            bool-t*       has-exported-state-ptr =    nullptr,
                            bool-t*       has-exported-behavior-ptr = nullptr) -> bool-t {
  bool-t is-exported =           cast(bool-t)named-info::at(kls-info, #is-exported);
  bool-t has-exported-state =    cast(bool-t)named-info::at(kls-info, #has-exported-state);
  bool-t has-exported-behavior = cast(bool-t)named-info::at(kls-info, #has-exported-behavior);

  if (is-exported-ptr)
    *is-exported-ptr = is-exported;
  if (has-exported-state-ptr)
    *has-exported-state-ptr = has-exported-state;
  if (has-exported-behavior-ptr)
    *has-exported-behavior-ptr = has-exported-behavior;

  bool-t result = (is-exported || has-exported-state || has-exported-behavior);
  return result;
}
static func dump?(named-info-t* kls-info, str-t only) -> bool-t {
  assert(kls-info != nullptr);
  assert-valid-str(only);
  symbol-t name = name-from-info(kls-info);
  assert-valid-str(name);

  bool-t result = true;
  ssize-t only-len = cast(ssize-t)safe-strlen(only);
  if (only[0] == '*') {
    ssize-t name-len = cast(ssize-t)safe-strlen(name);
    if (name-len < (only-len - 1) || safe-strcmp(name + name-len - (only-len - 1), only + 1) != 0)
      result = false;
  }
  else if (only[only-len - 1] == '*') {
    if (safe-strncmp(name, only, cast(size-t)(only-len - 1)) != 0)
      result = false;
  } else {
    if (safe-strcmp(name, only) != 0)
      result = false;
  }
  return result;
}
# if 1
extern sorted-set-core-t gbl-selectors-table;
static func json-dump-resource-info(sorted-set-core-t* klass-defns-table) -> void {
  ssize-t klses-count = 0;
  ssize-t methods-count = 0;
  for (ssize-t i = 0; i < klass-defns-table->count; i++) {
    named-info-t* kls-info = cast(named-info-t*)sorted-set-core::at(klass-defns-table, i);
    named-info-t* current-info = kls-info;

    do {
      symbol-t type = cast(symbol-t)named-info::at(current-info, #type, cast(intptr-t)#klass);
      if (type == #klass)
        klses-count++;
      const signature-t* const* method-signatures = cast(const signature-t* const*)named-info::at(current-info, #method-signatures);

      if (method-signatures != nullptr) {
        const method-t* method-addresses = cast(const method-t*)named-info::at(current-info, #method-addresses);
        if (method-addresses != nullptr) {
          ssize-t j = 0;
          const signature-t* method-signature;
          while ((method-signature = method-signatures[j]) != nullptr) {
            method-t method-address = method-addresses[j];
            if (method-address != nullptr && method-address != DKT-NULL-METHOD)
              methods-count++;
            j++;
          }
        }
      }
    } while ((current-info = current-info->next) != nullptr);
  }
  ostream-t ostrm = { .output = stdout, .col = 0 };
  ostream::print-format(ostrm, "{ \"klasses\": %zi, \"selectors\": %zi \"methods\": %zi },\n",
                        klses-count, selector-count(), methods-count);
  return;
}
# endif
static func json-dump-klass-defns(sorted-set-core-t* klass-defns-table) -> void {
  assert(klass-defns-table != nullptr);
  ostream-t ostrm = { .output = stdout, .col = 0 };
  ostream::print-format(ostrm, "{\n");
  ostream::col-incr(ostrm);

  for (ssize-t i = 0; i < klass-defns-table->count; i++) {
    named-info-t* kls-info = cast(named-info-t*)sorted-set-core::at(klass-defns-table, i);
    named-info-t* current-info = kls-info;

    do {
      symbol-t name =          name-from-info(current-info);
      symbol-t kls-name =      klass-name-from-info(current-info);
      symbol-t superkls-name = superklass-name-from-info(current-info);
      ostream::print-format(ostrm, "\"%s\": {\n", name);
      ostream::col-incr(ostrm);
      symbol-t type = cast(symbol-t)named-info::at(current-info, #type, cast(intptr-t)#klass);
      ostream::print-format(ostrm, "\"type\": \"%s\",\n", type);
      if (kls-name != nullptr)
        ostream::print-format(ostrm, "\"klass\": \"%s\",\n",      kls-name);
      if (superkls-name != nullptr)
        ostream::print-format(ostrm, "\"superklass\": \"%s\",\n", superkls-name);

      const signature-t* const* method-signatures = cast(const signature-t* const*)named-info::at(current-info, #method-signatures);
      if (method-signatures != nullptr) {
        ostream::print-format(ostrm, "\"methods\": {\n");
        ostream::col-incr(ostrm);
        const method-t* method-addresses = cast(const method-t*)named-info::at(current-info, #method-addresses);
        ssize-t j = 0;
        const signature-t* method-signature;

        while ((method-signature = method-signatures[j]) != nullptr) {
          bool-t is-defined = false;
          if (method-addresses != nullptr) {
            method-t method-address = method-addresses[j];
            if (method-address != nullptr && method-address != DKT-NULL-METHOD)
              is-defined = true;
          }
          j++;
          ostream::print-format(ostrm, "\"%s(%s)\": { \"name\": \"%s\", \"param-types\": \"%s\", \"return-type\": \"%s\", \"is-defined\": %i },\n",
                                method-signature->name, method-signature->param-types,
                                method-signature->name,
                                method-signature->param-types,
                                method-signature->return-type,
                                is-defined ? 1 : 0);
        }
        ostream::col-decr(ostrm);
        ostream::print-format(ostrm, "},\n");
      }
      ostream::col-decr(ostrm);
      ostream::print-format(ostrm, "},\n");
    } while ((current-info = current-info->next) != nullptr);
  }
  ostream::col-decr(ostrm);
  ostream::print-format(ostrm, "},\n");
  return;
}
static named-info-t* gbl-registration-info-list;

// func dk-make-simple-singleton(symbol-t name, symbol-t superkls-name) -> object-t {
//   object-t kls = dk-make-simple-klass(name, superkls-name, #singleton-klass);
//   object-t singleton = $make(kls);
//   return singleton;
// }
func dk-make-simple-klass(symbol-t name, symbol-t superkls-name, symbol-t kls-name) -> object-t {
  //fprintf(stderr, "%s(#%s, #%s, #%s)\n", __func__, name, superkls-name, kls-name);
  assert(name          != nullptr);
  assert(superkls-name != nullptr);
  assert(kls-name      != nullptr);
  object-t kls = dk-klass-for-name(dk-register-klass(dk-make-named-info(name,
                                                                        #superklass-name, superkls-name,
                                                                        #klass-name,      kls-name,
                                                                        nullptr)));
  return kls;
}
klass each-box-func   { slots (*)(...) -> object-t; }
klass named-info-func { slots (*)(named-info-t*, each-box-func-t) -> void; }
klass str-box-func    { slots (*)(str-t) -> object-t; }
klass int-box-func    { slots (*)(intmax-t) -> object-t; }

static func each(named-info-t* root-info-list, named-info-func-t func, each-box-func-t user-data) -> void  {
  named-info-t* info;
  named-info-t* info-list = root-info-list;
  while ((info = info-list) != nullptr) {
    info-list = info-list->next;
    named-info-t* next = info->next;
    info->next = nullptr;
    func(info, user-data);
    info->next = next;
  }
  return;
}
static func each-str(named-info-t* info, str-box-func-t box-func) -> void  {
  core-node-t* ptrs = cast(core-node-t*)named-info::at(info, #str-ptrs);
  if (ptrs) {
    str-t* literals = cast(decltype(literals))named-info::at(info, #str-literals);
    assert(literals != nullptr);
    ssize-t i = 0;
    while (ptrs[i].item-ptr) {
      object-t item = box-func(literals[i]);
      core-node::set-all(&ptrs[i], item); // write-kls-ptr
      i++;
    }
  }
  return;
}
static func each-int(named-info-t* info, int-box-func-t box-func) -> void  {
  core-node-t* ptrs = cast(core-node-t*)named-info::at(info, #int-ptrs);
  if (ptrs) {
    intmax-t* literals = cast(decltype(literals))named-info::at(info, #int-literals);
    assert(literals != nullptr);
    ssize-t i = 0;
    while (ptrs[i].item-ptr) {
      object-t item = box-func(literals[i]);
      core-node::set-all(&ptrs[i], item); // write-kls-ptr
      i++;
    }
  }
  return;
}

static func named-info-to-registration-info(named-info-t* ni, registration-info-t* ri) -> void {
  *ri = {
    .generic-func-ptrs =      cast(decltype(ri->generic-func-ptrs))      named-info::at(ni, #generic-func-ptrs),
    .get-segment-data =       cast(decltype(ri->get-segment-data))       named-info::at(ni, #get-segment-data),
    .imported-klass-names =   cast(decltype(ri->imported-klass-names))   named-info::at(ni, #imported-klass-names),
    .imported-klass-ptrs =    cast(decltype(ri->imported-klass-ptrs))    named-info::at(ni, #imported-klass-ptrs),
    .interposers =            cast(decltype(ri->interposers))            named-info::at(ni, #interposers),
    .klass-defns =            cast(decltype(ri->klass-defns))            named-info::at(ni, #klass-defns),
    .name =                   cast(decltype(ri->name))                   named-info::at(ni, #name),
    .selectors =              cast(decltype(ri->selectors))              named-info::at(ni, #selectors),
    .signatures =             cast(decltype(ri->signatures))             named-info::at(ni, #signatures),
    .va-generic-func-ptrs =   cast(decltype(ri->va-generic-func-ptrs))   named-info::at(ni, #va-generic-func-ptrs),
    .va-selectors =           cast(decltype(ri->va-selectors))           named-info::at(ni, #va-selectors),
    .va-signatures =          cast(decltype(ri->va-signatures))          named-info::at(ni, #va-signatures),
  };
  return;
}
static func import-klass(symbol-t kls-name, core-node-t* node) -> void {
  assert-valid-str(kls-name);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%s\",\"%p\"]", __func__, kls-name, cast(ptr-t)(node));
  named-core-node-t named-node = { .name = kls-name, .node = node };
  result-t found-result = sorted-set-core::result-at(gbl-imported-klasses-table, &named-node);
  named-core-node-t* found-named-node = cast(decltype(found-named-node))found-result.item;

  if (found-named-node == nullptr) {
    named-node.node->next = nullptr;
    sorted-set-core::add-at(gbl-imported-klasses-table, found-result.offset, &named-node);
    sorted-set-core::add(gbl-imported-klasses-file-table, kls-name);
  } else {
    node->next = found-named-node->node;
    found-named-node->node = node;

    if (found-named-node->node == nullptr)
      sorted-set-core::add(gbl-imported-klasses-file-table, kls-name);
  }
  return;
}
static func import-klasses(symbol-t* kls-names, core-node-t* kls-nodes) -> void {
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%p\",\"%p\"]",
                        __func__,
                        cast(ptr-t)(kls-names),
                        cast(ptr-t)(kls-nodes));
  assert((kls-names != nullptr) &&
         (kls-nodes != nullptr));
  ssize-t i = 0;
  while (kls-names[i] != nullptr) {
    symbol-t     name =   kls-names[i];
    core-node-t* nodes = &kls-nodes[i];
    i++;
//     fprintf(stderr, "\"%s\": %p\n", name, nodes->item);
    import-klass(name, nodes);
  }
  return;
}
static func sort-named-info-array(named-info-t* info, symbol-t sub-info-key) -> void {
  if (info != nullptr) {
    named-info::sort(info);
    if (sub-info-key != nullptr) {
      named-info-t* sub-info = cast(named-info-t*)named-info::at(info, sub-info-key);
      if (sub-info != nullptr) {
        ssize-t i = 0;
        while (sub-info[i].items != nullptr)
          named-info::sort(&sub-info[i++]);
      }
    }
  }
  return;
}
static func sort-kls-info(named-info-t* info) -> void {
  sort-named-info-array(info, #slots-info);
  return;
}
static func sort-reg-info(named-info-t* info) -> void {
  sort-named-info-array(info, #klass-defns);
  named-info-t* klass-defns = cast(named-info-t*)named-info::at(info, #klass-defns);
  if (klass-defns != nullptr) {
    ssize-t i = 0;
    while (klass-defns[i].items != nullptr) {
      sort-kls-info(&klass-defns[i++]);
    }
  }
  return;
}
func dk-register-klass(named-info-t* kls-info) -> symbol-t {
  //fprintf(stderr, "%s(#%s)\n", __func__, cast(symbol-t)named-info::at(kls-info, #name));
  sort-kls-info(kls-info); // REQUIRED since symbols address are not known at compile time
  symbol-t name = name-from-info(kls-info);
  assert-valid-str(name);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%p\"],\"klass-name\":\"%s\"", __func__, cast(ptr-t)(kls-info), name);

  symbol-t interpose-name = cast(symbol-t)named-info::at(kls-info, #interpose-name);
  if (interpose-name != nullptr) {
    symbol-t type = cast(symbol-t)named-info::at(kls-info, #type, cast(intptr-t)#klass);
    assert(type == #klass);
    add-interpose-prop(interpose-name, name);
  }
  result-t found-result = sorted-set-core::result-at(gbl-klass-defns-table, kls-info);
  named-info-t* found-kls-info = cast(decltype(found-kls-info))found-result.item;

  if (found-kls-info == nullptr) {
    sorted-set-core::add-at(gbl-klass-defns-table, found-result.offset, kls-info);
  } else {
    assert(kls-info->next == nullptr);
    named-info-t* prev = found-kls-info->next;
    found-kls-info->next = kls-info;
    kls-info->next = prev;
  }
  return name;
}
static func register-klasses(named-info-t* kls-info) -> void {
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%p\"]", __func__, cast(ptr-t)(kls-info));
  ssize-t i = 0;

  while (kls-info[i].items != nullptr)
    dk-register-klass(&kls-info[i++]);
  return;
}
/*LOCAL*/ func interposer-name-for-klass-name(symbol-t kls-name) -> symbol-t {
  property-t key = { .key = kls-name, .item = cast(intptr-t)nullptr };
  result-t ss-result = sorted-set-core::result-at(gbl-interposers-table, &key);
  property-t* prop = cast(decltype(prop))ss-result.item;
  symbol-t result;

  if (prop == nullptr) {
    result = nullptr;
  } else {
    result = cast(symbol-t)(prop->item);
  }
//   if (result != nullptr)
//     fprintf(stderr, "%s = %s(%s)\n", result, __func__, kls-name);
  assert(kls-name != result);
  return result;
}
/*LOCAL*/ func add-interpose-prop(symbol-t key, symbol-t item) -> void {
//   dkt-log(dkt::k-log-info, "%s(%s, %s)", __func__, key, item);
  property-t prop = { .key = key, .item = cast(intptr-t)item };
  sorted-set-core::add(gbl-interposers-table, &prop);
  return;
}
static func add-interposers(property-t* interposers) -> void {
//assert(interposers != nullptr);
  ssize-t i = 0;
  while (interposers[i].key != nullptr) {
    property-t* prop = &interposers[i++];
    add-interpose-prop(prop->key, cast(symbol-t)(prop->item)); // hackhack: api should take property-t*
  }
//   if (interposers != nullptr)
//     fprintf(stderr, "===\n");
  return;
}
static func register-info-common(named-info-t* ni, each-box-func-t) -> void {
  registration-info-t ri {};
  named-info-to-registration-info(ni, &ri);

  assert((ri.signatures == nullptr    && ri.selectors == nullptr   ) ||
         (ri.signatures != nullptr    && ri.selectors != nullptr   ));
  assert((ri.va-signatures == nullptr && ri.va-selectors == nullptr) ||
         (ri.va-signatures != nullptr && ri.va-selectors != nullptr));

  if (ri.va-signatures != nullptr)
    import-selectors(ri.va-signatures, ri.va-selectors);
  if (ri.signatures != nullptr)
    import-selectors(ri.signatures, ri.selectors);
  if (ri.imported-klass-ptrs != nullptr)
    import-klasses(ri.imported-klass-names, ri.imported-klass-ptrs);
  if (ri.klass-defns != nullptr)
    register-klasses(ri.klass-defns);
  if (ri.interposers != nullptr)
    add-interposers(ri.interposers);

  return;
}

// object         klass' superklass is null instance (singleton)
// klass          klass' superklass is object klass
// null-singleton klass' superklass is object klass
//
// object         klass' klass is klass klass
// klass          klass' klass is klass klass
// null-singleton klass' klass is klass klass
func dk-init-runtime() -> void {
  //fprintf(stderr, "%s()\n", __func__);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[]", __func__);
  if (object::_klass_) // runtime already initiated
    return;
  init-runtime-ds();
  each(gbl-registration-info-list, register-info-common, cast(each-box-func-t)nullptr);

# if 0
  setenv-int("DKT_ECHO_ALLOC_INIT_DEALLOC", 1);
# endif

  // alloc
  klass::_klass_ =  alloc-klass(#klass); // must be first
  object::_klass_ = alloc-klass(#object);

  // init()
  object::_klass_ = init-klass(object::_klass_, #object); // must be first
  klass::_klass_ =  init-klass(klass::_klass_,  #klass);

  klass::mutable-unbox(object::_klass_).superkls = nullptr;

  object-t null-klass = dk-make-simple-klass(#null, #object, #singleton-klass);
  null = $make(null-klass); // first generic function executed
  klass::mutable-unbox(object::_klass_).superkls = null;
  null.has-exit-time-dtor(); // hackhack: to prevent dealloc on exit()

  // core runtime initialized

  // core runtime klasses are setup
  // klasses: object, klass, singleton-klass, null
  // and (null)

  // instantiation hier:
  //   klass <- klass
  //   klass <- object
  //   klass <- singleton-klass <- null <- (null)
  // inheritance hier:
  //   (null) <- object <- klass <- singleton-klass
  //   (null) <- object <- null

  assert(klass::_klass_           == klass-of(klass::_klass_));
  assert(klass::_klass_           == klass-of(singleton-klass::_klass_));
  assert(klass::_klass_           == klass-of(object::_klass_));
  assert(singleton-klass::_klass_ == klass-of(null-klass));
  assert(null-klass               == klass-of(null));

  assert(null            == superklass-of(object::_klass_));
  assert(object::_klass_ == superklass-of(klass::_klass_));
  assert(object::_klass_ == superklass-of(null-klass));
  assert(klass::_klass_  == superklass-of(singleton-klass::_klass_));
  assert(object::_klass_ == superklass-of(klass-of(null)));

# if !defined DKT-OMIT-BEHAVIOR
  $behavior(object::_klass_);
  $behavior(klass::_klass_);
  $behavior(singleton-klass::_klass_);
  $behavior(null-klass);
  $behavior(bit-vector::_klass_);
# endif

# if 0
  setenv-int("DKT_ECHO_ALLOC_INIT_DEALLOC", 1);
# endif

  std-input =  $make(input-stream::klass(),  #slots: stdin);
  std-output = $make(output-stream::klass(), #slots: stdout);
  std-error =  $make(output-stream::klass(), #slots: stderr);
  std-input.has-exit-time-dtor();  // hackhack: to prevent dealloc on exit()
  std-output.has-exit-time-dtor(); // hackhack: to prevent dealloc on exit()
  std-error.has-exit-time-dtor();  // hackhack: to prevent dealloc on exit()

  set-read-write();
  each(gbl-registration-info-list,
       cast(named-info-func-t)cast(func (*)(named-info-t*, str-box-func-t) -> void)each-str,
       cast(each-box-func-t)cast(str-box-func-t)str::box);
  each(gbl-registration-info-list,
       cast(named-info-func-t)cast(func (*)(named-info-t*, int-box-func-t) -> void)each-int,
       cast(each-box-func-t)cast(int-box-func-t)intmax::box);
  set-read-only();

# if 0
  $dump(object::_klass_);
  fprintf(stderr, "---\n");
  $dump(klass::_klass_);
  fprintf(stderr, "---\n");
  $dump(singleton-klass::_klass_);
  fprintf(stderr, "---\n");
  $dump(null-klass);
# if !defined DKT-OMIT-BEHAVIOR
  fprintf(stderr, "---\n");
  $dump(bit-vector::_klass_);
# endif
  fprintf(stderr, "---\n");
  $dump(null);
# endif
  if (getenv-int("DK_INIT_ALL_KLASSES"))
    init-imported-klasses();
  return;
}
/*LOCAL*/ func imported-klasses-for-klass(symbol-t kls-name) -> core-node-t* {
  assert-valid-str(kls-name);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%s\"]", __func__, kls-name);
  named-core-node-t named-node = { .name = kls-name, .node = nullptr };
  result-t node-result = sorted-set-core::result-at(gbl-imported-klasses-table, &named-node); // hackhack
  named-core-node-t* found-named-node = cast(decltype(found-named-node))node-result.item;
  core-node-t* result;

  if (found-named-node == nullptr)
    result = nullptr;
  else
    result = found-named-node->node;
  return result;
}
static func dump-interposers(ostream-t ostrm, named-info-t* registration-info) -> void {
  const property-t* interposers = cast(const property-t*)named-info::at(registration-info, #interposers);
  if (interposers != nullptr) {
    for (ssize-t i = 0; interposers[i].key != nullptr; i++)
      ostream::print-format(ostrm, "interpose %s, %s;\n", interposers[i].key, cast(symbol-t)interposers[i].item);
  }
  return;
}
[[unused]] static func remove-ext(char-t* path) -> char-t* {
  char-t* dot = cast(char-t*)strrchr(cast(const char-t*)path, '.');
  if (dot != nullptr)
    *dot = NUL;
  assert-valid-str(path);
  return path;
}
[[unused]] static func pad(char-t* buf, ssize-t buf-len, ssize-t len) -> char-t* {
  assert(buf-len >= len);
  snprintf(buf, sizeof(buf), "%*s", cast(int-t)len, "");
  return buf;
}
klass catalog-info {
  slots {
    symbol-t                  name;
    symbol-t                  superkls-name;
    symbol-t                  kls-name;

    symbol-t                  modulee;
    symbol-t                  cat;
    symbol-t                  type;
    symbol-t                  interpose-name;
    const symbol-t*           traits;
    const symbol-t*           requires;
    const symbol-t*           provides;
    const signature-t* const* method-aliases;
    const signature-t* const* method-signatures;
    const signature-t* const* kw-args-method-signatures;
    const signature-t* const* exported-method-signatures;
    const signature-t* const* exported-slots-method-signatures;
    const signature-t* const* slots-method-signatures;
  //const signature-t* const* va-method-signatures;
  //const signature-t* const* va-slots-method-signatures;
    const named-enum-info-t*  enum-info;
    const const-info-t*       const-info;
    str-t                     slots-type;
    str-t                     enum-base;
    named-info-t*             slots-info;
  }
}
static func named-info-to-catalog-info(named-info-t* ni, catalog-info::slots-t* ci) -> void {
  *ci = {
    .name =          name-from-info(ni),
    .superkls-name = superklass-name-from-info(ni),
    .kls-name =      klass-name-from-info(ni),

    .modulee =                          cast(decltype(ci->modulee))                           named-info::at(ni, #module),
    .cat =                              cast(decltype(ci->cat))                               named-info::at(ni, #cat, cast(intptr-t)#struct),
    .type =                             cast(decltype(ci->type))                              named-info::at(ni, #type, cast(intptr-t)#klass),
    .interpose-name =                   cast(decltype(ci->interpose-name))                    named-info::at(ni, #interpose-name),
    .traits =                           cast(decltype(ci->traits))                            named-info::at(ni, #traits),
    .requires =                         cast(decltype(ci->requires))                          named-info::at(ni, #requires),
    .provides =                         cast(decltype(ci->provides))                          named-info::at(ni, #provides),
    .method-aliases =                   cast(decltype(ci->method-aliases))                    named-info::at(ni, #method-aliases),
    .method-signatures =                cast(decltype(ci->method-signatures))                 named-info::at(ni, #method-signatures),
    .kw-args-method-signatures =        cast(decltype(ci->kw-args-method-signatures))         named-info::at(ni, #kw-args-method-signatures),
    .exported-method-signatures =       cast(decltype(ci->exported-method-signatures))        named-info::at(ni, #exported-method-signatures),
    .exported-slots-method-signatures = cast(decltype(ci->exported-slots-method-signatures))  named-info::at(ni, #exported-slots-method-signatures),
    .slots-method-signatures =          cast(decltype(ci->slots-method-signatures))           named-info::at(ni, #slots-method-signatures),
  //.va-method-signatures =             cast(decltype(ci->va-method-signatures))              named-info::at(ni, #va-method-signatures),
  //.va-slots-method-signatures =       cast(decltype(ci->va-slots-method-signatures))        named-info::at(ni, #va-slots-method-signatures),
    .enum-info =                        cast(decltype(ci->enum-info))                         named-info::at(ni, #enum-info),
    .const-info =                       cast(decltype(ci->const-info))                        named-info::at(ni, #const-info),
    .slots-type =                       cast(decltype(ci->slots-type))                        named-info::at(ni, #slots-type),
    .enum-base =                        cast(decltype(ci->enum-base))                         named-info::at(ni, #enum-base),
    .slots-info =                       cast(decltype(ci->slots-info))                        named-info::at(ni, #slots-info),
  };
  return;
}
static func max-enum-name-width(enum-info-t* enum-info) -> int-t {
  int-t result = 0;
  int-t i = 0;
  str-t name;
  while ((name = enum-info[i++].name) != nullptr) {
    ssize-t width = cast(ssize-t)safe-strlen(name);
    if (width > result)
      result = cast(int-t)width;
  }
  return result;
}
static func max-slot-type-width(named-info-t* slots-info) -> int-t {
  int-t result = 0;
  int-t i = 0;
  while (slots-info[i].items != nullptr) {
    str-t slot-type = cast(str-t)named-info::at(&slots-info[i++], #type);
    ssize-t width = cast(ssize-t)safe-strlen(slot-type);
    if (width > result)
      result = cast(int-t)width;
  }
  return result;
}
static func max-slot-name-width(named-info-t* slots-info) -> int-t {
  int-t result = 0;
  int-t i = 0;
  while (slots-info[i].items != nullptr) {
    str-t slot-name = cast(str-t)named-info::at(&slots-info[i++], #name);
    ssize-t width = cast(ssize-t)safe-strlen(slot-name);
    if (width > result)
      result = cast(int-t)width;
  }
  return result;
}
static func max-alias-name-width(const signature-t* const* method-aliases) -> int-t {
  int-t result = 0;
  int-t i = 0;
  const signature-t* alias;
  while ((alias = method-aliases[i]) != nullptr) {
    ssize-t width = cast(ssize-t)safe-strlen(alias->name);
    if (width > result)
      result = cast(int-t)width;
    i += 2;
  }
  return result;
}
static func dump-method(ostream-t ostrm, const signature-t* info, str-t attrs = nullptr) -> void {
  if (attrs == nullptr)
    ostream::print-format(ostrm, "method %s(%s) -> %s;\n",
                          info->name,
                          info->param-types,
                          info->return-type);
  else
    ostream::print-format(ostrm, "%s method %s(%s) -> %s;\n",
                          attrs,
                          info->name,
                          info->param-types,
                          info->return-type);
  return;
}
static func dump-klass(ostream-t ostrm, named-info-t* kls-info, symbol-t prev-module) -> symbol-t {
  assert(ostrm.output != nullptr);
  assert(8 > ostrm.col);
  assert(kls-info != nullptr);

  catalog-info::slots-t ci {};
  named-info-to-catalog-info(kls-info, &ci);

  assert-valid-str(ci.type);
  assert-valid-str(ci.name);
  assert(!(ci.interpose-name != nullptr && ci.superkls-name != nullptr));

  bool-t is-verbose = false;

  if (is-verbose) {
    if (ci.superkls-name == nullptr)
      ci.superkls-name = default-superklass-name();
    if (ci.kls-name == nullptr)
      ci.superkls-name = default-klass-name();
  } else {
    if (default-superklass-name() == ci.superkls-name)
      ci.superkls-name = nullptr;
    if (default-klass-name() == ci.kls-name)
      ci.kls-name = nullptr;
  }
# if defined DKT-ENABLE-EXPORT-GROUP
  if (prev-module != nullptr && prev-module != ci.modulee) {
    ostream::col-decr(ostrm);
    ostream::print-format(ostrm, "} // export\n"); // closes "export {" from prev dump-klass()
  }
# endif
  if (prev-module != ci.modulee) {
    ostream::print-format(ostrm, "module %s;\n\n", ci.modulee);
# if defined DKT-ENABLE-EXPORT-GROUP
    ostream::print-format(ostrm, "export {\n");
# endif
  }
# if defined DKT-ENABLE-EXPORT-GROUP
  ostream::col-incr(ostrm);
# endif
  bool-t is-exported =           false;
  bool-t has-exported-state =    false;
  bool-t has-exported-behavior = false;
  if (klass-exported?(kls-info, &is-exported, &has-exported-state, &has-exported-behavior))
    ostream::print-format(ostrm, "export %s %s {\n", ci.type, ci.name);
  else
    ostream::print-format(ostrm, "%s %s {\n", ci.type, ci.name);
  ostream::col-incr(ostrm);

  if (ci.interpose-name != nullptr)
    ostream::print-format(ostrm, "interpose %s;\n", ci.interpose-name);
  if (ci.superkls-name != nullptr)
    ostream::print-format(ostrm, "superklass %s;\n", ci.superkls-name);
  if (ci.kls-name != nullptr)
    ostream::print-format(ostrm, "klass %s;\n", ci.kls-name);
  if (ci.traits != nullptr) {
    ssize-t index = 0;

    while (ci.traits[index] != nullptr)
      ostream::print-format(ostrm, "trait %s;\n", ci.traits[index++]);
  }
  if (ci.requires != nullptr) {
    ssize-t index = 0;

    while (ci.requires[index] != nullptr)
      ostream::print-format(ostrm, "require %s;\n", ci.requires[index++]);
  }
  if (ci.provides != nullptr) {
    ssize-t index = 0;

    while (ci.provides[index] != nullptr)
      ostream::print-format(ostrm, "provides %s;\n", ci.provides[index++]);
  }
  if (ci.enum-info != nullptr) {
    ssize-t i = 0;
    while (ci.enum-info[i].info != nullptr) {
      if (ci.enum-info[i].name != nullptr)
        ostream::print-format(ostrm, "enum %s\n", ci.enum-info[i].name);
      else
        ostream::print-format(ostrm, "enum\n");
      ostream::print-format(ostrm, "{\n");
      ostream::col-incr(ostrm);
      int-t max-name-width = max-enum-name-width(ci.enum-info[i].info);
      int-t j = 0;
      while (ci.enum-info[i].info[j].name != nullptr) {
        ostream::print-format(ostrm, "%-*s = %s,\n",
                              max-name-width,
                              ci.enum-info[i].info[j].name,
                              ci.enum-info[i].info[j].expr);
        j++;
      }
      ostream::col-decr(ostrm);
      ostream::print-format(ostrm, "}\n");
      i++;
    }
  }
  if (ci.const-info != nullptr) {
    ssize-t i = 0;
    while (ci.const-info[i].name != nullptr) {
      ostream::print-format(ostrm, "const %s %s = %s;\n",
                            ci.const-info[i].type,
                            ci.const-info[i].name,
                            ci.const-info[i].value);
      i++;
    }
  }
# define DKT-DEBUG-CODEGEN 0
  if (DKT-DEBUG-CODEGEN || has-exported-state) {
    if (ci.slots-type != nullptr) {
      ostream::print-format(ostrm, "export slots %s;\n", ci.slots-type);
    }
    else if (ci.slots-info != nullptr) {
        if (ci.cat == nullptr || ci.cat == #struct)
          ostream::print-format(ostrm, "export slots {\n");
        else if (ci.enum-base)
                  ostream::print-format(ostrm, "export slots %s: %s {\n", ci.cat, ci.enum-base);
        else
          ostream::print-format(ostrm, "export slots %s {\n", ci.cat);
        ostream::col-incr(ostrm);
        if (ci.cat == #enum) {
          int-t max-type-width = max-slot-name-width(ci.slots-info);
          int-t i = 0;
          while (ci.slots-info[i].items != nullptr) {
            named-info-t* slots-info = &ci.slots-info[i++];
            symbol-t slot-name = name-from-info(slots-info);
            assert-valid-str(slot-name);
            str-t slot-expr-str = cast(str-t)named-info::at(slots-info, #expr-str);
            assert-valid-str(slot-expr-str);

            ostream::print-format(ostrm, "%-*s = %s,\n", max-type-width, slot-name, slot-expr-str);
          }
        } else {
          int-t max-type-width = max-slot-type-width(ci.slots-info);
          ssize-t i = 0;
          while (ci.slots-info[i].items != nullptr) {
            named-info-t* slots-info = &ci.slots-info[i++];
            str-t slot-type =   cast(str-t)named-info::at(slots-info, #type, cast(intptr-t)#object-t);
            str-t slot-typeid = cast(str-t)named-info::at(slots-info, #typeid);
            USE(slot-typeid);
            assert-valid-str(slot-type);
            symbol-t slot-name = name-from-info(slots-info);
            assert-valid-str(slot-name);
            // printf("%s::%s, type: %s, typeid: %s\n", name, slot-name, slot-type, slot-typeid);
            str-t slot-expr-str = cast(str-t)named-info::at(slots-info, #expr-str);

            if (slot-expr-str != nullptr)
              ostream::print-format(ostrm, "%-*s %s = %s;\n", max-type-width, slot-type, slot-name, slot-expr-str);
            else
              ostream::print-format(ostrm, "%-*s %s;\n", max-type-width, slot-type, slot-name);
          }
        }
        ostream::col-decr(ostrm);
        ostream::print-format(ostrm, "}\n");
      } else {
        fprintf(stderr, "%s:%i: ERROR: %s %s: exported slots without type or info\n", __FILE__, __LINE__, ci.type, ci.name);
    }
  } // if (has-exported-state)
  if ((ci.superkls-name != nullptr || ci.kls-name != nullptr || ci.traits != nullptr || ci.requires != nullptr || ci.provides != nullptr)
      && ci.method-signatures != nullptr) {
    ostream::print-format(ostrm, "\n");
  }
  const signature-t* sig;

  ssize-t index = 0;
  if (ci.kw-args-method-signatures != nullptr)
    while ((sig = ci.kw-args-method-signatures[index++]) != nullptr)
      dump-method(ostrm, sig);

  index = 0;
  if (ci.method-signatures != nullptr)
    while ((sig = ci.method-signatures[index++]) != nullptr)
      dump-method(ostrm, sig);

  index = 0;
  if (ci.slots-method-signatures != nullptr)
    while ((sig = ci.slots-method-signatures[index++]) != nullptr)
      dump-method(ostrm, sig);

  index = 0;
  if (ci.exported-method-signatures != nullptr)
    while ((sig = ci.exported-method-signatures[index++]) != nullptr)
      dump-method(ostrm, sig);

  index = 0;
  if (ci.exported-slots-method-signatures != nullptr)
    while ((sig = ci.exported-slots-method-signatures[index++]) != nullptr)
      dump-method(ostrm, sig);

  index = 0;
  if (ci.method-aliases != nullptr) {
    int-t max-width = max-alias-name-width(ci.method-aliases);
    ostream::print-format(ostrm, "\n");
    char-t[128] attrs = "";
    const signature-t* alias;
    while ((alias = ci.method-aliases[index++]) != nullptr) {
      sig = ci.method-aliases[index++];
      ssize-t width = cast(ssize-t)safe-strlen(alias->name);
      int-t pad-width = cast(int-t)(max-width - width);
      int-t len = snprintf(attrs, sizeof(attrs), "[[alias(%s)]]%*s", alias->name, pad-width, "");
      if (len >= cast(int-t)sizeof(attrs))
        attrs[sizeof(attrs) - 1] = NUL;
      dump-method(ostrm, sig, attrs);
    }
  }
  ostream::col-decr(ostrm);
  ostream::print-format(ostrm, "}\n");
  return ci.modulee;
}
static func dump-include-for-decls(ostream-t ostrm, named-info-t* registration-info) -> void {
  assert(ostrm.output != nullptr);
  assert(8 > ostrm.col);
  assert(registration-info != nullptr);

  const str-t* include-fors = cast(decltype(include-fors))named-info::at(registration-info, #include-fors);

  if (include-fors) {
    ssize-t i = 0;
    while (1) {
      str-t h = include-fors[i++];
      assert(h != nullptr);
      ostream::print-format(ostrm, "include-for %s", h);
      str-t d = " ";
      str-t t;
      while ((t = include-fors[i++]) != nullptr) {
        ostream::print-format(ostrm, "%s%s", d, t);
        d = ", ";
      }
      ostream::print-format(ostrm, ";\n");
      if (include-fors[i] == nullptr)
        break;
    }
  }
  return;
}
static func count-of(named-info-t* registration-info, symbol-t key) -> ssize-t {
  assert(registration-info != nullptr);
  assert(key != nullptr);

  ssize-t total-count = 0;

  named-info-t* ni = cast(named-info-t*)named-info::at(registration-info, key);
  if (ni != nullptr)
    total-count = ni->count;
  return total-count;
}
static func total-count-of(named-info-t* registration-info, symbol-t[] keys) -> ssize-t {
  assert(registration-info != nullptr);
  assert(keys != nullptr);

  ssize-t total-count = 0;

  for (int-t i = 0; symbol-t key = keys[i]; i++)
    total-count += count-of(registration-info, key);
  return total-count;
}
static func dump-klass-defns(ostream-t ostrm, named-info-t* registration-info, str-t only, bool-t exported-only) -> void {
  assert(ostrm.output != nullptr);
  assert(8 > ostrm.col);
  assert(registration-info != nullptr);

  str-t output-dir = getenv("DAKOTA_CATALOG_OUTPUT_DIRECTORY");
  named-info-t* klass-defns = cast(named-info-t*)named-info::at(registration-info, #klass-defns);

  if (klass-defns) {
    ssize-t i = 0;

    if (output-dir != nullptr) {
      int-t n = mkdir(output-dir, 0755);
      if (n == -1 && errno != EEXIST)
        exit-fail-with-msg("ERROR: %s: \"%s\"", output-dir, strerror(errno));
    }
    symbol-t prev-module = nullptr;
    while (klass-defns[i].items != nullptr) {
      named-info-t* kls-info = &klass-defns[i++];
      if (exported-only && !klass-exported?(kls-info))
        continue;
      if (only != nullptr && !dump?(kls-info, only))
        continue;
      if (1)
        prev-module = dump-klass(ostrm, kls-info, prev-module);
      if (output-dir != nullptr) {
        char-t[255 + (1)] klass-file = "";
        symbol-t kls-name = name-from-info(kls-info);
        snprintf(klass-file, sizeof(klass-file), "%s/%s.ctlg", output-dir, kls-name);
        ostream-t dostrm = ostream::fopen(klass-file);
        dump-klass(dostrm, kls-info, nullptr);
# if defined DKT-ENABLE-EXPORT-GROUP
        ostream::col-decr(dostrm);
        ostream::print-format(dostrm, "} // export\n"); // closes "export {" from dump-klass()
# endif
        ostream::fclose(dostrm);
      }
    }
# if defined DKT-ENABLE-EXPORT-GROUP
    ostream::col-decr(ostrm);
    ostream::print-format(ostrm, "} // export\n"); // closes "export {" from dump-klass()
# endif
  }
  return;
} // dump-klass-defns()
klass get-segment-data-func {
  slots (*)(str-t, ptr-t*, size-t*) -> ptr-t;
}
klass registration-info {
  slots {
    generic-func-t*    generic-func-ptrs;
    get-segment-data-func-t get-segment-data;
    symbol-t*          imported-klass-names;
    core-node-t*       imported-klass-ptrs;
    property-t*        interposers;
    named-info-t*      klass-defns;
    symbol-t           name;
    selector-node-t*   selectors;
    signature-t**      signatures;
    generic-func-t*    va-generic-func-ptrs;
    selector-node-t*   va-selectors;
    signature-t**      va-signatures;
  }
}
static func add-registration-info(named-info-t* registration-info) -> void {
  assert(registration-info->next == nullptr);
  registration-info->next = gbl-registration-info-list;
  gbl-registration-info-list = registration-info;
  return;
}
klass x::siginfo {
  slots siginfo-t;
}
klass x::sigaction-handler {
  slots (*)(int-t, x::siginfo-t*, ptr-t) -> void;
}
klass x::sigaction {
  slots struct sigaction;
}
klass x::sigaction-pair {
  slots {
    x::sigaction-handler-t handler;
    x::sigaction-t         prev-sa;
  }
}
static int8-t const index-from-sig-data[NSIG] = {
  // [SIGBUS] =  0,
  // [SIGSEGV] = 1,
};
static func index-from-sig(int-t sig) -> int8-t {
  return 0;
  return index-from-sig-data[sig];
}
static x::sigaction-pair-t[] sa-pairs = {
  { .handler = nullptr, .prev-sa = {} },
  { .handler = nullptr, .prev-sa = {} },
};
klass addr2name-pair {
  slots {
    ptr-t*   addr;
    symbol-t name;
  }
}
static addr2name-pair-t[] named-instances = {
  { .addr = cast(ptr-t*)&null,       .name = #null       }, /// &object-t
  { .addr = cast(ptr-t*)&std-input,  .name = #std-input  }, /// &object-t
  { .addr = cast(ptr-t*)&std-output, .name = #std-output }, /// &object-t
  { .addr = cast(ptr-t*)&std-error,  .name = #std-error  }, /// &object-t
};
klass so-symbol-info {
  slots {
    str-t fname;
    str-t sname;
  }
}
static func symbol-name-for-addr(ptr-t addr, so-symbol-info::slots-t* info) -> so-symbol-info::slots-t* { // slowslow
  // named-instances
  for (ssize-t i = 0; i < scountof(named-instances); i++) {
    addr2name-pair-t named-instance = named-instances[i];
    if (named-instance.addr == addr) {
        info->fname = nullptr; // fixfix
        info->sname = named-instance.name;
        return info;
    }
  }
  named-info-t* ni = gbl-registration-info-list;
  while (ni != nullptr) {
    registration-info-t ri {};
    named-info-to-registration-info(ni, &ri);
    //printf("name: \"%s\"\n", ri.name);

    // imported-klasses
    for (int-t i = 0; ri.imported-klass-ptrs[i].item-ptr != nullptr; i++) {
      if (ri.imported-klass-ptrs[i].item-ptr == cast(object-t*)addr) {
        info->fname = ri.name;
        info->sname = ri.imported-klass-names[i];
        return info;
      }
    }
    ni = ni->next;
  }
  return nullptr;
}
[[noreturn]] static func bus-segv-handler(int-t sig, x::siginfo-t *si, void *dummy) -> void {
  str-t sname-mangled = dso-symbol-name-for-addr(si->si-addr);
  if (sname-mangled != nullptr) {
      int status = -1;
      str-t sname-demangled = abi::__cxa_demangle(sname-mangled, nullptr, nullptr, &status);
      if (status != 0)
        sname-demangled = sname-mangled;
      syslog(LOG-ERR, "caught sig%s in \"%s\" at \"%s\" %p\n",
             strsignal-name(sig), dso-abs-path-containing-addr(si->si-addr), sname-demangled, si->si-addr);
      if (status == 0)
        free(cast(ptr-t)sname-demangled);
  } // else {}
  so-symbol-info::slots-t info {};
  // could use dso-symbol-name-for-addr()
  if (symbol-name-for-addr(si->si-addr, &info)) {
    if (info.fname == nullptr) {
      syslog(LOG-ERR, "caught sig%s at named-instance \"%s\" %p\n",
             strsignal-name(sig), info.sname, si->si-addr);
    } else {
      syslog(LOG-ERR, "caught sig%s in \"%s\" at \"%s::_klass_\" %p\n",
             strsignal-name(sig), info.fname, info.sname, si->si-addr);
    }
  }
  x::sigaction-handler-t prev-sa-handler =
    sa-pairs[index-from-sig(sig)].prev-sa.sa-sigaction;

  if (prev-sa-handler &&
      prev-sa-handler != cast(x::sigaction-handler-t)SIG-DFL &&
      prev-sa-handler != cast(x::sigaction-handler-t)SIG-IGN) {
    prev-sa-handler(sig, si, dummy);
  }
  switch (sig) {
    case SIGBUS:
      throw $make(sigbus-exception::klass());
      break;
    case SIGSEGV:
      throw $make(sigsegv-exception::klass());
      break;
    default:
      throw $make(signal-exception::klass());
  }
}
static func sigaction-setup(int-t sig, x::sigaction-handler-t bus-segv-handler) -> int-t {
  x::sigaction-t sa {};
  sa.sa-flags = cast(decltype(sa.sa-flags))(SA-SIGINFO | SA-RESETHAND | SA-RESTART);
  sigemptyset(&sa.sa-mask);
  sa.sa-sigaction = bus-segv-handler;

  sa-pairs[index-from-sig(sig)].prev-sa.sa-sigaction = nullptr;
  int-t r = sigaction(sig, &sa, &sa-pairs[index-from-sig(sig)].prev-sa);
  if (r == -1) {
    exit-fail-with-msg("ERROR: %s: \"%s\"", "sigaction", strerror(errno));
  }
  return r;
}
static func set-protection(str-t segment, int-t protection, get-segment-data-func-t get-segment-data) -> int-t {
  assert-valid-str(segment);
  ptr-t addr = nullptr;
  size-t size = 0;
  get-segment-data(segment, &addr, &size); // code-generated in each lib/exe

  int-t result = -1;
  if (addr != nullptr) {
    result = mprotect(addr, size, protection);
    if (result == -1) {
      exit-fail-with-msg("ERROR: %s: \"%s\"", "mprotect", strerror(errno));
    }
  }
  return result;
}
static func set-protection-all(str-t segment, int-t protection) -> int-t {
  int-t result = 0;
  named-info-t* ni = gbl-registration-info-list;
  while (ni != nullptr) {
    registration-info-t ri {};
    named-info-to-registration-info(ni, &ri);
    int-t r = set-protection(segment, protection, cast(get-segment-data-func-t)ri.get-segment-data);
    if (r != 0)
      result = r;
    ni = ni->next;
  }
  return result;
}
func set-read-only() -> int-t {
  int-t r = set-protection-all("__DKT_READ_ONLY", PROT-READ);
  if (r != 0)
    exit-fail-with-msg("ERROR: %s: \"%s\"", "mprotect", strerror(errno));
  return r;
}
func set-read-write() -> int-t {
  int-t r = set-protection-all("__DKT_READ_ONLY", PROT-READ | PROT-WRITE);
  if (r != 0)
    exit-fail-with-msg("ERROR: %s: \"%s\"", "mprotect", strerror(errno));
  return r;
}
static func dump-random() -> void {
  if (getenv-int("DKT_DUMP_RANDOM")) {
    printf("null-method: %p\n", cast(ptr-t)DKT-NULL-METHOD);
    printf("num-generics: %zi\n", selector-count());
  }
  return;
}
static func last-user-code-before-main() -> void  {
  dump-random();
  return;
}

static named-info-t* next-dumped-registration-info = nullptr;
static func dump-registration-info(named-info-t* registration-info, bool-t is-root) -> void {
  symbol-t type = cast(symbol-t)named-info::at(registration-info, #type, cast(intptr-t)#executable);
  bool-t ctlg-exported-only = getenv-int("DAKOTA_CATALOG_EXPORTED_ONLY");
  bool-t ctlg-recursive =     getenv-int("DAKOTA_CATALOG_RECURSIVE");
  str-t  ctlg-output-path =   getenv("DAKOTA_CATALOG_OUTPUT");
  str-t  ctlg-only =          getenv("DAKOTA_CATALOG_ONLY");
  ostream-t ostrm = {};
  if (ctlg-output-path != nullptr) {
    if (ctlg-output-path[0] == NUL) // empty-string ("") means use default-value
      ostrm = { .output = stdout, .col = 0 };
    else
      ostrm = ostream::fopen(ctlg-output-path, "a"); // ctlg-output-path is initially truncated by dakota-catalog
    symbol-t name = name-from-info(registration-info);
    assert-valid-str(name);
    static symbol-t[] keys = {
      #klass-defns,
      #interposers,
      nullptr
    };
    if (ctlg-recursive || is-root) {
      if (total-count-of(registration-info, keys)) {
        ostream::print-format(ostrm, "// -*- mode: c++; mode: dakota -*-\n");
        ostream::print-format(ostrm, "// DO NOT EDIT!! generated by dakota-catalog from %s: %s\n\n", type, name);
        dump-include-for-decls(ostrm, registration-info);
        dump-klass-defns(ostrm, registration-info, ctlg-only, ctlg-exported-only);
        dump-interposers(ostrm, registration-info);
      }
    }
    if (ostrm.output != nullptr)
      ostream::fclose(ostrm);
  }
  return;
}
func dkt-register-info(named-info-t* registration-info) -> void {
  //fprintf(stderr, "%s(\"%s\")\n", __func__, cast(symbol-t)named-info::at(registration-info, #name));
  if (registration-info == nullptr)
    return;
  sort-reg-info(registration-info); // REQUIRED since symbols address are not known at compile time
  if (next-dumped-registration-info) {
    dump-registration-info(next-dumped-registration-info, false);
  }
  next-dumped-registration-info = registration-info;
  // str-t dso-path = dso-abs-path-containing-addr(registration-info);
  // if (dso-path != nullptr)  {
  //   int-t overwrite;
  //   setenv("DKT_SHARED_LIBRARY_PATH", dso-path, overwrite = 1);
  // }
  symbol-t type = cast(symbol-t)named-info::at(registration-info, #type, cast(intptr-t)#executable);
  switch (type) {
    case #shared-library:
      add-registration-info(registration-info);
      break;
    case #executable:
    default:
      openlog(getprogname(), LOG-CONS | LOG-PID | LOG-PERROR, LOG-USER);
      sigaction-setup(SIGBUS,  bus-segv-handler);
      sigaction-setup(SIGSEGV, bus-segv-handler);
      add-registration-info(registration-info);
      if (!getenv-int("DKT_NO_INIT_RUNTIME"))
        dk-init-runtime();
      if (getenv-int("DAKOTA_CATALOG_JSON"))
        json-dump-klass-defns(gbl-klass-defns-table);
      if (getenv-int("DKT_JSON_DUMP_RESOURCE_INFO"))
        json-dump-resource-info(gbl-klass-defns-table);
      last-user-code-before-main();
      if (getenv-int("DKT_EXIT_BEFORE_MAIN"))
        exit(EXIT-SUCCESS);
  }
  return;
}
func dkt-deregister-info(named-info-t* registration-info) -> void {
  if (registration-info == nullptr) {
    if (next-dumped-registration-info) {
      dump-registration-info(next-dumped-registration-info, true);
      next-dumped-registration-info = nullptr;
    }
    return;
  }
  set-read-write();
  if (getenv-int("DAKOTA_CATALOG_OUTPUT") ||
      getenv-int("DKT_NO_INIT_RUNTIME") ||
      !null)
    return;
  named-info-t* klass-defns = cast(named-info-t*)named-info::at(registration-info, #klass-defns);

  if (klass-defns != nullptr) { // this should be done in reverse
    ssize-t i = 0;

    while (klass-defns[i].items != nullptr) {
      named-info-t* kls-info = &klass-defns[i++];
      symbol-t kls-name = name-from-info(kls-info);
      // const symbol-t* traits = cast(const symbol-t*)named-info::at(kls-info, #traits);
      // if (traits != nullptr) {
      //   object-t kls = dk-klass-for-name(kls-name);
      //   klass::traits-finalize(kls, traits);
      // }
      finalize-func-t klass-finalize = cast(finalize-func-t)named-info::at(kls-info, #finalize);
      if (klass-finalize != nullptr) {
        core-node-t* kls-nodes = imported-klasses-for-klass(kls-name);
        if (kls-nodes != nullptr) {
          object-t kls = *(kls-nodes->item-ptr);
          if (kls != nullptr) {
            DKT-LOG-INITIAL-FINAL("\"action\":\"%s\",\"args\":[\"%s\"],\"klass\":\"%s\",\"file\":\"%s\"",
                                  "finalize", "klass", kls-name,
                                  cast(symbol-t)named-info::at(kls-info, #file));

            klass-finalize(kls);
          }
        }
      }
    }
  }
  symbol-t name = name-from-info(registration-info);
  assert-valid-str(name);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%p\"],\"klass-name\":\"%s\"", __func__, cast(ptr-t)(registration-info), name);
  return;
}
static func klass-for-name-simple(symbol-t name) -> object-t {
  core-node-t* kls-nodes = imported-klasses-for-klass(name);
  // if (kls-nodes == nullptr) printf("klass='%s', not imported\n", name);
  object-t kls = nullptr;
  if (kls-nodes != nullptr)
    kls = *(kls-nodes->item-ptr);
  return kls; // may be nullptr
}
static func klass-for-name-recursive(symbol-t name, ssize-t column = 0) -> object-t {
  // for (ssize-t i = 0; i < column; i++) fprintf(stderr, "  "); fprintf(stderr, "%s(#%s)\n", __func__, name);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%s\"]", __func__, name);
  assert-valid-str(name);
  named-info-t* info-slots = info-for-name(name);
  assert(info-slots != nullptr);
  assert(cast(symbol-t)named-info::at(info-slots, #type, cast(intptr-t)#klass) == #klass);
  object-t kls = klass-for-name-simple(name);

  if (kls != nullptr)
    return kls;

  // superklass chain first
  symbol-t superkls-name;
  if ((superkls-name = superklass-name-from-info(info-slots)) != nullptr)
    if (klass-for-name-simple(superkls-name) == nullptr)
      klass-for-name-recursive(superkls-name, column + 1); // recursive

  symbol-t kls-name;
  object-t kls-klass;
  if ((kls-name = klass-name-from-info(info-slots)) != nullptr) {
    if ((kls-klass = klass-for-name-simple(kls-name)) == nullptr)
      kls-klass = klass-for-name-recursive(kls-name, column + 1); // recursive
  }
  else
    kls-klass = klass::_klass_;

  if (kls-klass != klass::_klass_ && !klass::subklass?(kls-klass, klass::_klass_)) // hardhard
    throw $make(illegal-klass-exception::klass());

  kls = $make(kls-klass, #name: name);
  return kls;
}
func dk-klass-for-name(symbol-t name) -> object-t {
  ssize-t column;
  object-t kls = klass-for-name-recursive(name, column = 0);
  return kls;
}
/*LOCAL*/ func info-for-name(symbol-t kls-name) -> named-info-t* {
  assert-valid-str(kls-name);
  property-t[] properties = { { .key = #name, .item = cast(intptr-t)kls-name } };
  named-info-t info = { .next = nullptr, .count = scountof(properties), .items = properties };
  result-t info-result = sorted-set-core::result-at(gbl-klass-defns-table, &info);
  named-info-t* kls-info = cast(decltype(kls-info))info-result.item;

  if (kls-info == nullptr) {
    str-t klasspath = getenv("KLASSPATH");

    if (klasspath == nullptr) {
      fprintf(stderr, "%s:%i: ERROR: klass '%s' not found and KLASSPATH not set.\n", __FILE__, __LINE__, kls-name);
      throw $make(exception::klass(), #msg: "bummer");
    } else {
      //fprintf(stdout, "KLASSPATH=%s\n", klasspath);
      str-t file-name = file-name-from-klass-name(kls-name);
      str-t file = find-file(klasspath, file-name, "so"); // hackhack: the extension should be handeled in a platform neutral way

      if (file != nullptr) {
        dso-open(file, 0);

        // aggregate klass here

        named-info-t* loaded-kls-info = info-for-name(kls-name); // recursive
        return loaded-kls-info; // rnielsen: should have only one return per func
      }
      fprintf(stderr, "%s:%i: ERROR: klass '%s' not found.\n", __FILE__, __LINE__, kls-name);
      throw $make(exception::klass(), #msg: "bummer");
    }
  }
  return kls-info; // rnielsen: should have only one return per func
}
// dk-intern needs to be able to be used **early** in the static initialization sequence.
func dk-intern-free(str-t key) -> symbol-t {
  symbol-t result = dk-intern(key);
  if (result != key)
    free(cast(ptr-t)key);
  return result;
}
func dk-intern(str-t key) -> symbol-t {
  assert(key != nullptr);
  assert(key[0] != NUL);
  DKT-LOG-TRACE-RUNTIME("\"func\":\"%s\",\"args\":[\"%s\"]", __func__, key);
  // start with half a page (4096/2 bytes) of intern memory
  bool-t is-ptr;
  static sorted-set-core-t* intern-array = sorted-set-core::create((4096/2)/sizeof(symbol-t),
                                                                      ssizeof(symbol-t),
                                                                      cast(std-compare-t)
                                                                      cast(symbol-compare-t)symbol-str-compare,
                                                                      is-ptr = true);
# if 0
  symbol-t val = key;
# else
  symbol-t val = cast(symbol-t)sorted-set-core::add(intern-array, cast(const void*)(key));
//fprintf(stderr, "%s(\"%s\" {%p}) = \"%s\" {%p}\n", __func__, key, key, val, val);
# endif
  //dkt-log(dkt::k-log-info, "%s(\"%s\" {%p}) = \"%s\" {%p}", __func__, key, key, val, val);
  return val;
}
static func get-klass-chain(object-t kls, char-t* buf, ssize-t buf-len) -> char-t* { // recursive
  object-t superkls = superklass-of(kls);
  if (superkls != null)
    get-klass-chain(superkls, buf, buf-len); // recursive
  str-t kls-name = name-of(kls);
  strcat(buf, "/");
  strcat(buf, kls-name);
  return buf;
}
func dkt-get-klass-chain(object-t kls, char-t* buf, ssize-t buf-len) -> char-t* {
  buf[0] = NUL;
  return get-klass-chain(kls, buf, buf-len);
}
func dkt-abs-path-containing-addr(ptr-t addr) -> str-t {
  str-t result = dso-abs-path-containing-addr(addr);
  return result;
}
func dkt-file-type-containing-addr(ptr-t addr) -> symbol-t {
  symbol-t result = dk-intern(dso-file-type-containing-addr(addr));
  return result;
}
