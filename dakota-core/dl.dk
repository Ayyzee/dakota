// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module dakota-core;

# include <dlfcn.h> // dlopen(), dlclose(), dladdr(), struct Dl-info

# include "dl.hh"

// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/dlfcn.h.html

// dso-open() mode flags (default is dso-NOW|dso-LOCAL)
const int-t dso-LAZY = RTLD-LAZY;
const int-t dso-NOW =  RTLD-NOW;
//
const int-t dso-GLOBAL = RTLD-GLOBAL;
const int-t dso-LOCAL =  RTLD-LOCAL;

// dso-symbol() pseudo handles
const ptr-t dso-DEFAULT = RTLD-DEFAULT;
const ptr-t dso-NEXT =    RTLD-NEXT;

klass x::dl-info {
  slots Dl-info;
}
func dso-open(str-t name, int mode) -> ptr-t {
# if defined WIN32
  USE(mode);
  HINSTANCE handle = LoadLibrary(name);
# else
  if (0 == mode)
    mode = dso-NOW | dso-LOCAL;
  ptr-t handle = dlopen(name, mode);
# endif
  return cast(ptr-t)handle;
}
// returns nullptr if no exact match
func dso-symbol-name-for-addr(ptr-t addr) -> str-t {
  str-t result = nullptr;
# if defined WIN32
# error "not yet implemented on win32"
# else
  x::dl-info::slots-t dli;
  if (0 != dladdr(addr, &dli) && (dli.dli-saddr == addr))
    result = dli.dli-sname;
# endif
  return result;
}
func dso-abs-path-containing-addr(ptr-t addr) -> str-t {
  str-t result = nullptr;
# if defined WIN32
# error "not yet implemented on win32"
# else
  Dl-info dl-info {};
  if (dladdr(addr, &dl-info))
    result = dl-info.dli-fname;
# endif
  return result;
}
func dso-symbol(ptr-t handle, str-t symbol-name) -> ptr-t {
  ptr-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlsym(handle, symbol-name);
# endif
  return result;
}
func dso-close(ptr-t handle) -> int-t {
  int-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlclose(handle);
# endif
  return result;
}
func dso-error() -> str-t {
  str-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlerror();
# endif
  return result;
}
