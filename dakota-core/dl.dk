// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module dakota-core;

# include <dlfcn.h> // dlopen(), dlclose(), dladdr(), struct Dl-info

# include "dl.hh"

// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/dlfcn.h.html

// dso-open() mode flags (default contains DSO-OPEN-MODE.NOW)
// this is different (but safer) than dlopen() default mode flags (default contains RTLD-LAZY)

const dso-open-mode-t DSO-OPEN-MODE = {
  .NOW =  RTLD-NOW,  // default
  .LAZY = RTLD-LAZY, // dlopen() default

  .GLOBAL = RTLD-GLOBAL, // default
  .LOCAL =  RTLD-LOCAL,

  .NOLOAD = RTLD-NOLOAD,
};
const dso-symbol-handle-t DSO-SYMBOL-HANDLE = {
  .DEFAULT = RTLD-DEFAULT,
  .NEXT =    RTLD-NEXT,
};

static inline boole-t bit-set?(int-t word, uint-t pos) {
  boole-t state = word & (1 << pos);
  return state;
}
static inline boole-t bit-set?(int-t word, int-t pos) {
  return bit-set?(word, cast(uint-t)pos);
}

klass dso-info {
  slots Dl-info;
}
func dso-open(str-t name, int-t mode) -> ptr-t {
# if defined WIN32
  USE(mode);
  HINSTANCE handle = LoadLibrary(name);
# else
  if (!bit-set?(mode, DSO-OPEN-MODE.LAZY))
    mode = DSO-OPEN-MODE.NOW;
  ptr-t handle = dlopen(name, mode);
# endif
  return cast(ptr-t)handle;
}
// returns nullptr if no exact match
func dso-symbol-name-for-addr(ptr-t addr) -> str-t {
  str-t result = nullptr;
# if defined WIN32
# error "not yet implemented on win32"
# else
  dso-info::slots-t dli {};
  if (0 != dladdr(addr, &dli) && (dli.dli-saddr == addr))
    result = dli.dli-sname;
# endif
  return result;
}
func dso-abs-path-containing-addr(ptr-t addr) -> str-t {
  str-t result = nullptr;
# if defined WIN32
# error "not yet implemented on win32"
# else
  dso-info::slots-t dli {};
  if (dladdr(addr, &dli))
    result = dli.dli-fname;
# endif
  return result;
}
func dso-symbol(ptr-t handle, str-t symbol-name) -> ptr-t {
  ptr-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlsym(handle, symbol-name);
# endif
  return result;
}
func dso-close(ptr-t handle) -> int-t {
  int-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlclose(handle);
# endif
  return result;
}
func dso-error() -> str-t {
  str-t result;
# if defined WIN32
# error "not yet implemented on win32"
# else
  result = dlerror();
# endif
  return result;
}
