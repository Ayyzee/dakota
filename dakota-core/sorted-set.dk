// -*- mode: dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

# include <cassert>
# include <cinttypes>
# include <cstdlib>
# include <cstring>

# include "sorted-array.hh"

module dakota-core;

klass compare;
klass exception;
klass equals;
klass object-output-stream;
klass result;
klass sorted-array;
klass std-compare;

klass sorted-set {
  superklass collection;

  trait set;

  slots {
    sorted-array::slots-t sa;
    ssize-t               iterator-state;
  }
  // 'elements' is a collection (of objects)
  // 'objects' is a nullptr terminated array (of objects)
  // using compound literals 'objects' can be used as follows:
  // $init(o, #objects : cast(object-t[]){ o1, o2, nullptr });

  method init(object-t   self,
              compare-t  compare :          $compare,
              ssize-t    initial-capacity : 64,
              object-t   elements :         nullptr,
              object-t[] objects :          nullptr) -> object-t {
    assert(0 < initial-capacity);
    self = $init(super);
    boole-t ptr?;
    sorted-array::create(&self.sa,
                         initial-capacity,
                         ssizeof(ptr-t),
                         cast(std-compare-t)compare,
                         ptr? = true);
    self.iterator-state = 0;

    if (nullptr != elements)
      $add-all(self, elements);

    if (nullptr != objects)
      $add-objects(self, objects);
    return self;
  }
  method dealloc(object-t self) -> object-t {
    dkt::dealloc(self.sa.elements);
    object-t result = $dealloc(super);
    return result;
  }
  method add(object-t self, object-t element) -> object-t {
    object-t result = element;
    self.iterator-state++;
    result-t found-result = sorted-array::search(&self.sa, element);

    if (nullptr == found-result.element)
      sorted-array::add-at(&self.sa, element, found-result.offset);
    else
      result = cast(object-t)found-result.element;
    return result;
  }
  method empty(object-t self) -> object-t {
    self.iterator-state++;
    self.sa.count = 0; // hackhack
    return self;
  }
  method in(object-t self, object-t element, object-t default-result) -> object-t {
    object-t result = default-result;
    result-t found-result = sorted-array::search(&self.sa, element);

    if (nullptr != found-result.element)
      result = cast(object-t)sorted-array::at(&self.sa, found-result.offset);
    return result;
  }
  method in(object-t self, object-t element) -> object-t {
    object-t result = $in(self, element, cast(object-t)nullptr);
    if (nullptr == result)
      throw $make(exception::klass(), #msg : "oops");
    return result;
  }
  method in?(object-t self, object-t element) -> boole-t {
    boole-t state? = false;
    if (nullptr != $in(self, element, cast(object-t)nullptr))
      state? = true;
    return state?;
  }
  method empty?(object-t self) -> boole-t {
    boole-t state? = false;
    if (0 == self.sa.count)
      state? = true;
    return state?;
  }
  method remove(object-t self, object-t element) -> object-t {
    result-t found-result = sorted-array::search(&self.sa, element);
    object-t prev-element = nullptr;

    if (nullptr != found-result.element) {
      self.iterator-state++;
      // element not required
      prev-element = cast(object-t)sorted-array::remove-at(&self.sa, element, found-result.offset);
    }
    return prev-element; // returns nullptr on error
  }
  method remove-last(object-t self) -> object-t {
    object-t prev-element = nullptr;
    if (0 != self.sa.count) {
      self.iterator-state++;
      prev-element = cast(object-t)sorted-array::remove-last(&self.sa);
    }
    return prev-element; // returns nullptr on error
  }
  method copy-shallow(object-t self) -> object-t {
    object-t kls = klass-of(self);
    object-t copy = $make(kls);
    const slots-t& s1 = unbox(self);
    slots-t& s2 = mutable-unbox(copy);
    s2 = s1;
    s2.sa.elements = cast(ptr-t*)dkt::alloc(s2.sa.size * s2.sa.capacity);
    memcpy(s2.sa.elements, s1.sa.elements, cast(size-t)(s2.sa.size * s2.sa.capacity));
    s2.iterator-state = 0;
    return copy;
  }
  method size(object-t self) -> ssize-t {
    return self.sa.count;
  }
  method forward-iterator(object-t self) -> object-t {
    object-t forward-iterator = $make(sorted-set-forward-iterator::klass(), #sorted-set : self);
    return forward-iterator;
  }
  method dump(object-t self) -> object-t {
    $dump(super);
    fprintf(stderr, "%p:%p { count=%zi, capacity=%zi, elements=[] }\n",
            cast(ptr-t)(self), cast(ptr-t)&unbox(self), self.sa.count, self.sa.capacity);
    for (object-t element in self)
      $dump(element);
    return self;
  }
  method write-slots(object-t self, object-t out) -> object-t {
    $write-slots(super, out);
    $write-slots-start(out, _klass_);

    $write-sequence-start(out, "elements");

    for (object-t element in self)
      $write-element-idref(out, element, cast(str-t)nullptr);
    $write-sequence-end(out);

    $write-slots-end(out);
    return self;
  }
}
klass sorted-set-forward-iterator {
  trait forward-iterator;

  slots {
    object-t sorted-set;
    ssize-t  offset;

    ssize-t  iterator-state;
  }
  method init(object-t self, object-t sorted-set :) -> object-t {
    self = $init(super);
    assert(klass-of(sorted-set) == sorted-set::_klass_ || $instance?(sorted-set, sorted-set::_klass_));
    const sorted-set::slots-t& ss = sorted-set::unbox(sorted-set);
    self.sorted-set = sorted-set;
    self.offset = 0;
    self.iterator-state = ss.iterator-state;
    return self;
  }
  static func check-iterator-state(object-t self) -> void {
    const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);

    if (self.iterator-state != ss.iterator-state) {
      fprintf(stderr, "%zi == %zi\n", self.iterator-state, ss.iterator-state);
      throw $make(exception::klass(), #msg : "oops");
    }
    return;
  }
  method next?(object-t self) -> boole-t {
    check-iterator-state(self);
    const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);
    boole-t state? = false;
    if (self.offset < ss.sa.count)
      state? = true;
    return state?;
  }
  method next(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      element = $element(self);
      self.offset++;
    }
    return element;
  }
  method element(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);
      element = cast(object-t)sorted-array::at(&ss.sa, self.offset);
      assert(nullptr != element);
    }
    return element; // returns nullptr on error
  }
}
