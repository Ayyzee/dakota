// -*- mode: dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

# include <cassert>
# include <cinttypes>
# include <cstdlib>
# include <cstring>

# include "sorted-set-core.hh"

module dakota-core;

klass compare;
klass equals;
klass exception;
klass object-output-stream;
klass result;
klass sorted-set-core;
klass std-compare;

klass sorted-set {
  superklass collection;

  trait set;

  slots {
    sorted-set-core::slots-t* sa;
    ssize-t                   iterator-state;
  }
  // 'elements' is a collection (of objects)
  // 'objects' is a nullptr terminated array (of objects)
  // using compound literals 'objects' can be used as follows:
  // $init(o, #objects: { o1, o2 });

  method init(object-t   self,
              compare-t  compare:          $compare,
              ssize-t    initial-capacity: 64,
              object-t   elements:         nullptr,
              object-t[] objects:          nullptr) -> object-t {
    assert(0 < initial-capacity);
    self = $init(super);
    bool-t is-ptr;
    self.sa = sorted-set-core::create(initial-capacity,
                                      ssizeof(object-t),
                                      cast(std-compare-t)compare,
                                      is-ptr = false);
    self.iterator-state = 0;

    if (elements != nullptr)
      $add-all(self, elements);

    if (objects != nullptr)
      $add-objects(self, objects);
    return self;
  }
  method dealloc(object-t self) -> object-t {
    $empty(self);
    sorted-set-core::destroy(self.sa);
    return $dealloc(super);
  }
  method in(object-t self, object-t element, object-t default-result) -> object-t {
    object-t result = default-result;
    object-t* element-ptr = &element; /// &object-t
    result-t found-result = sorted-set-core::result-at(self.sa, element-ptr);

    if (found-result.element != nullptr)
      result = *(cast(object-t*)sorted-set-core::at(self.sa,
                                                    found-result.offset));
    return result;
  }
  method in(object-t self, object-t element) -> object-t {
    object-t result = $in(self, element, nullptr);
    if (result == nullptr)
      throw $make(exception::klass(), #msg: "oops");
    return result;
  }
  method in?(object-t self, object-t element) -> bool-t {
    bool-t state = false;
    if ($in(self, element, nullptr) != nullptr)
      state = true;
    return state;
  }
  method add(object-t self, object-t element) -> object-t {
    object-t result = element;
    self.iterator-state++;
    object-t* element-ptr = &element; /// &object-t
    result-t found-result = sorted-set-core::result-at(self.sa, element-ptr);

    if (found-result.element == nullptr) {
      element.add-ref();
      sorted-set-core::add-at(self.sa, found-result.offset, element-ptr);
    }
    else
      result = *(cast(object-t*)found-result.element);
    return result;
  }
  method remove(object-t self, object-t element) -> object-t {
    object-t* element-ptr = &element; /// &object-t
    result-t found-result = sorted-set-core::result-at(self.sa, element-ptr);
    object-t prev-element = nullptr;

    if (found-result.element != nullptr) {
      self.iterator-state++;
      prev-element = *(cast(object-t*)sorted-set-core::remove-at(self.sa,
                                                                 found-result.offset));
      prev-element.remove-ref();
    }
    return prev-element; // returns nullptr on error
  }
  method remove-last(object-t self) -> object-t {
    object-t prev-element = nullptr;
    if (self.sa->count != 0) {
      self.iterator-state++;
      prev-element = *(cast(object-t*)sorted-set-core::remove-last(self.sa));
      prev-element.remove-ref();
    }
    return prev-element; // returns nullptr on error
  }
  method empty(object-t self) -> object-t {
    while (self.sa->count != 0) {
      $remove-last(self);
      self.iterator-state++;
    }
    return self;
  }
  method empty?(object-t self) -> bool-t {
    bool-t state = false;
    if (self.sa->count == 0)
      state = true;
    return state;
  }
  method copy-shallow(object-t self) -> object-t {
    object-t kls = klass-of(self);
    object-t copy = $make(kls);
    const slots-t& s1 = unbox(self);
    slots-t& s2 = mutable-unbox(copy);
    s2 = s1;
    s2.sa->elements = cast(ptr-t*)dkt::alloc(s2.sa->size * s2.sa->capacity);
    memcpy(s2.sa->elements, s1.sa->elements, cast(size-t)(s2.sa->size * s2.sa->capacity));
    s2.iterator-state = 0;
    return copy;
  }
  method size(object-t self) -> ssize-t {
    return self.sa->count;
  }
  method forward-iterator(object-t self) -> object-t {
    object-t forward-iterator = $make(sorted-set-forward-iterator::klass(), #sorted-set: self);
    return forward-iterator;
  }
  method dump(object-t self) -> object-t {
    $dump(super);
    fprintf(stderr, "%p { count=%zi, capacity=%zi, elements=[] }\n",
            cast(ptr-t)self, self.sa->count, self.sa->capacity);
    for (object-t element in self)
      $dump(element);
    return self;
  }
  method write-slots(object-t self, object-t out) -> object-t {
    $write-slots(super, out);
    $write-slots-start(out, _klass_);

    $write-sequence-start(out, "elements");

    for (object-t element in self)
      $write-element-idref(out, element, cast(str-t)nullptr);
    $write-sequence-end(out);

    $write-slots-end(out);
    return self;
  }
}
klass sorted-set-forward-iterator {
  trait forward-iterator;

  slots {
    object-t sorted-set;
    ssize-t  offset;

    ssize-t  iterator-state;
  }
  method init(object-t self, object-t sorted-set:) -> object-t {
    self = $init(super);
    assert(klass-of(sorted-set) == sorted-set::_klass_ || $instance?(sorted-set, sorted-set::_klass_));
    const sorted-set::slots-t& ss = sorted-set::unbox(sorted-set);
    self.sorted-set = sorted-set;
    self.offset = 0;
    self.iterator-state = ss.iterator-state;
    return self;
  }
  static func check-iterator-state(object-t self) -> void {
    const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);

    if (self.iterator-state != ss.iterator-state) {
      fprintf(stderr, "%zi == %zi\n", self.iterator-state, ss.iterator-state);
      throw $make(exception::klass(), #msg: "oops");
    }
    return;
  }
  method next?(object-t self) -> bool-t {
    check-iterator-state(self);
    const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);
    bool-t state = false;
    if (self.offset < ss.sa->count)
      state = true;
    return state;
  }
  method next(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      element = $element(self);
      self.offset++;
    }
    return element;
  }
  method element(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      const sorted-set::slots-t& ss = sorted-set::unbox(self.sorted-set);
      element = *(cast(object-t*)sorted-set-core::at(ss.sa, self.offset));
      assert(element != nullptr);
    }
    return element; // returns nullptr on error
  }
}
