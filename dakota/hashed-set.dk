// -*- mode: dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2017 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

# include <cassert>
# include <cinttypes>

//  2^n: prime < 2^n
// ----|--------------------
//  128: 127
//  256: 251
//  512: 509
// 1024: 1021

module dakota;

klass deque;
klass equals;
klass exception;
klass object-output-stream;
klass vector;

klass hashed-set {
  superklass collection;

  trait set;

  slots {
    equals-t equals?;
    ssize-t  num-buckets;
    object-t buckets; // a vector of deques
    ssize-t  size;

    ssize-t  iterator-state;
  }
  // 'elements' is a collection (of objects)
  // 'objects' is a nullptr terminated array (of objects)
  // using compound literals 'objects' can be used as follows:
  // $init(o, #objects: { o1, o2 });

  method init(object-t   self,
              equals-t   equals?: $equals?,
              ssize-t    initial-capacity: 251, // should be prime
              object-t   elements: nullptr,
              object-t[] objects:  nullptr) -> object-t {
    assert(0 < initial-capacity);
    self = $init(super);
    self.equals? = equals?;
    self.num-buckets = initial-capacity;
    self.buckets = $make(vector::klass(), #initial-capacity: self.num-buckets, #fill-element: nullptr);
    self.size = 0;

    self.iterator-state = 0;

    if (elements != nullptr)
      $add-all(self, elements);

    if (objects != nullptr)
      $add-objects(self, objects);
    return self;
  }
  method add(object-t self, object-t element) -> object-t {
    object-t result = element;
    ssize-t index = cast(ssize-t)($hash(element) % cast(hash-t)self.num-buckets);
    object-t deque = $at(self.buckets, index, nullptr);

    if (deque == nullptr) {
      deque = $make(deque::klass());
      self.iterator-state++;
      self.size++; // bugbug - could wrap
      $add-first(deque, element);
      // why use replace-at?  should be add-at
      $replace-at(self.buckets, index, deque);
    } else {
      object-t found-element = nullptr;

      for (object-t e in deque) {
        if (self.equals?(e, element)) { // arg order matters here!!
          result = found-element = e;
          break;
        }
      }
      if (found-element == nullptr) {
        self.iterator-state++;
        self.size++; // bugbug - could wrap
        $add-first(deque, element);
      }
    }
    return result;
  }
  method empty(object-t self) -> object-t {
    if (self.size != 0) {
      self.iterator-state++;
      $empty(self.buckets);
    }
    return self;
  }
  method at(object-t self, object-t element, object-t default-result) -> object-t {
    object-t result = default-result;
    ssize-t index = cast(ssize-t)($hash(element) % cast(hash-t)self.num-buckets);
    object-t deque = $at(self.buckets, index, nullptr);

    if (deque != nullptr) {
      for (object-t e in deque) {
        if (self.equals?(e, element)) { // arg order matters here!!
          result = e;
          break;
        }
      }
    }
    return result;
  }
  method at(object-t self, object-t element) -> object-t {
    object-t result = $at(self, element, nullptr);
    if (result == nullptr)
      throw $make(exception::klass(), #msg: "oops");
    return result;
  }
  method in?(object-t self, object-t element) -> bool-t {
    bool-t state = ($at(self, element, nullptr) != nullptr);
    return state;
  }
  method empty?(object-t self) -> bool-t {
    bool-t state = (self.size == 0);
    return state;
  }
  method remove(object-t self, object-t element) -> object-t {
    object-t prev-element = nullptr;

    ssize-t index = cast(ssize-t)($hash(element) % cast(hash-t)self.num-buckets);
    object-t deque = $at(self.buckets, index, nullptr);

    if (deque != nullptr) {
      for (object-t iterator = $iterator(deque);
           object-t e = $next(iterator); /**/) {
        //printf("element: %s\n", $name(element));
        //printf("e: %s\n", $name(e));

        if (self.equals?(e, element)) { // arg order matters here!!
          //            object-t remove-not-yet-tested;
          // NOT TESTED!!!
          self.iterator-state++;
          prev-element = $remove(iterator); //e
          self.size--;
          break;
        }
      }
    }
    return prev-element; // returns nullptr on error
  }
  [[alias(copy)]] method copy-shallow(object-t self) -> object-t {
    object-t kls = klass-of(self);
    object-t copy = $make(kls);
    const slots-t& s1 = unbox(self);
    slots-t& s2 = mutable-unbox(copy);
    s2 = s1;
    s2.buckets = $copy-shallow(s1.buckets);
    s2.iterator-state = 0;
    return copy;
  }
  method size(object-t self) -> ssize-t {
    return self.size;
  }
  [[alias(iterator)]] method forward-iterator(object-t self) -> object-t {
    object-t iterator = $make(hashed-set-iterator::klass(), #hashed-set: self);
    return iterator;
  }
  method dump(object-t self) -> object-t {
    $dump(super);
    fprintf(stderr, "%p { size=%zi, elements=[] }\n",
            cast(ptr-t)self, self.size);
    for (object-t element in self)
      $dump(element);
    return self;
  }
  method write-slots(object-t self, object-t out) -> object-t {
    $write-slots(super, out);
    $write-slots-start(out, _klass_);

    $write-sequence-start(out, "elements");

    for (object-t element in self)
      $write-element-idref(out, element, cast(str-t)nullptr);
    $write-sequence-end(out);

    $write-slots-end(out);
    return self;
  }
}
klass hashed-set-iterator {
  trait iterator;

  slots {
    object-t hashed-set;
    object-t vector-iter; // set one time per instantiation
    object-t deque-iter;  // set many times per instantiation

    ssize-t  iterator-state;
  }
  static func check-iterator-state(object-t self) -> void {
    const hashed-set::slots-t& hs = hashed-set::unbox(self.hashed-set);

    if (self.iterator-state != hs.iterator-state)
      throw $make(exception::klass(), #msg: "oops");
    return;
  }
  method init(object-t self, object-t hashed-set:) -> object-t {
    self = $init(super);
    assert(hashed-set != null);
    const hashed-set::slots-t& hs = hashed-set::unbox(hashed-set);
    self.hashed-set = hashed-set;
    self.vector-iter = $iterator(hs.buckets);
    self.iterator-state = hs.iterator-state;
    self.deque-iter = nullptr;
    object-t deque = $next(self.vector-iter);
    if (deque != nullptr) {
      assert($size(deque) != 0);
      self.deque-iter = $iterator(deque);
    }
    return self;
  }
  method next?(object-t self) -> bool-t {
    check-iterator-state(self);
    bool-t state = false;
    if (self.deque-iter != nullptr)
      state = $next?(self.deque-iter);
    return state;
  }
  static func next-deque-iterator(object-t vector-iter) -> object-t {
    object-t deque = $next(vector-iter);
    object-t deque-iter = nullptr;
    if (deque != nullptr) {
      assert($size(deque) != 0);
      deque-iter = $iterator(deque);
    }
    return deque-iter;
  }
  method next(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      element = $next(self.deque-iter);
      if (element == nullptr) {
        self.deque-iter = next-deque-iterator(self.vector-iter);
        if (self.deque-iter != nullptr)
          element = $next(self.deque-iter); // may return nullptr
      }
      if (element != nullptr)
        if (self.deque-iter != nullptr)
          unless ($next?(self.deque-iter))
            self.deque-iter = next-deque-iterator(self.vector-iter); // may return nullptr
    }
    return element;
  }
  method element(object-t self) -> object-t {
    check-iterator-state(self);
    object-t element = nullptr;
    if ($next?(self)) {
      element = $element(self.deque-iter);
      assert(element != nullptr);
    }
    return element; // returns nullptr on error
  }
}
