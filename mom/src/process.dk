// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <assert.h>;
include <stdlib.h>;
include <unistd.h>;

#ifndef _GNU-SOURCE
#define _GNU-SOURCE
#endif //_GNU-SOURCE

include <dlfcn.h>;
include <sys/wait.h>;

include "config.h";
include "hacks.h";
include "log.h";
include "sys.h";
include "tags.h";

module dakota-mom;

klass callback;
klass connection;
klass cstring;
klass event-queue;
klass fd;
klass handler;
klass msg-id;
klass cstring;
klass unnamed-pipe;

#define SUPPORT_STDIN_PIPE 1

//noexport const char8-t-t* MOM-DISABLE-STDIN = NULL;
noexport const char8-t* MOM-DISABLE-STDOUT = NULL;
noexport const char8-t* MOM-DISABLE-STDERR = NULL;

static void __attribute__((constructor)) initializer()
{
  // STDIN currently disabled
  MOM-DISABLE-STDOUT = sys:getenv("DE_DISABLE_STDOUT");
  MOM-DISABLE-STDERR = sys:getenv("DE_DISABLE_STDERR");
  return;
}

klass process
{
  slots
  {
    pid-t id;
    object-t connection;
    msg-id-t msg-id;
    object-t event-handler;
    object-t rcv-msg-handler;
    object-t child-pipe-in;
    object-t child-pipe-out;
    object-t child-pipe-err;
  }

  method object-t connection-for(object-t self)
  {
    return self.connection;
  }

  method pid-t id(object-t self)
  {
    return self.id;
  }

    
  export method object-t sigchld-read-event-callback(object-t self,
                                                     object-t sigchld-event)
  {
    MOM-LOG-CALLBACK("pid=%i %s:%s()", self.id, __klass__, __func__);
    int32-t status = event:data(event:unbox(sigchld-event));
    pid-t id = event:ident(event:unbox(sigchld-event));
//         if (WIFEXITED(status))
//         { sys:fprintf(stderr, "sys:exit-status=%i\n", WEXITSTATUS(status)); }
//         else
//         if (WIFSIGNALED(status))
//         { sys:fprintf(stderr, "term-sig=%i\n", WTERMSIG(status)); }
//         else
//         if (WIFSTOPPED(status))
//         { sys:fprintf(stderr, "stop-sig=%i\n", WSTOPSIG(status)); }

        assert(id == self.id);
        int32-t len = 1 + 3 + 3 + 3; // 2^32 = x,xxx,xxx,xxx
        object-t exit-value = make(cstring:klass, len => len + 1);
        cstring:slots-t* exit-value-slots = cstring:unbox(exit-value);
        // bugbug
        sys:snprintf(exit-value-slots->ptr, len + 1, "%i", status);
    
        object-t exit-value-msg = make(msg:klass,
                                       tag => exit-value,
                                       val => exit-value-slots);
        dk:id=(exit-value-msg, self.msg-id);
        dk:invoke(box(self.rcv-msg-handler), exit-value-msg);
    return self;
  }

  method object-t init(object-t self, object-t connection => {}, msg-id-t msg-id => {})
  {
    self = dk:init(super);

    assert(0 != msg-id);
    assert(NULL != connection);
    
    self.id = -1;
    self.connection = connection;
    self.msg-id = msg-id;
    
    self.event-handler = make(handler:klass,
                              object => self,
                              callback => sigchld-read-event-callback);

    self.rcv-msg-handler = make(handler:klass,
                                object => self);
    
#if SUPPORT-STDIN-PIPE
    self.child-pipe-in = make(unnamed-pipe:klass);
#endif
    if (!MOM-DISABLE-STDOUT) {
      self.child-pipe-out = make(unnamed-pipe:klass);
      MOM-LOG-FD("fd=%i #child-pipe-out-read", dk:fd(self.child-pipe-out, unnamed-pipe:k-read));
      MOM-LOG-FD("fd=%i #child-pipe-out-write", dk:fd(self.child-pipe-out, unnamed-pipe:k-write));
    }
    if (!MOM-DISABLE-STDERR) {
      self.child-pipe-err = make(unnamed-pipe:klass);
      MOM-LOG-FD("fd=%i #child-pipe-err-read", dk:fd(self.child-pipe-out, unnamed-pipe:k-read));
      MOM-LOG-FD("fd=%i #child-pipe-err-write", dk:fd(self.child-pipe-out, unnamed-pipe:k-write));
    }
    MOM-LOG-CREATE("%s:%s() = 0x%08x", __klass__, __func__, (uint32-t)self);
    return self;
  }

  method object-t free(object-t self)
  {
    // leakleak
    return NULL;
  }

  method pid-t fork(object-t self)
  {
    self.id = sys:fork();  sc(self.id);
    if (0 < self.id) {
      object-t eq = dk:get-current(event-queue:klass);
      int32-t n = dk:add(eq, event:k-proc, self.id, self.event-handler);  sc(n);
    }
    return self.id;
  }
  
  method int32-t exec(object-t self, char8-t* path, char8-t** args, char8-t** vars)
  {
#if SUPPORT-STDIN-PIPE
    dk:init-read(self.child-pipe-in, STDIN-FILENO);
#endif
    if (!MOM-DISABLE-STDOUT)
      dk:init-write(self.child-pipe-out, STDOUT-FILENO);
    if (!MOM-DISABLE-STDERR)
      dk:init-write(self.child-pipe-err, STDERR-FILENO);
    MOM-LOG-EXEC-CONTEXT("path=%s, args[0]=%s, args[1]=%s, vars[0]=%s",
                        path, args[0], args[1], vars[0]);
    int32-t n = sys:execve(path, args, vars);
    MOM-LOG-EXEC-CONTEXT("%s[%i]: %s(\"%s\", 0x%08x, 0x%08x): \"%s\"",
                        sys:getprogname(), sys:getpid(), "sys:execve", path, (uint32-t)args, (uint32-t)vars, sys:strerror(errno));
    return n;
  }

#if SUPPORT-STDIN-PIPE
  export object-t child-pipe-in-read-event-callback(object-t child-pipe,
                                                    object-t read-event)
  {
    MOM-LOG-CALLBACK("fd=%i %s:%s()", dk:fd(child-pipe, unnamed-pipe:k-write), __klass__, __func__);
    dk:write-event-callback(child-pipe, read-event);
    cstring-t child-pipe-buf = dk:buf(child-pipe);
//     object-t write-event-handler = dk:write-event-handler(child-pipe); // ???
    if (0) {
    }
    return child-pipe;
  }
#endif

  export object-t child-pipe-out-write-event-callback(object-t child-pipe,
                                                      object-t write-event)
  {
    MOM-LOG-CALLBACK("fd=%i %s:%s()", dk:fd(child-pipe, unnamed-pipe:k-read), __klass__, __func__);
    dk:read-event-callback(child-pipe, write-event);
    cstring-t child-pipe-buf = dk:buf(child-pipe);
    object-t read-event-handler = dk:read-event-handler(child-pipe); // ???
    if (0 != child-pipe-buf.len) {
      object-t process = dk:udata(read-event-handler);
      slots-t* process-slots = unbox(process);
      object-t msg = make(msg:klass,
                          tag => child-stdout,
                          val => child-pipe-buf);
//       child-pipe-buf.len = 0; child-pipe-buf.ptr[0] = (char8-t)0;
      dk:id=(msg, process-slots->msg-id);
      dk:snd-msg(process-slots->connection, msg);
    }
    return child-pipe;
  }

  export object-t child-pipe-err-write-event-callback(object-t child-pipe,
                                                      object-t write-event)
  {
    MOM-LOG-CALLBACK("fd=%i %s:%s()", dk:fd(child-pipe, unnamed-pipe:k-read), __klass__, __func__);
    dk:read-event-callback(child-pipe, write-event);
    cstring-t child-pipe-buf = dk:buf(child-pipe);
    object-t read-event-handler = dk:read-event-handler(child-pipe); // ???
    if (0 != child-pipe-buf.len) {
      object-t process = dk:udata(read-event-handler);
      slots-t* process-slots = unbox(process);
      object-t msg = make(msg:klass,
                          tag => child-stderr,
                          val => child-pipe-buf);
//       child-pipe-buf.len = 0; child-pipe-buf.ptr[0] = (char8-t)0;
      dk:id=(msg, process-slots->msg-id);
      dk:snd-msg(process-slots->connection, msg);
    }
    return child-pipe;
  }

  method callback-t rcv-msg-callback=(object-t self, callback-t rcv-msg-callback)
  {
    dk:callback=(self.rcv-msg-handler, rcv-msg-callback); // bugbug: same as below
//     assert(self == self.rcv-msg-handler.self);

#if SUPPORT-STDIN-PIPE
    dk:write-event-setup(self.child-pipe-in, child-pipe-in-read-event-callback, self);
#endif
    if (!MOM-DISABLE-STDOUT)
      dk:read-event-setup(self.child-pipe-out, child-pipe-out-write-event-callback, self);
    if (!MOM-DISABLE-STDERR)
      dk:read-event-setup(self.child-pipe-err, child-pipe-err-write-event-callback, self);
  
    dk:callback=(self.event-handler, sigchld-read-event-callback);
    dk:object=(self.event-handler, self);

    dk:callback=(self.rcv-msg-handler, rcv-msg-callback); // bugbug: same as above
    dk:object=(self.rcv-msg-handler, self);
    return rcv-msg-callback;
  }

  method object-t log(object-t self, callback-t msg-callback, object-t msg)
  {
    assert(NULL != msg-callback);
    assert(NULL != msg);
    __unused const char8-t* sname = "<unknown>";
#if USE-DLADDR
    Dl-info dli = {0};  int-t n = dladdr((const void*)msg-callback, &dli);
    if (0 != n && dli.dli-saddr == msg-callback)
      sname = dli.dli-sname;
    else
      MOM-LOG-WARNING-DL();
#endif
    char8-t buf[4 + 4 + 8 + 4 + (1)] = ""; //01234567890123456789 : 20 + (1)
    dk:statestr(msg, buf, sizeof(buf));
    MOM-LOG-INVOKE("%s (self=%p, msg='%s')", sname, self, buf);
    return self;
  }

  method object-t invoke(object-t self, callback-t msg-callback, object-t msg)
  {
    dk:log(self, msg-callback, msg);
    object-t msg-handler = make(handler:klass,
                                object=> self,
                                callback => msg-callback);
    dk:invoke(msg-handler, msg);
    return self;
  }
}
