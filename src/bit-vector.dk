// -*- mode: C++; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007, 2008, 2009 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cassert>;
include <cstring>;

noexport uint32-t
min(uint32-t a, uint32-t b)
{
  uint32-t r = a < b ? a : b;
  return r;
}

noexport uint32-t
max(uint32-t a, uint32-t b)
{
  uint32-t r = a > b ? a : b;
  return r;
}

noexport uint32-t
host-to-little-32(uint32-t arg)
{
#if 0
  return arg;
#endif
  uint32-t result = 
    ((arg << 24) & 0xff000000) |
    ((arg <<  8) & 0x00ff0000) |
    ((arg >>  8) & 0x0000ff00) |
    ((arg >> 24) & 0x000000ff);
  return result;
}

noexport uint32-t
reverse-32(uint32-t arg)
{
#if 0
  return arg;
#endif
  uint32-t result = 0;
  for(uint32-t i = 0; i < (sizeof(arg) * 8); i++)
  {
    uint32-t bit = arg & (1 << i);
    if (bit)
    {
      uint32-t mask = 1 << (((sizeof(arg) * 8) - 1) - i);
      result |= mask;
    }
  }
  return result;
}

noexport uint32-t
ceiling-divide(uint32-t numerator, uint32-t denominator)
{
  uint32-t result = (numerator + denominator - 1) / denominator;
  return result;
}

module dakota;

klass bit-vector
{
  slots
  {
    uint32-t* elements;
    uint32-t  count; // number of elements
    uint32-t  capacity; // number of bits
  //uint32-t  size; // 1 bit
  }
  
  static const uint32-t gbl-element-width = cast(uint32-t)(sizeof((cast(slots-t*)0)->elements[0]) * 8);
  static const uint32-t gbl-resize-factor = 2; // hackhack - should be a consumer settable fraction
  static const uint32-t gbl-default-initial-capacity = 6 * gbl-element-width; // shall never be 0

  method object-t init(object-t self, uint32-t initial-capacity => gbl-default-initial-capacity)
  {
    self = dk:init(super);
    if (0 == initial-capacity)
      initial-capacity = gbl-default-initial-capacity;
    self.count = 0;
    uint32-t num-elements = ceiling-divide(initial-capacity, gbl-element-width);
    self.capacity = num-elements * gbl-element-width;
    self.elements = cast(uint32-t*)(malloc(sizeof(self.elements[0]) * num-elements));
    memset(self.elements, 0, sizeof(self.elements[0]) * num-elements);
    return self;
  }

  method object-t dealloc(object-t self)
  {
    free(self.elements);
    object-t result = dk:dealloc(super);
    return result;
  }

  method object-t copy-shallow(object-t self)
  {
    object-t kls = dk:klass(self);
    object-t copy = make(kls);
    slots-t* s1 = unbox(self);
    slots-t* s2 = unbox(copy);
    *s2 = *s1;
    uint32-t num-elements = ceiling-divide(self.capacity, cast(uint32-t)sizeof(self.elements[0]));
    s2->elements = cast(uint32-t*)(malloc(sizeof(self.elements[0]) * num-elements));
    memcpy(s2->elements, self.elements, sizeof(self.elements[0]) * num-elements);
    return copy;
  }

  method boole-t bit(object-t self, uint32-t index)
  {
    uint32-t offset = index/gbl-element-width;
    uint32-t mask = 1 << (index % gbl-element-width);
    if (self.count < (offset + 1))
      self.count = (offset + 1);

    boole-t result = (self.elements[offset] & mask);
    return result;
  }

  method object-t set-bit(object-t self, uint32-t index, boole-t value)
  {
    uint32-t offset = index/gbl-element-width;
    uint32-t mask = 1 << (index % gbl-element-width);
    if (self.count < (offset + 1))
      self.count = (offset + 1);

    if (false == value)
      self.elements[offset] &= ~mask; // set bit to zero
    else
      self.elements[offset] |= mask;  // set bit to one
    return self;
  }

//   method object-t clr-bit(object-t self, uint32-t index)
//   {
//     return set-bit(self, index, false);
//   }

//   method object-t set-bit(object-t self, uint32-t index)
//   {
//     return set-bit(self, index, true);
//   }

  method object-t dump(object-t self)
  {
    dk:dump(super);
    file-t out = stderr;
    fprintf(out, "%p:%p { count=%i, capacity=%i, elements=\"",
            cast(void*)(self), cast(void*)(unbox(self)), self.count, self.capacity);
    for (uint32-t i = 0; i < self.count * gbl-element-width; i++)
    {
      if (0 != i && 0 == (i % 8))
        fprintf(out, " ");

      boole-t value = bit(self, i);

      if (false == value)
        fprintf(out, "0");
      else
        fprintf(out, "1");
    }
    fprintf(out, "\" }\n");
    return self;
  }

  noexport uint32-t op-bit-and(uint32-t i1, uint32-t i2)
  {
    return i1 & i2;
  }

  noexport uint32-t op-bit-or(uint32-t i1, uint32-t i2)
  {
    return i1 | i2;
  }

  noexport uint32-t op-bit-xor(uint32-t i1, uint32-t i2)
  {
    return i1 ^ i2;
  }

  method object-t bit-not(object-t self)
  {
    slots-t* self-slots =  unbox(self);
    for (uint32-t offset = 0; offset < self-slots->count; offset++)
      self-slots->elements[offset] = ~self-slots->elements[offset];
    return self;
  }

//   noexport void op-common(object-t self, object-t other, uint32-t (*op)(uint32-t, uint32-t))
//   {
//     slots-t* self-slots =  unbox(self);
//     slots-t* other-slots = unbox(other);
//     assert(self-slots->capacity == other-slots->capacity);
//     self-slots->count = max(self-slots->count, other-slots->count);
//     for (uint32-t offset = 0; offset < self-slots->count; offset++)
//       self-slots->elements[offset] = op(self-slots->elements[offset], other-slots->elements[offset]);
//     return;
//   }

  noexport boole-t op-common?(object-t self, object-t other, uint32-t (*op)(uint32-t, uint32-t))
  {
    boole-t result = false;
    slots-t* self-slots =  unbox(self);
    slots-t* other-slots = unbox(other);
    assert(self-slots->capacity == other-slots->capacity);
    self-slots->count = max(self-slots->count, other-slots->count);
    for (uint32-t offset = 0; offset < self-slots->count; offset++)
    {
      if (0 != (self-slots->elements[offset] = op(self-slots->elements[offset], other-slots->elements[offset])))
      {
        result = true;
        break;
      }
    }
    return result;
  }

//   method object-t bit-and(object-t self, object-t other)
//   {
//     op-common(self, other, op-bit-and);
//     return self;
//   }

//   method object-t bit-or(object-t self, object-t other)
//   {
//     op-common(self, other, op-bit-or);
//     return self;
//   }

//   method object-t bit-xor(object-t self, object-t other)
//   {
//     op-common(self, other, op-bit-xor);
//     return self;
//   }

  method boole-t bit-and?(object-t self, object-t other)
  {
    boole-t result = op-common?(self, other, op-bit-and);
    return result;
  }

  method boole-t bit-or?(object-t self, object-t other)
  {
    boole-t result = op-common?(self, other, op-bit-or);
    return result;
  }

  method boole-t bit-xor?(object-t self, object-t other)
  {
    boole-t result = op-common?(self, other, op-bit-xor);
    return result;
  }

  method int-t compare(object-t self, object-t other)
  {
    //printf("%s('%s', '%s')\n", __method__, dkt-name(dkt-klass(self)), dkt-name(dkt-klass(other)));
    int-t result = 0;

    if (dk:instance?(other, klass))
    {
      slots-t* self-slots =  unbox(self);
      slots-t* other-slots = unbox(other);
      assert(self-slots->capacity == other-slots->capacity);
      self-slots->count = max(self-slots->count, other-slots->count);
      for (uint32-t offset = 0; offset < self-slots->count; offset++)
      {
        uint32-t i = self-slots->count - 1 - offset;
        if (self-slots->elements[i] > other-slots->elements[i])
        {
          result = +1;
          break;
        }
        else-if (self-slots->elements[i] < other-slots->elements[i])
        {
          result = -1;
          break;
        }
      }
    }
    else
    {
      result = dk:compare(super, other);
    }
    result = normalize-compare-result(result);
    return result;
  }
}
