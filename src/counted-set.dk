// -*- mode: C++; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007, 2008, 2009 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module dakota;

trait counted-set
{
  //provides dk:set;
  require collection;

  method object-t at(object-t self, object-t key, object-t default-result)
  {
    object-t result = default-result;
    object-t assoc = dk:assoc-at(self, key, nullptr);

    if (nullptr != assoc)
    {
      assoc-t* assoc-content = assoc:unbox(assoc);
      result = assoc-content->element;
    }
    return result;
  }

  noexport object-t add(object-t self, object-t element)
  {
    object-t assoc = dk:assoc-at(self, element, nullptr);

    if (nullptr != assoc)
    {
      assoc-t* assoc-content = assoc:unbox(assoc);
      object-t count = assoc-content->element;
      uint32-t* count-content = uint32:unbox(count);
      (*count-content)++;
    }
    else
    {
      object-t count = uint32:box(1);
      object-t assoc1 = assoc:box({element, count});
      dk:add-assoc(self, assoc1);
    }
    return element;
  }

  method object-t elements(object-t self)
  {
    object-t result = make(vector:klass, size => dk:size(self));
    for (assoc-t* assoc in self)
      dk:add-last(result, assoc->key);
    return result;
  }

  method object-t counts(object-t self)
  {
    object-t result = make(vector:klass, size => dk:size(self));
    for (assoc-t* assoc in self)
      dk:add-last(result, assoc->element);
    return result;
  }

  method uint32-t count-at(object-t self, object-t element, uint32-t default-count)
  {
    uint32-t count-content = default-count;
    object-t assoc = dk:assoc-at(self, element, nullptr);

    if (nullptr != assoc)
    {
      assoc-t* assoc-content = assoc:unbox(assoc);
      object-t count = assoc-content->element;
      count-content = *uint32:unbox(count);
    }
    return count-content;
  }

  object-t initialize(object-t kls)
  {
    typedef object-t (*)(object-t, object-t, object-t) at-t;
    dk:add-method-for-selector(kls,
                               selector(assoc-at(object-t, object-t, object-t)),
                               dk:method-for-selector(kls, selector(at(object-t, object-t, object-t))));
    dk:add-method-for-selector(kls,
                               selector(at(object-t, object-t, object-t)),
                               cast(method-t)cast(at-t)(at));

    typedef object-t (*)(object-t, object-t) add-t;
    dk:add-method-for-selector(kls,
                               selector(add-assoc(object-t, object-t)),
                               dk:method-for-selector(kls, selector(add(object-t, object-t))));
    dk:add-method-for-selector(kls,
                               selector(add(object-t, object-t)),
                               cast(method-t)cast(add-t)(add));
    return kls;
  }

  object-t finalize(object-t kls)
  {
    return kls;
  }

  method /*alias(at)*/ object-t assoc-at(object-t self, object-t key, object-t default-assoc);
  method /*alias(add)*/ object-t add-assoc(object-t self, object-t assoc);
}
