// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cassert>;
include <cerrno>;
include <cinttypes>;
include <cstdio>;
include <cstring>;
include <exception>;
include <sys/stat.h>; // struct stat, stat()

#if HAVE-CONFIG-HH
  #include "config.hh"
#endif

#include "dakota-log.hh"
#include "dakota-private.hh"
#include "dakota-rt-private.hh"
#include "dl.hh" // load-library()
#include "sorted-array.hh"
#include "sorted-ptr-array.hh"

#if !defined SO-EXT
#define SO-EXT "so"
#endif

module dakota;

klass const-info;
klass construct;
klass enum-info;
klass named-enum-info;
klass named-info;
klass property;
klass resource-usage;
klass result;
klass selector-node;
klass singleton-klass;
klass sorted-array;
klass sorted-ptr-array;
klass std-compare;
klass str128;
klass super;
klass symbol;

#if DKT-WORKAROUND
namespace property
{
  noexport int-t compare(slots-t**, slots-t**);
}
namespace named-info
{
  noexport int-t compare(slots-t**, slots-t**);
}
namespace klass
{
  noexport object-t init(object-t, named-info-t*);
  noexport boole-t subklass?(object-t, object-t);
}
#endif

static const char8-t gbl-delimiter = '/'; // unix path delimiter
static str-t gbl-current-module = "";

klass assoc-node
{
  slots
  {
    uintptr-t element;
    slots-t*  next;
  }
}

klass named-assoc-node
{
  slots
  {
    symbol-t name;
    assoc-node-t* node;
  }
  method int-t compare(slots-t* s, slots-t* other-s)
  {
    assert(nullptr != s);
    assert(nullptr != other-s);
    //printf("%s(): %s ?= %s\n", __func__, s, other-s);
    int-t result = symbol::compare(cast(symbol-t)(s->name), cast(symbol-t)(other-s->name)); // hackhack
    result = dkt-normalize-compare-result(result);
    return result;
  }

//   noexport slots-t* dump(slots-t* s)
//   {
//     printf("\"%s\"\n", s->name);
//     assoc-node-t* node = s->node;
//     while (nullptr != node)
//     {
//       printf("  element=%p, next=%p\n", node->element, node->next);
//       node = node->next;
//     }
//     return s;
//   }
}

static sorted-array-t* gbl-imported-klasses-table;
static sorted-array-t* gbl-klass-defns-table;
static sorted-array-t* gbl-interposers-table;
static sorted-array-t* gbl-imported-klasses-file-table;

static void
init-runtime-ds()
{
  const uint32-t num-klasses = 256;

  gbl-imported-klasses-table =
    sorted-array::create(num-klasses,
                        cast(uint32-t)sizeof(named-assoc-node::slots-t),
                        cast(std-compare-t)cast(int-t(*)(named-assoc-node::slots-t*,named-assoc-node::slots-t*))named-assoc-node::compare);
  gbl-klass-defns-table =
    sorted-array::create(num-klasses,
                        cast(uint32-t)sizeof(named-info::slots-t*),
                        cast(std-compare-t)cast(int-t(*)(named-info::slots-t**,named-info::slots-t**))named-info::compare);
  gbl-interposers-table =
    sorted-array::create(num-klasses,
                        cast(uint32-t)sizeof(property::slots-t),
                        cast(std-compare-t)cast(int-t(*)(property::slots-t*,property::slots-t*))property::compare);
  gbl-imported-klasses-file-table =
    sorted-array::create(num-klasses,
                        cast(uint32-t)sizeof(symbol-t),
                        cast(std-compare-t)cast(int-t(*)(symbol::slots-t*,symbol::slots-t*))symbol::compare);
  return;
}

#if defined DKT-DUMP-MEM-FOOTPRINT
extern noexport resource-usage::slots-t gbl-ru;
#endif

typedef int32-t (*)(void*, void*) vcompare-t;

export object-t null = nullptr;
static object-t null-klass = nullptr;
export object-t std-input = nullptr;
export object-t std-output = nullptr;
export object-t std-error = nullptr;

// this is quick and dirty!!!!!!!!!!!!!!!!
static void
init-imported-klasses()
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':[]", __func__);
  symbol-t* imported-klass-name-ptr;
  while (nullptr != (imported-klass-name-ptr = (symbol-t*)sorted-array::remove-last(gbl-imported-klasses-file-table)))
    dk-klass-for-name(*imported-klass-name-ptr);
  return;
}

static str-t
file-name-from-klass-name(symbol-t klass-name)
{
  char8-t* file-name = cast(char8-t*)dkt::alloc(sizeof(char8-t) * (symbol::length(klass-name) + 1));
  file-name[0] = NUL;
  uint32-t kn = 0;
  uint32-t fn = 0;

  while (':' == klass-name[kn])
    kn++;
  while (NUL != klass-name[kn]) {
    if (':' == klass-name[kn]) {
      do {
        kn++;
      } while (':' == klass-name[kn]);

      if (NUL != klass-name[kn]) {
        file-name[fn] = gbl-delimiter;
        fn++;
      }
    } else {
      file-name[fn] = klass-name[kn];
      kn++;
      fn++;
    }
  }
  file-name[fn] = NUL;
  return file-name;
}
static str-t
find-file(str-t path, str-t file-name, str-t suffix)
{
  char8-t* file = cast(char8-t*)dkt::alloc(sizeof(char8-t) * (FILENAME-MAX + 1));
  file[0] = NUL;
  uint32-t j1 = 0;
  uint32-t j2 = 0;
  str-t rtn = nullptr;

  while (j1 <= safe-strlen(path)) {
    if (NUL == path[j1] || ':' == path[j1]) {
      if (0 != j2 && gbl-delimiter != file[j2 - 1]) {
        file[j2] = gbl-delimiter;
        j2++;
      }
      file[j2] = NUL;
      strcat(file, file-name);
      strcat(file, ".");
      strcat(file, suffix);
      struct stat status;
      int-t err = stat(file, &status);

      if (0 == err) {
        if (0 == S-ISREG(status.st-mode)) { // NOT a regular file
          fprintf(stderr, "%s:%i: ERROR: %s: not a regular file.\n", __FILE__, __LINE__, file);
        }
        else-if (0 == (S-IRUSR & status.st-mode)) { // user DOES NOT have read permission
          fprintf(stderr, "%s:%i: ERROR: %s: user does not have read permission.\n", __FILE__, __LINE__, file);
        } else {
          //fprintf(stdout, "%s: IS a regular file AND user DOES have read permission\n", file);
          rtn = file;
          break;
        }
      } else {
        str128-t buf = "";
        strerror-r(errno, buf, sizeof(buf));
        fprintf(stderr, "%s:%i: INFO: %s: %s\n", __FILE__, __LINE__, file, buf);
        throw "bummer";
      }
      j1++;
      j2 = 0;
    } else {
      file[j2] = path[j1];
      j1++;
      j2++;
    }
  }
  return rtn;
}

noexport symbol-t
default-klass-name()
{
  return $klass;
}
static object-t
default-klass()
{
  return klass::klass;
}

static object-t
alloc-klass(symbol-t name)
{
  named-info-t* info = info-for-name(name);
  symbol-t klass-name = klass-name-from-info(info);
  if (nullptr == klass-name)
    klass-name = default-klass-name();
  named-info-t* klass-info = info-for-name(klass-name);
  
  uint32-t offset = offset-from-info(klass-info);
  uint32-t size =   size-from-info(klass-info);
  //fprintf(stderr, "%s($%s):\toffset=%i + size=%i\n", __func__, name, offset, size);

#if defined DKT-DUMP-MEM-FOOTPRINT
  resource-usage::add-alloc(&gbl-ru, offset + size);
  resource-usage::log-alloc(&gbl-ru, offset + size, name);
#endif

  object-t kls = cast(object-t)dkt::alloc(offset + size);
  if (nullptr != klass::klass)
    kls->klass = klass::klass;
  else
    kls->klass = kls; // klass klass's klass is klass klass
  kls->retain-count = 1;
  return kls;
}

static object-t
init-klass(object-t kls, symbol-t name)
{
    named-info-t* info = info-for-name(name);
    kls = klass::init(kls, info);
    return kls;
}

noexport void import-klass(symbol-t name, assoc-node-t* klass-assoc);

noexport void pre-runtime-verbose-terminate();
noexport void verbose-terminate();

noexport void pre-runtime-verbose-unexpected();
noexport void verbose-unexpected();

klass ofile
{
  slots
  {
    file-t   output;
    uint32-t col;
  }

  static slots-t
  pad(slots-t s)
  {
    for (uint32-t i = 0; i < s.col; i++)
      fprintf(s.output, "  "); // two spaces per column :-) [my way]
    return s;
  }

  static slots-t
  format-va-printf(2)
  va-printf(slots-t s, str-t format, va-list-t args)
  {
    pad(s);
    vfprintf(s.output, format, args);
    return s;
  }

  static slots-t
  format-printf(2)
  printf(slots-t s, str-t format, ...)
  {
    va-list-t args;
    va-start(args, format);
    va-printf(s, format, args);
    va-end(args);
    return s;
  }

  static slots-t
  fopen(str-t path)
  {
    slots-t s = { nullptr, 0 };
    s.output = ::fopen(path, "w");
    if (nullptr == s.output)
      abort();
    return s;
  }

  static slots-t
  fclose(slots-t s)
  {
    int n = ::fclose(s.output);
    if (-1 == n)
      abort();
    return s;
  }
}

#if 1
extern noexport sorted-array-t gbl-selectors-table;
static void
perl-dump-resource-info(sorted-array-t* klass-defns-table)
{
  uint32-t klasses-count = 0;
  uint32-t methods-count = 0;
  for (uint32-t i = 0; i < klass-defns-table->count; i++) {
    named-info-t* klass-info = *cast(named-info-t**)sorted-array::at(klass-defns-table, i);
    named-info-t* current-info = klass-info;

    do {
      symbol-t construct = cast(symbol-t)named-info::at(current-info, $construct);
      if (0 == symbol::compare($klass, construct))
        klasses-count++;
      signature-t const* const* method-signatures = cast(signature-t const* const*)named-info::at(current-info, $method-signatures);

      if (nullptr != method-signatures) {
        method-t const* method-addresses = cast(method-t const*)named-info::at(current-info, $method-addresses);
        uint32-t j = 0;
        signature-t const* method-signature;
        while (nullptr != (method-signature = method-signatures[j])) {
          method-t method-address = method-addresses[j];
          if (nullptr != method-address && cast(method-t)dkt-null-method != method-address)
            methods-count++;
          j++;
        }
      }
    } while (nullptr != (current-info = current-info->next));
  }
  ofile-t ofl = {stdout, 0};
  ofile::printf(ofl, "{ 'klasses' : '%i', 'selectors' : '%u' 'methods' : '%i' },\n",
         klasses-count, gbl-selectors-table.count, methods-count);
  return;
}
#endif

static void
perl-dump-klass-defns(sorted-array-t* klass-defns-table)
{
  ofile-t ofl = { stdout, 0 };
  ofile::printf(ofl, "{\n");
  ofl.col++;

  for (uint32-t i = 0; i < klass-defns-table->count; i++) {
    named-info-t* klass-info = *cast(named-info-t**)sorted-array::at(klass-defns-table, i);
    named-info-t* current-info = klass-info;

    do {
      symbol-t name =            name-from-info(current-info);
      symbol-t klass-name =      klass-name-from-info(current-info);
      symbol-t superklass-name = superklass-name-from-info(current-info);
      ofile::printf(ofl, "'%s' :\n", name);
      ofile::printf(ofl, "{\n");
      ofl.col++;
      symbol-t construct = cast(symbol-t)named-info::at(current-info, $construct);
      ofile::printf(ofl, "'construct' : '%s',\n", construct);
      if (nullptr != klass-name)
        ofile::printf(ofl, "'klass' : '%s',\n",      klass-name);
      if (nullptr != superklass-name)
        ofile::printf(ofl, "'superklass' : '%s',\n", superklass-name);
      
      signature-t const* const* method-signatures = cast(signature-t const* const*)named-info::at(current-info, $method-signatures);
      if (nullptr != method-signatures) {
        ofile::printf(ofl, "'methods' :\n");
        ofile::printf(ofl, "{\n");
        ofl.col++;
        method-t const* method-addresses = cast(method-t const*)named-info::at(current-info, $method-addresses);
        uint32-t j = 0;
        signature-t const* method-signature;
        
        while (nullptr != (method-signature = method-signatures[j])) {
          method-t method-address = method-addresses[j];
          uint32-t defined;
          if (nullptr == method-address)
            defined = 0;
          else
            defined = 1;
          ofile::printf(ofl, "'%s(%s)' : { 'return-type' : '%s', 'name' : '%s', 'parameter-types' : '%s', 'defined?' : '%i' },\n",
                       method-signature->name, method-signature->parameter-types,
                       method-signature->return-type,
                       method-signature->name,
                       method-signature->parameter-types,
                       defined);
          j++;
        }
        ofl.col--;
        ofile::printf(ofl, "},\n");
      }
      ofl.col--;
      ofile::printf(ofl, "},\n");
    } while (nullptr != (current-info = current-info->next));
  }
  ofl.col--;
  ofile::printf(ofl, "},\n");
  return;
}
static named-info-t* gbl-registration-info-list;

noexport void register-info-common(named-info-t* registration-info);
noexport void export-klass(named-info-t* klass-info);

// export object-t
// dk-make-simple-singleton(symbol-t name, symbol-t superklass-name)
// {
//   object-t kls = dk-make-simple-klass(name, superklass-name, $singleton-klass);
//   object-t singleton = make(kls);
//   return singleton;
// }

export object-t
dk-make-simple-klass(symbol-t name, symbol-t superklass-name, symbol-t klass-name)
{
  assert(name != nullptr);
  uint32-t num-klass-props = 1;
  if (superklass-name != nullptr)
    num-klass-props++;
  if (klass-name != nullptr)
    num-klass-props++;

  property-t*        klass-props = cast(property-t*)       dkt::alloc(sizeof(property-t) * num-klass-props);
  named-info-t* klass-info =  cast(named-info-t*)dkt::alloc(sizeof(named-info-t));

  // need to be sorted
  uint_t i = 0;
  if (klass-name != nullptr)
    klass-props[i++] = { $klass-name,      cast(uintptr-t)klass-name      };

  klass-props[i++] =   { $name,            cast(uintptr-t)name            };

  if (superklass-name != nullptr)
    klass-props[i++] = { $superklass-name, cast(uintptr-t)superklass-name };

  *klass-info = { klass-props, num-klass-props, nullptr };
  export-klass(klass-info);

  object-t klass = dk-klass-for-name(name);
  return klass;
}

// object klass' superklass is null instance (singleton)
// klass klass'  superklass is object klass
// null klass'   superklass is object klass
//
// object klass' klass is klass klass
// klass klass'  klass is klass klass
// null klass'   klass is klass klass
export void
dk-init-runtime()
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':[]", __func__);
  if (nullptr == object::klass) {
    init-runtime-ds();

    named-info-t* registration-info;
    while (nullptr != (registration-info = gbl-registration-info-list)) {
      gbl-registration-info-list = gbl-registration-info-list->next;
      registration-info->next = nullptr;
      register-info-common(registration-info);
    }
    assert(nullptr == gbl-registration-info-list);

    // alloc
    klass::klass =  alloc-klass($klass); // must be first
    object::klass = alloc-klass($object);

    // init()
    object::klass = init-klass(object::klass, $object); // must be first
    klass::klass =  init-klass(klass::klass,  $klass);

    klass::unbox(object::klass)->superklass = nullptr;
#if 1
    dk-klass-for-name($singleton-klass);
    null-klass = dk-make-simple-klass($null, $object, $singleton-klass);
    null = make(null-klass);
    klass::unbox(object::klass)->superklass = null;
#endif
    assert(klass::klass == dkt-klass(klass::klass));

    // core runtime klasses are setup
    // klasses: object, klass, (optionally) singleton-klass
    // and (optionally) null-klass and null singleton

#if !defined DKT-OMIT-BEHAVIOR
    dk-klass-for-name($bit-vector);

    object-t behavior;
    behavior = dk::behavior(object::klass);
    behavior = dk::behavior(klass::klass);
    behavior = dk::behavior(bit-vector::klass);

    if (null-klass)
      behavior = dk::behavior(null-klass);
#else
    klass::unbox(object::klass)->behavior =     nullptr;
    klass::unbox(klass::klass)->behavior =      nullptr;
    klass::unbox(bit-vector::klass)->behavior = nullptr;
    if (null-klass)
      klass::unbox(null-klass)->behavior =     nullptr;
#endif
#if 1
    dk-klass-for-name($input-stream);
    dk-klass-for-name($output-stream);

    std-input =  make(input-stream::klass,  $file : stdin);
    std-output = make(output-stream::klass, $file : stdout);
    std-error =  make(output-stream::klass, $file : stderr);
#endif

    previous-terminate = std::set-terminate(verbose-terminate);
    assert(previous-terminate == pre-runtime-verbose-terminate);

    previous-unexpected = std::set-unexpected(verbose-unexpected);
    assert(previous-unexpected == pre-runtime-verbose-unexpected);

#if 0
    dk::dump(object::klass);
    dk::dump(klass::klass);
    if (null) {
      dk::dump(null-klass);
      dk::dump(null);
    }
#endif
  }
  init-imported-klasses();

  return;
}
noexport assoc-node-t*
imported-klasses-for-klass(symbol-t klass-name)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%s']", __func__, klass-name);
  named-assoc-node-t named-node = { klass-name, nullptr };
  named-assoc-node-t* found-named-node = cast(named-assoc-node-t*)sorted-array::bsearch(gbl-imported-klasses-table, &named-node); // hackhack
  assoc-node-t* result;

  if (nullptr == found-named-node)
    result = nullptr;
  else
    result = found-named-node->node;
  return result;
}
noexport void
import-klass(symbol-t klass-name, assoc-node-t* node)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%s','%p']", __func__, klass-name, cast(void*)(node));
  named-assoc-node-t named-node = { klass-name, node };
  named-assoc-node-t* found-named-node = cast(named-assoc-node-t*)sorted-array::bsearch(gbl-imported-klasses-table, &named-node);

  if (nullptr == found-named-node) {
    named-node.node->next = nullptr;
    sorted-array::add(gbl-imported-klasses-table, &named-node);
    sorted-array::add(gbl-imported-klasses-file-table, &klass-name);
  } else {
    node->next = found-named-node->node;
    found-named-node->node = node;

    if (nullptr == found-named-node->node)
      sorted-array::add(gbl-imported-klasses-file-table, &klass-name);
  }
  return;
}
static void
import-klasses(symbol-t* klass-names, assoc-node-t* klass-assoc)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%p','%p']",
                        __func__,
                        cast(void*)(klass-names),
                        cast(void*)(klass-assoc));
  assert((nullptr != klass-names) &&
         (nullptr != klass-assoc));
  uint32-t i = 0;
  while (1) {
    symbol-t name =        klass-names[i];
    assoc-node-t* assoc = &klass-assoc[i];
    i++;
    if (nullptr == name)
      break;
//     fprintf(stderr, "\"%s\": %p\n", name, assoc->element);
    import-klass(name, assoc);
  }
  return;
}
noexport symbol-t
interposer-name-for-klass-name(symbol-t klass-name)
{
  property-t key = { klass-name, cast(uintptr-t)nullptr };
  property-t* assoc-ptr = cast(property-t*)sorted-array::bsearch(gbl-interposers-table, &key);
  symbol-t result;

  if (nullptr == assoc-ptr) {
    result = nullptr;
  } else {
    property-t assoc = *assoc-ptr;
    result = cast(symbol-t)(assoc.element);
  }
//   if (nullptr != result)
//     fprintf(stderr, "%s = %s(%s)\n", result, __func__, klass-name);
  assert(0 != symbol::compare(klass-name, result));
  return result;
}

noexport void
add-interpose-prop(symbol-t key, symbol-t element)
{
//   dkt-log(dkt::k-log-info, "%s(%s, %s)", __func__, key, element);
  property-t prop = { key, cast(uintptr-t)element };
  sorted-array::add(gbl-interposers-table, &prop);
  return;
}

static void
add-interposers(property-t* interposers)
{
//assert(nullptr != interposers);
  uint32-t i = 0;
  while (1) {
    property-t* prop = &interposers[i++];
    if (nullptr == prop->key)
      break;
    add-interpose-prop(prop->key, cast(symbol-t)(prop->element)); // hackhack: api should take property-t*
  }
//   if (nullptr != interposers)
//     fprintf(stderr, "===\n");
  return;
}

noexport void
export-klass(named-info-t* klass-info)
{
  named-info::sort(klass-info);
  symbol-t name = name-from-info(klass-info);
  assert(nullptr != name);
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%p'],'klass-name':'%s'", __func__, cast(void*)(klass-info), name);

  symbol-t interpose-name = cast(symbol-t)named-info::at(klass-info, $interpose-name);
  if (nullptr != interpose-name) {
    symbol-t construct = cast(symbol-t)named-info::at(klass-info, $construct);
    assert(0 == symbol::compare($klass, construct));
    add-interpose-prop(interpose-name, name);
  }

  named-info-t** klass-info-ptr = cast(named-info-t**)sorted-array::bsearch(gbl-klass-defns-table, &klass-info);
  if (nullptr == klass-info-ptr) {
    sorted-array::add(gbl-klass-defns-table, &klass-info);
  } else {
    klass-info->next = *klass-info-ptr;
    *klass-info-ptr = klass-info;
  }
  return;
}
static void
export-klasses(named-info-t* klass-info)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%p']", __func__, cast(void*)(klass-info));
  uint32-t i = 0;

  while (1) {
    named-info-t* var-klass-info = &klass-info[i++];
    if (nullptr == var-klass-info->elements)
      break;
    export-klass(var-klass-info);
  }
  return;
}
static void
dump-interposers(ofile-t ofl, named-info-t* registration-info)
{
  property-t const* interposers = cast(property-t const*)named-info::at(registration-info, $interposers);
  if (nullptr != interposers) {
    for (uint32-t i = 0; nullptr != interposers[i].key; i++)
      ofile::printf(ofl, "interpose %s, %s;\n", interposers[i].key, (symbol-t)interposers[i].element);
  }
  return;
}

static boole-t
should-dump(named-info-t* klass-info, str-t only)
{
  assert(nullptr != klass-info);
  assert(nullptr != only);
  symbol-t name = name-from-info(klass-info);
  assert(nullptr != name);

  boole-t result = true;
  uint32-t only-len = cast(uint32-t)safe-strlen(only);
  if ('-' == only[0]) {
    uint32-t name-len = cast(uint32-t)safe-strlen(name);
    if (name-len < only-len)
      result = false;

    if (0 != safe-strcmp(name + name-len - only-len, only))
      result = false;
  }
  else-if ('-' == only[only-len - 1]) {
    if (0 != safe-strncmp(name, only, only-len))
      result = false;
  } else {
    if (0 != safe-strcmp(name, only))
      result = false;
  }
  return result;
}

noexport void dump-klass(ofile-t ofl, named-info-t* klass-info);

static str-t
remove-dir(str-t path)
{
  str-t result = strrchr(path, '/');
  if (nullptr == result)
    result = path;
  else
    result++;
  assert(NUL != result[0]); // not empty-string
  return result;
}

unused static str-t
remove-ext(str-t path)
{
  char8-t* dot = strrchr(path, '.');
  if (nullptr != dot)
    *dot = NUL;
  assert(NUL != path[0]); // not empty-string
  return path;
}

unused static char8-t*
pad(char8-t* buf, uint32-t buf-len, uint32-t len)
{
  assert(buf-len >= len);
  buf[0] = NUL;
  for (uint32-t i = 0; i < len; i++)
    strcat(buf, " ");
  return buf;
}
static size-t
first-parameter-type-len(str-t params)
{
  size-t i;
  for (i = 0; i < strlen(params); i++) {
    char8-t c = params[i];
    if (c == ',')
      break;
  }
  return i;
} 

static void
dump-module-description(ofile-t ofl, named-info-t* registration-info)
{
  assert(nullptr != ofl.output);
  assert(8 > ofl.col);
  assert(nullptr != registration-info);

  named-info-t* klass-defns = cast(named-info-t*)named-info::at(registration-info, $klass-defns);

  if (nullptr != klass-defns) {
    uint32-t i = 0;
    symbol-t module-name = nullptr;
    str-t c = "";

    while (1) {
      named-info-t* klass-info = &klass-defns[i++];
      assert(nullptr != klass-info);
      if (nullptr == klass-info->elements)
        break;
      // klass-name,
      // klass-name::slots-t,
      // klass-name::method-name(slots-t),
      // klass-name::method-name(object-t), // maybe generated
      // klass-name::va::method-name(slots-t),
      // klass-name::va::method-name(object-t), // maybe generated
      // klass-name::kw-args-method-name(slots-t), ???
      // klass-name::kw-args-method-name(object-t), // maybe generated
      symbol-t name = name-from-info(klass-info);

      str-t                     modulee =                        cast(str-t)                    named-info::at(klass-info, $module);

      //boole-t                   exported? =                      cast(boole-t)                  named-info::at(klass-info, $exported?);
      //boole-t                   state-exported? =                cast(boole-t)                  named-info::at(klass-info, $state-exported?);
      //boole-t                   behavior-exported? =             cast(boole-t)                  named-info::at(klass-info, $behavior-exported?);
      
      //symbol-t                  interpose-name =                 cast(symbol-t)                 named-info::at(klass-info, $interpose-name);

      named-info-t*             slots-info =                     cast(named-info-t*)            named-info::at(klass-info, $slots-info);
      symbol-t                  slots-type =                     cast(symbol-t)                 named-info::at(klass-info, $slots-type);

      signature-t const* const* method-signatures =              cast(signature-t const* const*)named-info::at(klass-info, $method-signatures);
      //signature-t const* const* va-method-signatures =           cast(signature-t const* const*)named-info::at(klass-info, $va-method-signatures);
      //signature-t const* const* slots-method-signatures =        cast(signature-t const* const*)named-info::at(klass-info, $slots-method-signatures);
      //signature-t const* const* va-slots-method-signatures =     cast(signature-t const* const*)named-info::at(klass-info, $va-slots-method-signatures);
      //signature-t const* const* kw-args-method-signatures =      cast(signature-t const* const*)named-info::at(klass-info, $kw-args-method-signatures);

      if (nullptr == modulee)
        abort();
      if (module-name != modulee)
        ofile::printf(ofl, "%s %s %s", "module", modulee, "export");
      module-name = modulee;
      ofile::printf(ofl, "%s\n  %s", c, name);
      c = ",";
      if (nullptr != slots-info || nullptr != slots-type)
        ofile::printf(ofl, ",\n  %s::%s", name, "slots-t");
      if (nullptr != method-signatures) {
        uint32-t index = 0;
        signature-t const* info;

        while (nullptr != (info = method-signatures[index++])) {
          char8-t first-parameter-type[15 + (1)] = "";
          size-t len = first-parameter-type-len(info->parameter-types);
          assert(len < DK-ARRAY-LENGTH(first-parameter-type) - 1);
          strncpy(first-parameter-type, info->parameter-types, len);
          first-parameter-type[len] = cast(char8-t)0;
          //ofile::printf(ofl, ",\n  %s:%s(%s)", name, info->name, first-parameter-type); // this code works just fine
        }
      }
    }
    ofile::printf(ofl, ";\n");
  }
  return;
}

static void
dump-klass-defns(ofile-t ofl, named-info-t* registration-info, str-t only)
{
  assert(nullptr != ofl.output);
  assert(8 > ofl.col);
  assert(nullptr != registration-info);

  str-t output-dir = getenv("DKT_INFO_OUTPUT_DIRECTORY");
  named-info-t* klass-defns = cast(named-info-t*)named-info::at(registration-info, $klass-defns);

  if (nullptr != klass-defns) {
    uint32-t i = 0;
      
    if (NULL != output-dir) {
      int-t n = mkdir(output-dir, 0755);
      if (-1 == n && EEXIST != errno)
        abort();
    }
    while (1) {
      named-info-t* klass-info = &klass-defns[i++];
      assert(nullptr != klass-info);
      if (nullptr == klass-info->elements)
        break;
      if (nullptr == only || should-dump(klass-info, only)) {
        if (1)
          dump-klass(ofl, klass-info);
        if (nullptr != output-dir) {
          boole-t exported? =          cast(boole-t)named-info::at(klass-info, $exported?);
          boole-t state-exported? =    cast(boole-t)named-info::at(klass-info, $state-exported?);
          boole-t behavior-exported? = cast(boole-t)named-info::at(klass-info, $behavior-exported?);

          if (exported? || state-exported? || behavior-exported?) {
            // bugbug: klass and trait can have same name
            char8-t[255 + (1)] klass-file = "";
            symbol-t klass-name = name-from-info(klass-info);
            snprintf(klass-file, sizeof(klass-file), "%s/%s.ctlg", output-dir, klass-name);
            ofile-t dofl = ofile::fopen(klass-file);
            gbl-current-module = "";
            dump-klass(dofl, klass-info);
            ofile::fclose(dofl);
          }
        }
      }
    }
  }
  return;
}

static uint32-t
max-enum-name-width(enum-info-t* enum-info)
{
  uint32-t result = 0;
  uint32-t i = 0;
  str-t name;
  while (nullptr != (name = enum-info[i++].name)) {
    uint32-t width = cast(uint32-t)safe-strlen(name);
    if (width > result)
      result = width;
  }
  return result;
}

static uint32-t
max-slot-type-width(named-info-t* slots-info)
{
  uint32-t result = 0;
  uint32-t i = 0;
  while (nullptr != slots-info[i].elements) {
    str-t slot-type = cast(str-t)named-info::at(&slots-info[i], $type);
    uint32-t width = cast(uint32-t)safe-strlen(slot-type);
    if (width > result)
      result = width;
    i++;
  }
  return result;
}

static uint32-t
max-slot-name-width(named-info-t* slots-info)
{
  uint32-t result = 0;
  uint32-t i = 0;
  while (nullptr != slots-info[i].elements) {
    str-t slot-name = cast(str-t)named-info::at(&slots-info[i], $name);
    uint32-t width = cast(uint32-t)safe-strlen(slot-name);
    if (width > result)
      result = width;
    i++;
  }
  return result;
}

static uint32-t
max-method-return-type-width(signature-t const* const* method-signatures, ...)
{
  uint32-t result = 0;
  va-list-t args;
  va-start(args, method-signatures);
  signature-t const* const* arg = method-signatures;
  do {
    uint32-t index =  0;

    if (nullptr != arg) {
      signature-t const* info;
      while (nullptr != (info = arg[index++])) {
        uint32-t width = cast(uint32-t)safe-strlen(info->return-type);
        if (width > result)
          result = width;
      }
    }
  }  while (nullptr != (arg = va-arg(args, signature-t const* const*)));
  va-end(args);
  return result;
}

static void
dump-method(ofile-t ofl, signature-t const* info, uint32-t max-return-type-width)
{
 ofile::printf(ofl, "method %-*s %s(%s);\n",
              max-return-type-width,
              info->return-type,
              info->name,
              info->parameter-types);
  return;
}

static void
dump-generic(ofile-t ofl, signature-t const* info)
{
 ofile::printf(ofl, "generic %s dk:%s(%s);\n",
              info->return-type,
              info->name,
              info->parameter-types);
  return;
}

noexport void
dump-klass(ofile-t ofl, named-info-t* klass-info)
{
  assert(nullptr != ofl.output);
  assert(8 > ofl.col);
  assert(nullptr != klass-info);

  symbol-t name = name-from-info(klass-info);
  symbol-t superklass-name = superklass-name-from-info(klass-info);
  symbol-t klass-name = klass-name-from-info(klass-info);

  str-t                     modulee =                        cast(str-t)                    named-info::at(klass-info, $module);
  boole-t                   exported? =                      cast(boole-t)                  named-info::at(klass-info, $exported?);
  boole-t                   state-exported? =                cast(boole-t)                  named-info::at(klass-info, $state-exported?);
  boole-t                   behavior-exported? =             cast(boole-t)                  named-info::at(klass-info, $behavior-exported?);
  symbol-t                  cat =                            cast(symbol-t)                 named-info::at(klass-info, $cat, cast(uintptr-t)$struct);
  symbol-t                  construct =                      cast(symbol-t)                 named-info::at(klass-info, $construct, cast(uintptr-t)$klass);
  symbol-t                  interpose-name =                 cast(symbol-t)                 named-info::at(klass-info, $interpose-name);
  symbol-t const*           traits =                         cast(symbol-t const*)          named-info::at(klass-info, $traits);
  symbol-t const*           requires =                       cast(symbol-t const*)          named-info::at(klass-info, $requires);
  symbol-t const*           provides =                       cast(symbol-t const*)          named-info::at(klass-info, $provides);
  signature-t const* const* method-signatures =              cast(signature-t const* const*)named-info::at(klass-info, $method-signatures);
  signature-t const* const* kw-args-method-signatures =           cast(signature-t const* const*)named-info::at(klass-info, $kw-args-method-signatures);
  signature-t const* const* exported-method-signatures =     cast(signature-t const* const*)named-info::at(klass-info, $exported-method-signatures);
  signature-t const* const* exported-slots-method-signatures = cast(signature-t const* const*)named-info::at(klass-info, $exported-slots-method-signatures);
  signature-t const* const* slots-method-signatures =        cast(signature-t const* const*)named-info::at(klass-info, $slots-method-signatures);
  //signature-t const* const* va-method-signatures =           cast(signature-t const* const*)named-info::at(klass-info, $va-method-signatures);
  //signature-t const* const* va-slots-method-signatures =     cast(signature-t const* const*)named-info::at(klass-info, $va-slots-method-signatures);
  named-enum-info-t const*  enum-info =                      cast(named-enum-info-t const*) named-info::at(klass-info, $enum-info);
  const-info-t const*       const-info =                     cast(const-info-t const*)      named-info::at(klass-info, $const-info);
  str-t                     slots-type =                     cast(str-t)                    named-info::at(klass-info, $slots-type);
  str-t                     enum-base =                      cast(str-t)                    named-info::at(klass-info, $enum-base);
  named-info-t*        slots-info =                     cast(named-info-t*)       named-info::at(klass-info, $slots-info);
//     method-t const* method-addresses =          cast(method-t*)named-info::at(klass-info, $method-addresses);
//     method-t const* va-method-addresses =       cast(method-t*)named-info::at(klass-info, $va-method-addresses);
//     method-t const* slots-method-addresses =    cast(method-t*)named-info::at(klass-info, $slots-method-addresses);
//     method-t const* va-slots-method-addresses = cast(method-t*)named-info::at(klass-info, $va-slots-method-addresses);

  assert(nullptr != construct);
  assert(nullptr != name);
  assert(!(nullptr != interpose-name && nullptr != superklass-name));

  boole-t verbose = 0;

  if (verbose) {
    if (nullptr == superklass-name)
      superklass-name = default-superklass-name();
    if (nullptr == klass-name)
      superklass-name = default-klass-name();
  } else {
    if (0 == symbol::compare(default-superklass-name(), superklass-name))
      superklass-name = nullptr;
    if (0 == symbol::compare(default-klass-name(), klass-name))
      klass-name = nullptr;
  }
  if (nullptr != modulee && 0 != safe-strcmp(gbl-current-module, modulee)) {
    ofile::printf(ofl, "module %s;\n\n", modulee);
    gbl-current-module = modulee;
  }

  if (exported? || state-exported? || behavior-exported?) {
    if (nullptr != kw-args-method-signatures) {
      uint32-t index = 0;
      signature-t const* info;
      while (nullptr != (info = kw-args-method-signatures[index++])) {
        dump-generic(ofl, info);
      }
      ofile::printf(ofl, "\n");
    }

    ofile::printf(ofl, "%s %s\n", construct, name);
    ofile::printf(ofl, "{\n");
    ofl.col++;

    if (nullptr != interpose-name)
      ofile::printf(ofl, "interpose %s;\n", interpose-name);
    if (nullptr != superklass-name)
      ofile::printf(ofl, "superklass %s;\n", superklass-name);
    if (nullptr != klass-name)
      ofile::printf(ofl, "klass %s;\n", klass-name);
    if (nullptr != traits) {
      uint32-t index = 0;

      while (nullptr != traits[index]) {
        ofile::printf(ofl, "trait %s;\n", traits[index]);
        index++;
      }
    }
    if (nullptr != requires) {
      uint32-t index = 0;

      while (nullptr != requires[index]) {
        ofile::printf(ofl, "require %s;\n", requires[index]);
        index++;
      }
    }
    if (nullptr != provides) {
      uint32-t index = 0;

      while (nullptr != provides[index]) {
        ofile::printf(ofl, "provides %s;\n", provides[index]);
        index++;
      }
    }
    if (nullptr != enum-info) {
      uint32-t i = 0;
      while (nullptr != enum-info[i].info) {
        ofile::printf(ofl, "export\n"); // hackhack
        if (nullptr != enum-info[i].name)
          ofile::printf(ofl, "enum %s\n", enum-info[i].name);
        else
          ofile::printf(ofl, "enum\n");
        ofile::printf(ofl, "{\n");
        ofl.col++;
        uint32-t max-name-width = max-enum-name-width(enum-info[i].info);
        uint32-t j = 0;
        while (nullptr != enum-info[i].info[j].name) {
          ofile::printf(ofl, "%-*s = %s,\n",
                       max-name-width,
                       enum-info[i].info[j].name,
                       enum-info[i].info[j].expr);
          j++;
        }
        ofl.col--;
        ofile::printf(ofl, "}\n");
        i++;
      }
    }
    if (nullptr != const-info) {
      uint32-t i = 0;
      while (nullptr != const-info[i].name) {
        ofile::printf(ofl, "export\n"); // hackhack
        ofile::printf(ofl, "const %s %s = %s;\n", const-info[i].type, const-info[i].name, const-info[i].value);
        i++;
      }
    }
#define DKT-DEBUG-CODEGEN 0
    if (DKT-DEBUG-CODEGEN || state-exported?) {
      if (nullptr != slots-type) {
        ofile::printf(ofl, "slots %s;\n", slots-type);
      }
      else-if (nullptr != slots-info) {
        if (nullptr == cat || $struct == cat)
          ofile::printf(ofl, "slots\n");
        else-if (enum-base)
          ofile::printf(ofl, "slots %s : %s\n", cat, enum-base);
        else
          ofile::printf(ofl, "slots %s\n", cat);
        ofile::printf(ofl, "{\n");
        ofl.col++;
        if ($enum == cat) {
          uint32-t max-type-width = max-slot-name-width(slots-info);
          uint32-t i = 0;
          while (nullptr != slots-info[i].elements) {
            symbol-t       slot-name = name-from-info(&slots-info[i]);
            assert(nullptr != slot-name);
            str-t slot-expr = cast(str-t)named-info::at(&slots-info[i], $expr);
            assert(nullptr != slot-expr);
            
            ofile::printf(ofl, "%-*s = %s,\n", max-type-width, slot-name, slot-expr);
            i++;
          }
        } else {
          uint32-t max-type-width = max-slot-type-width(slots-info);
          uint32-t i = 0;
          while (nullptr != slots-info[i].elements) {
            str-t slot-type = cast(str-t)named-info::at(&slots-info[i], $type);
            assert(nullptr != slot-type);
            symbol-t       slot-name = name-from-info(&slots-info[i]);
            assert(nullptr != slot-name);
            
            ofile::printf(ofl, "%-*s %s;\n", max-type-width, slot-type, slot-name);
            i++;
          }
        }
        ofl.col--;
        ofile::printf(ofl, "}\n");
      } else {
        fprintf(stderr, "%s:%i::error: exported slots without type or info\n", __FILE__, __LINE__);
      }
    } // if (state-exported?
    if ((nullptr != superklass-name || nullptr != klass-name || nullptr != traits || nullptr != requires || nullptr != provides)
        && nullptr != method-signatures) {
      ofile::printf(ofl, "\n");
    }
    signature-t const* info;
    uint32-t index;
    uint32-t max-return-type-width;

  //max-return-type-width = max-method-return-type-width(kw-args-method-signatures, nullptr);
    max-return-type-width = max-method-return-type-width(method-signatures,
                                                         slots-method-signatures,
                                                         exported-method-signatures,
                                                         exported-slots-method-signatures,
                                                         nullptr);

    index = 0;
    if (nullptr != kw-args-method-signatures)
      while (nullptr != (info = kw-args-method-signatures[index++])) {
        fprintf(ofl.output, "//");
        ofile-t ofl0 = {ofl.output, 0};
        dump-method(ofl0, info, max-return-type-width);
      }

    index = 0;
    if (nullptr != method-signatures)
      while (nullptr != (info = method-signatures[index++]))
        dump-method(ofl, info, max-return-type-width);

    index = 0;
    if (nullptr != slots-method-signatures)
      while (nullptr != (info = slots-method-signatures[index++]))
        dump-method(ofl, info, max-return-type-width);

    index = 0;
    if (nullptr != exported-method-signatures)
      while (nullptr != (info = exported-method-signatures[index++]))
        dump-method(ofl, info, max-return-type-width);

    index = 0;
    if (nullptr != exported-slots-method-signatures)
      while (nullptr != (info = exported-slots-method-signatures[index++]))
        dump-method(ofl, info, max-return-type-width);

    ofl.col--;
    ofile::printf(ofl, "}\n");
  }
  return;
}

noexport void import-selectors(signature-t**, selector-node-t*); // hackhack

noexport void
register-info-common(named-info-t* registration-info)
{
  signature-t**      signatures-va =          cast(signature-t**)     named-info::at(registration-info, $signatures-va);
  signature-t**      signatures =             cast(signature-t**)     named-info::at(registration-info, $signatures);
  selector-node-t*   selectors-va =           cast(selector-node-t*)  named-info::at(registration-info, $selectors-va);
  selector-node-t*   selectors =              cast(selector-node-t*)  named-info::at(registration-info, $selectors);
  symbol-t*          imported-klasses-names = cast(symbol-t*)         named-info::at(registration-info, $imported-klasses-names);
  assoc-node-t*      imported-klasses =       cast(assoc-node-t*)     named-info::at(registration-info, $imported-klasses);
  named-info-t* klass-defns =            cast(named-info-t*)named-info::at(registration-info, $klass-defns);
  property-t*        interposers =            cast(property-t*)       named-info::at(registration-info, $interposers);

  assert((nullptr == signatures    && nullptr == selectors   ) ||
         (nullptr != signatures    && nullptr != selectors   ));
  assert((nullptr == signatures-va && nullptr == selectors-va) ||
         (nullptr != signatures-va && nullptr != selectors-va));

  if (nullptr != signatures-va)
    import-selectors(signatures-va, selectors-va);
  if (nullptr != signatures)
    import-selectors(signatures, selectors);
  if (nullptr != imported-klasses)
    import-klasses(imported-klasses-names, imported-klasses);
  if (nullptr != klass-defns)
    export-klasses(klass-defns);
  if (nullptr != interposers)
    add-interposers(interposers);

  return;
}

static boole-t
getenv-boole(str-t name, boole-t default-value)
{
  boole-t value = default-value;
  str-t value-str = getenv(name);

  if (NULL != value-str) {
    if (0 != safe-strcmp("0", value-str))
      value = true;
  }
  return value;
}

static void
add-registration-info(named-info-t* registration-info)
{
  assert(nullptr == registration-info->next);
  registration-info->next = gbl-registration-info-list;
  gbl-registration-info-list = registration-info;
  return;
}

export void
dkt-register-info(named-info-t* registration-info)
{
  assert(nullptr != registration-info);
  file-t ctlg-output = nullptr;
  str-t output-path = getenv("DKT_INFO_OUTPUT");
  if (NULL != output-path) {
    if (NUL == output-path[0]) // empty-string ("") means use default-value
      ctlg-output = stdout;
    else
      ctlg-output = fopen(output-path, "a");
  }

  if (nullptr != ctlg-output) {
    boole-t ctlg-recursive = getenv-boole("DKT_INFO_RECURSIVE", false);
    str-t ctlg-only = getenv("DKT_INFO_ONLY");
    str-t ctlg-arg =  getenv("DKT_INFO_ARG");
    ofile-t ofl = {ctlg-output, 0};

    symbol-t name = name-from-info(registration-info);
    assert(nullptr != name);
    ofile::printf(ofl, "//arg=%s\n",  ctlg-arg);
    ofile::printf(ofl, "//name=%s\n", name);
    str-t arg-base =  remove-dir(ctlg-arg);
    str-t name-base = remove-dir(name);

    if (ctlg-recursive || (0 == safe-strcmp(arg-base, name-base))) {
      dump-klass-defns(ofl, registration-info, ctlg-only);
      dump-interposers(ofl, registration-info);
      if (NULL == ctlg-only)
        dump-module-description(ofl, registration-info);
    }
  }
  construct-t construct = cast(construct-t)named-info::at(registration-info, $construct);

  switch (construct)
  {
    case construct::k-library:
      add-registration-info(registration-info);
      break;
    case construct::k-executable:
      add-registration-info(registration-info);
      if (NULL != getenv("DKT_PERL_DUMP_KLASSES"))
        perl-dump-klass-defns(gbl-klass-defns-table);
      if (0)
        perl-dump-resource-info(gbl-klass-defns-table);
      if (NULL == getenv("DKT_NO_INIT_RUNTIME"))
        dk-init-runtime();
      if (NULL != getenv("DKT_EXIT_BEFORE_MAIN"))
        exit(0);
      break;
  }
  if (nullptr != output-path && NUL != output-path[0] && nullptr != ctlg-output)
    fclose(ctlg-output);
  return;
}
export void
dkt-deregister-info(named-info-t* registration-info)
{
  assert(nullptr != registration-info);
  if (NULL != getenv("DKT_INFO_OUTPUT") ||
      NULL != getenv("DKT_NO_INIT_RUNTIME"))
    return;
  named-info::sort(registration-info);
  named-info-t* klass-defns = cast(named-info-t*)named-info::at(registration-info, $klass-defns);

  if (nullptr != klass-defns) {
    uint32-t i = 0;
      
    while (1) {
      named-info-t* klass-info = &klass-defns[i++];
      assert(nullptr != klass-info);
      if (nullptr == klass-info->elements)
        break;
      symbol-t klass-name = name-from-info(klass-info);
      str-t file = cast(symbol-t)named-info::at(klass-info, $file);
      method-t finalize =   cast(method-t)named-info::at(klass-info, $finalize);
      if (nullptr != finalize) {
        named-assoc-node-t named-node = { klass-name, nullptr };
        named-assoc-node-t* found-named-node = cast(named-assoc-node-t*)sorted-array::bsearch(gbl-imported-klasses-table, &named-node);
        if (nullptr != found-named-node) {
          object-t kls = cast(object-t)(found-named-node->node->element);
          DKT-LOG-INITIAL-FINAL("'action':'%s','args':['%s'],'klass':'%s','file':'%s'",
                                "finalize", "klass", klass-name, file);
          kls = finalize(kls);
        }
      }
    }
  }
  symbol-t name = name-from-info(registration-info);
  assert(nullptr != name);
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%p'],'klass-name':'%s'", __func__, cast(void*)(registration-info), name);
  return;
}

static symbol-t
superklass-name-for-name(symbol-t klass-name)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%s']", __func__, klass-name);
  named-info-t* klass-info = info-for-name(klass-name);
  symbol-t superklass-name = superklass-name-from-info(klass-info, klass-name); // namename: ???
  return superklass-name;
}

export object-t
dk-klass-for-name(symbol-t klass-name)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%s']", __func__, klass-name);
  assert(nullptr != klass-name);
  named-info-t* klass-info-slots = info-for-name(klass-name);
  assert($trait != cast(symbol-t)named-info::at(klass-info-slots, $construct));
  assoc-node-t* klass-assoc = imported-klasses-for-klass(klass-name);
  object-t klass = nullptr;

  if (nullptr == klass-assoc || nullptr == (klass = *cast(object-t*)(klass-assoc->element))) {
    object-t klass-klass = nullptr;
    symbol-t name = klass-name-from-info(klass-info-slots);

    if (nullptr == name) {
      symbol-t superklass-name = superklass-name-for-name(klass-name);

      if (nullptr == superklass-name)
        superklass-name = default-superklass-name();

      named-info-t* superklass-info = info-for-name(superklass-name);
      symbol-t superklass-klass-name = klass-name-from-info(superklass-info);

      if (nullptr == superklass-klass-name)
        klass-klass = default-klass();
      else
        klass-klass = dk-klass-for-name(superklass-klass-name); // recursive
      assert(nullptr != klass-klass);
    } else {
      klass-klass = dk-klass-for-name(name); // recursive
      assert(klass::klass == klass-klass || klass::subklass?(klass-klass, klass::klass));
      assert(nullptr != klass-klass);
    }
    klass = make(klass-klass, $info-slots : klass-info-slots);
  }
  assert(nullptr != klass);
  return klass;
}
noexport named-info-t*
info-for-name(symbol-t klass-name)
{
  assert(nullptr != klass-name);
  property-t[] properties = { { $name, cast(uintptr-t)klass-name } };
  named-info-t info = { properties, DK-ARRAY-LENGTH(properties), nullptr };
  named-info-t* info-ptr = &info;
  named-info-t** klass-info-ptr = cast(named-info-t**)sorted-array::bsearch(gbl-klass-defns-table, &info-ptr);

  if (nullptr == klass-info-ptr) {
    str-t klasspath = getenv("KLASSPATH");

    if (NULL == klasspath) {
      fprintf(stderr, "%s:%i: ERROR: klass '%s' not found and KLASSPATH not set.\n", __FILE__, __LINE__, klass-name);
      throw "bummer";
    } else {
      //fprintf(stdout, "KLASSPATH=%s\n", klasspath);
      str-t file-name = file-name-from-klass-name(klass-name);
      str-t file = find-file(klasspath, file-name, SO-EXT);

      if (nullptr != file) {
        load-library(file);

        // aggregate klass here

        //init-imported-klasses();

        named-info-t* loaded-klass-info = info-for-name(klass-name); // recursive
        return loaded-klass-info; // rnielsen: should have only one return per function
      }
      fprintf(stderr, "%s:%i: ERROR: klass '%s' not found.\n", __FILE__, __LINE__, klass-name);
      throw "bummer";
    }
  }
  return *klass-info-ptr; // rnielsen: should have only one return per function
}

/*
  dk-intern needs to be able to be used **early** in the static initialization
  sequence.
 */

export symbol-t
dk-intern(str-t key)
{
  DKT-LOG-TRACE-RUNTIME("'func':'%s','args':['%s']", __func__, key);
  static sorted-ptr-array-t* intern-array = sorted-ptr-array::create(32, cast(uint32-t)sizeof(symbol-t), cast(std-compare-t)safe-strcmp);

  if (intern-array->count == intern-array->capacity) {
    intern-array->capacity *= 2;
    intern-array->elements = cast(void**)dkt::alloc(intern-array->size * intern-array->capacity, intern-array->elements);
  }

#if 0
  symbol-t val = key;
#else
  symbol-t val = cast(symbol-t)sorted-ptr-array::intern(intern-array, cast(void const*)(key));
//fprintf(stderr, "%s(\"%s\" {%p}) = \"%s\" {%p}\n", __func__, key, key, val, val);
#endif
  //dkt-log(dkt::k-log-info, "%s(\"%s\" {%p}) = \"%s\" {%p}", __func__, key, key, val, val);
  return val;
}

static char8-t*
get-klass-chain(object-t klass, char8-t* buf, uint32-t buf-len)
{
  object-t superklass = dk::superklass(klass);
  if (nullptr != superklass && null != superklass)
    get-klass-chain(superklass, buf, buf-len); // recursive
  str-t klass-name = dk::name(klass);
  strcat(buf, "/");
  strcat(buf, klass-name);
  return buf;
}

DEBUG-EXPORT char8-t*
dkt-get-klass-chain(object-t klass, char8-t* buf, uint32-t buf-len)
{
  buf[0] = NUL;
  return get-klass-chain(klass, buf, buf-len);
}
