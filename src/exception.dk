// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <unistd.h> // getpid()

#if HAVE-CONFIG-HH
  #include "config.hh"
#endif

#include "dakota-private.hh"

module dakota;

klass output-stream;
klass system-exception;

SO-EXPORT object-t dkt-capture-current-exception(object-t arg) {
  static THREAD_LOCAL object-t result;
  if (nullptr != arg) result = arg;
  return result;
}
SO-EXPORT str-t dkt-capture-current-exception(str-t arg) {
  static THREAD_LOCAL str-t result;
  if (nullptr != arg) result = arg;
  return result;
}
#if !defined HAVE-GETPROGNAME
#if defined HAVE-PROCFS
static char8-t[4 * 1024] gbl-buf;
str-t
getprogname() {
  int-t n = readlink("/proc/self/exe", gbl-buf, sizeof(gbl-buf) - 1);
  if (-1 == n)
    throw make(system-exception::klass, #errnum : errno);
  gbl-buf[n] = NUL;
  str-t progname = strrchr(gbl-buf, '/');
  if (nullptr != progname)
    progname++;
  else
    progname = gbl-buf;
  return progname;
}
#endif
#endif

[[format-va-printf(2)]] static auto
va-log(uint32-t priority, str-t format, va-list-t args) -> int-t {
  stream-t log-file = stderr;

  if (nullptr != getenv("DEBUG")) {
    fprintf(log-file, "%s[%i]: ", getprogname(), getpid());

    switch (priority) {
      case dkt::k-log-error:
        fprintf(log-file, "error: ");
        break;
      case dkt::k-log-warning:
        fprintf(log-file, "warning: ");
        break;
      case dkt::k-log-info:
        fprintf(log-file, "info: ");
        break;
      case dkt::k-log-debug:
        fprintf(log-file, "debug: ");
        break;
      default:
        std::abort();
    }
  }
  fprintf(log-file, "{");
  int-t result = vfprintf(log-file, format, args);
  fprintf(log-file, "},\n");
  // bugbug: need to adjust result
  return result;
}
DEBUG-SO-EXPORT [[format-va-printf(2)]]
auto dkt-va-log(uint32-t priority, str-t format, va-list-t args) -> int-t {
  int-t result = va-log(priority, format, args);
  return result;
}
DEBUG-SO-EXPORT [[format-printf(2)]]
auto dkt-log(uint32-t priority, str-t format, ...) -> int-t {
  va-list-t args;
  va-start(args, format);
  int-t result = dkt-va-log(priority, format, args);
  va-end(args);
  return result;
}
static /*THREAD-LOCAL*/ void (*original-terminate)() =  std::set-terminate(pre-runtime-verbose-terminate);
static /*THREAD-LOCAL*/ void (*original-unexpected)() = std::set-unexpected(pre-runtime-verbose-unexpected);

[[noreturn]] void
pre-runtime-verbose-terminate() noexcept {
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = dkt-capture-current-exception(cast(str-t)nullptr);
  dkt-log(dkt::k-log-error, "uncaught/unexpected exception");

  if (nullptr != current-exception-string)
    fprintf(stderr, ": \"%s\"\n", current-exception-string);
  else
    fprintf(stderr, "\n");

  if (nullptr != original-terminate)
    original-terminate();
  std::abort(); // should never get called
}
[[noreturn]] void
verbose-terminate() noexcept {
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = dkt-capture-current-exception(cast(str-t)nullptr);
  object-t current-exception = dkt-capture-current-exception(cast(object-t)nullptr);

  if (nullptr != (getenv("DKT_DUMP_UNHANDLED_EXCEPTION")))
    if (nullptr != current-exception)
      $dump(current-exception);

  $print-format(std-error, "{ \"progname\": \"%s\", \"pid\": %i, \"root-msg\": \"uncaught/unexpected exception\"",
                   getprogname(), getpid());

  if (nullptr != current-exception)
    $print(current-exception, std-error);
    // $println-format(std-error, ", \"exception\": \"%s\"", current-exception);
  else-if (nullptr != current-exception-string)
    $print-format(std-error, ", \"exception\": \"%s\"", current-exception-string);
  else
    $print(std-error, "");
  $println(std-error, " }");

  if (nullptr != original-terminate)
    original-terminate();
  std::abort(); // should never get called
}
[[noreturn]] void
pre-runtime-verbose-unexpected() noexcept {
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  pre-runtime-verbose-terminate();
}
[[noreturn]] void
verbose-unexpected() noexcept {
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  verbose-terminate();
}
klass exception {
  superklass object;

  slots {
    str-t message;
  }
  method init(object-t self, str-t message : name-of(klass-of(self))) -> object-t {
    self = $init(super);
    self.message = message;
    return self;
  }
  method print(object-t self, object-t out) -> object-t {
    if (null == out)
      out = std-error;
    $print-format(out, ", \"%s\": \"%s\"", name-of(klass), self.message);
    return self;
  }
}
