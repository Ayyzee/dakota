// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cerrno>;
include <cstdio>;
include <cstring>;
include <exception>;
include <unistd.h>; // getpid()

#if HAVE-CONFIG-HH
  #include "config.hh"
#endif

#include "dakota-private.hh"

#define THROW throw // so the macro system won't rewrite

module dakota;

klass output-stream;

export object-t dkt-capture-current-exception(object-t arg)
{
  static object-t result = arg;
  return result;
}

export str-t dkt-capture-current-exception(str-t arg)
{
  static str-t result = arg;
  return result;
}

#if !defined HAVE-GETPROGNAME
#if defined HAVE-PROCFS
static char8-t[1024] gbl-buf;
str-t
getprogname()
{
  int-t n = readlink("/proc/self/exe", gbl-buf, sizeof(gbl-buf) - 1);
  if (-1 == n)
    throw make(system-exception:klass, $errnum => errno);
  gbl-buf[n] = NUL;
  str-t progname = strrchr(gbl-buf, '/');
  if (nullptr != progname)
    progname++;
  else
    progname = gbl-buf;
  return progname;
}
#endif
#endif

static format-va-printf(2) int-t
va-log(uint32-t priority, str-t format, va-list-t args)
{
  file-t log-file = stderr;

  if (0) {
    fprintf(log-file, "%s[%i]: ", getprogname(), getpid());

    switch (priority)
    {
      case dkt::k-log-error:
        fprintf(log-file, "error: ");
        break;
      case dkt::k-log-warning:
        fprintf(log-file, "warning: ");
        break;
      case dkt::k-log-info:
        fprintf(log-file, "info: ");
        break;
      case dkt::k-log-debug:
        fprintf(log-file, "debug: ");
        break;
      default:
        abort();
    }
  }
  fprintf(log-file, "{");
  int-t result = vfprintf(log-file, format, args);
  fprintf(log-file, "},\n");
  // bugbug: need to adjust result
  return result;
}

DEBUG-EXPORT format-va-printf(2) int-t
dkt-va-log(uint32-t priority, str-t format, va-list-t args)
{
  int-t result = va-log(priority, format, args);
  return result;
}

DEBUG-EXPORT format-printf(2) int-t
dkt-log(uint32-t priority, str-t format, ...)
{
  va-list-t args;
  va-start(args, format);
  int-t result = dkt-va-log(priority, format, args);
  va-end(args);
  return result;
}

noexport void pre-runtime-verbose-terminate();
noexport void (*previous-terminate)() = std::set-terminate(pre-runtime-verbose-terminate);
noexport void
pre-runtime-verbose-terminate()
{
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = *dkt-capture-current-exception(cast(str-t)0);
  dkt-log(dkt::k-log-error, "uncaught exception");

  if (nullptr != current-exception-string)
    fprintf(stderr, ": \"%s\"\n", current-exception-string);
  else
    fprintf(stderr, "\n");

  previous-terminate();
}

noexport void
verbose-terminate()
{
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = *dkt-capture-current-exception(cast(str-t)0);
  object-t current-exception = *dkt-capture-current-exception(cast(object-t)0);

  if (NULL != (getenv("DKT_DUMP_UNHANDLED_EXCEPTION")))
    if (nullptr != current-exception)
      dk:dump(current-exception);

  dk:print-format(std-error, "%s[%i]: uncaught exception", getprogname(), getpid());

  if (nullptr != current-exception)
    dk:println(current-exception, std-error);
  else-if (nullptr != current-exception-string)
    dk:println-format(std-error, ": \"%s\"", current-exception-string);
  else
    dk:println(std-error, "");

  previous-terminate();
}

noexport void pre-runtime-verbose-unexpected();
noexport void (*previous-unexpected)() = std::set-unexpected(pre-runtime-verbose-unexpected);
noexport void
pre-runtime-verbose-unexpected()
{
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = *dkt-capture-current-exception(cast(str-t)0);
  dkt-log(dkt::k-log-error, "unexpected exception");

  if (nullptr != current-exception-string)
    fprintf(stderr, ": \"%s\"\n", current-exception-string);
  else
    fprintf(stderr, "\n");

  previous-unexpected();
}

noexport void
verbose-unexpected()
{
//   dkt-log(dkt::k-log-info, "%s()", __func__);

  str-t current-exception-string = *dkt-capture-current-exception(cast(str-t)0);
  object-t current-exception = *dkt-capture-current-exception(cast(object-t)0);

  if (NULL != (getenv("DKT_DUMP_UNEXPECTED_EXCEPTION")))
    if (nullptr != current-exception)
      dk:dump(current-exception);

  dk:print-format(std-error, "%s[%i]: unexpected exception", getprogname(), getpid());

  if (nullptr != current-exception)
    dk:println(current-exception, std-error);
  else-if (nullptr != current-exception-string)
    dk:println-format(std-error, ": \"%s\"", current-exception-string);
  else
    dk:println(std-error, "");

  previous-unexpected();
}

klass exception
{
  superklass object;

  slots
  {
    str-t message;
  }

  method object-t init(object-t self, str-t message => dkt-name(dkt-klass(self)))
  {
    self = dk:init(super);
    self.message = message;
    return self;
  }

  method object-t print(object-t self, object-t out)
  {
    if (null == out)
      out = std-error;
    dk:print-format(out, ": <%s>", self.message);
    return self;
  }
}
