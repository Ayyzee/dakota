// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

klass boole;
klass input-stream;
klass null-singleton;
klass output-stream;

// singleton null {}
// //=>
// klass null-singleton { klass singleton-klass; }
// instance null    of klass null-singleton;

// instance <qual-name> of klass <qual-ident> [ { ... } ] ;
// or
// instance <qual-name> of <qual-ident>::klass [ { ... } ] ;

instance null       { return make(null-singleton::klass); }
instance std-input  { return make(input-stream::klass,  #slots : stdin);  };
instance std-output { return make(output-stream::klass, #slots : stdout); };
instance std-error  { return make(output-stream::klass, #slots : stderr); };

// defn for export

{ // ro-data
  // name (for lookup)
  { #null,              [] () -> object-t { return make(null-singleton::klass); } },
  { #std-input,         [] () -> object-t { return make(input-stream::klass,  #slots : stdin);  } },
  { #std-output,        [] () -> object-t { return make(output-stream::klass, #slots : stdout); } },
  { #std-error,         [] () -> object-t { return make(output-stream::klass, #slots : stderr); } },
}
// AND
{ // rw-data
  &null,
  &std-input,
  &std-output,
  &std-error,
}

// decl for import

{ array of names/lambdas } // ro-data
// AND
{ array of ptrs } // rw-data

klass named-instance-defn-func {
  slots (*)() -> object-t;
}
klass named-instance-defn {
  slots { // ro-only
    symbol-t                   name;
    named-instance-defn-func-t func;
  }
}
klass ptr-node {
  slots {
    ptr-t       ptr;
    ptr-node-t* next;
  }
}
// example: export 2, import 3

static ptr-node-t named-instance-ptrs[] = {
  { &aa, nullptr }, // #aa
  { &bb, nullptr }, // #bb
  { &cc, nullptr }, // #cc
  { &dd, nullptr }, // #dd (only if defining SO also imports it)
  { &ee, nullptr }, // #ee (only if defining SO also imports it)
};
static symbol-t const* named-instance-names[] = {
  #aa,
  #bb,
  #cc,
  //#dd,
  //#ee,
};
static named-instance-defn-t named-instance-defns[] {
  #dd, []() { return make(...); }
  #ee, []() { return make(...); }
};
