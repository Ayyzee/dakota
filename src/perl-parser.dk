// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cassert>;
include <cctype>;
include <cerrno>;
include <cstdlib>;
include <cstring>;

module dakota-util;

klass str128;
klass tokenid;

static format-printf(4) int-t
print-error(str-t filename, uint32-t line, uint32-t column, str-t format, ...)
{
  int-t result = fprintf(stderr, "%s:%i:%i ", filename, line, column);
  if (-1 != result) {
    va-list-t args;
    va-start(args, format);
    result += vfprintf(stderr, format, args);
    va-end(args);
  }
  return result;
}
klass perl-parser
{  
  slots
  {
    file-t   in;
    str-t    filename;
    uint32-t line;
    uint32-t column;
  }
    
  method object-t init(object-t self,
                       file-t   file :     stdin,
                       str-t    filename : nullptr)
  {
    self = dk::init(super);
    assert(!(stdin != file &&
             nullptr  != filename)); // these are mutually exclusive

    if (nullptr != filename) {
      self.filename = filename;
      self.in =       fopen(self.filename, "r");
  
      if (nullptr == self.in) {
        str128-t buf = "";
        strerror-r(errno, buf, sizeof(buf));
        fprintf(stderr, "%s: %s", filename, buf);
        throw make(exception::klass, $message : "oops");
      }
    } else {
      self.filename = nullptr;
      self.in =       file;
    }
    self.line =     1;
    self.column =   0;
    return self;
  }

  method uint32-t read(object-t self, void* buffer, uint32-t element-size, uint32-t num-elements-max)
  {
    uint32-t num-elements-read = cast(uint32-t)fread(buffer, cast(size-t)element-size, cast(size-t)num-elements-max, self.in);
    
    // fread() does not distinguish between end-of-file and error, and callers must use
    // feof(3) and ferror(3) to determine which occurred.
    
    return num-elements-read;
  }

  /* method */ static void putback(object-t self, int32-t c)
  {
    if ('\n' == c)
      self.line--;
      // where is column left?
    else
      self.column--;
    ungetc(c, self.in);
    return;
  }

  /* method */ static int32-t get(object-t self)
  {
    int32-t c = getc(self.in);
    if (EOF != c) {
      if ('\n' == c) {
        self.line++;
        self.column = 0;
      } else {
        self.column++;
      }
    }
    return c;
  }

  //void error-msg(char8-t* filename, uint32-t line, uint32-t column, str-t msg0, ...); // one or more msg strings

  /* method */ static object-t lex(object-t self)
  {
    int32-t c;
    while (1) {
      while (isspace(c = perl-parser::get(self))) {
      }
      if (EOF == c)
      { return null; }

      switch (c)
      {
        // self.column needs to be adjusted by the length of the token
        case '[': { return make(token::klass, $tokenid : '[', $buffer : "[",
                                $line : self.line, $column : self.column - 1); }
        case ']': { return make(token::klass, $tokenid : ']', $buffer : "]",
                                $line : self.line, $column : self.column - 1); }
        case '{': { return make(token::klass, $tokenid : '{', $buffer : "{",
                                $line : self.line, $column : self.column - 1); }
        case '}': { return make(token::klass, $tokenid : '}', $buffer : "}",
                                $line : self.line, $column : self.column - 1); }
        case ',': { return make(token::klass, $tokenid : ',', $buffer : ",",
                                $line : self.line, $column : self.column - 1); }
        case '$':
        {
          while ('\n' != (c = perl-parser::get(self))) {
            if (EOF == c)
              return null;
          }
          break;
        }
        case '=':
        {
          c = perl-parser::get(self);
          if (EOF == c || '>' != c) {
            print-error(self.filename, self.line, self.column - 2, "unknown token '='\n");
            return null;
          } else {
            return make(token::klass, $tokenid : ':', $buffer : ":",
                        $line : self.line, $column : self.column - 2);
          }
        }
        case '\'':
        {
          int32-t quote-type = '\'';
          object-t token = make(token::klass, $tokenid : 'sqst',
                                $line : self.line, $column : self.column - 1);
          boole-t escaped?;
          c = perl-parser::get(self);
          if (EOF == c) {
            print-error(self.filename, self.line, self.column, "unterminated string\n");
            return null;
          }
          if (quote-type == c)
            return token; // empty string
          do {
            dk::append(token, cast(uint32-t)c);

            if ('\\' == c)
              escaped? = true;
            else
              escaped? = false;

            c = perl-parser::get(self);
            if (EOF == c) {
              print-error(self.filename, self.line, self.column, "unterminated string\n");
              return null;
            }
          } while ((quote-type != c) || escaped?);
            
          return token;
        }
        //case '"':
        //{
        //}

        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
        case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
        case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':
        case 'v': case 'w': case 'x': case 'y': case 'z':

        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
        case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':
        case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':
        case 'V': case 'W': case 'X': case 'Y': case 'Z':

        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            
        case '_':
        {
          object-t token = make(token::klass, $tokenid : 'st',
                                $line : self.line, $column : self.column - 1);
          do {
            dk::append(token, cast(uint32-t)c);
            c = perl-parser::get(self);
          } while (isalnum(c) || '_' == c);
          if (EOF != c)
            perl-parser::putback(self, c);
          return token;
        }
        default:
        {
          print-error(self.filename, self.line, self.column, "unknown token '%c'\n", c);
          return null;
        }
      }
    }
  }
    
  /* method */ noexport object-t get-table(object-t self);
  /* method */ noexport object-t get-vector(object-t self);

  /* method */ static object-t key(object-t self)
  {
    object-t token = perl-parser::lex(self);
    if (null == token) {
      print-error(self.filename, self.line, self.column, "incomplete table\n");
      return null;
    }
    object-t key;
    switch (dk::tokenid(token))
    {
      case 'sqst':
        key = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'dqst':
        key = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'st':
        key = make(string::klass, $bytes : dk::buffer(token));
        break;
      case '}':
        return null;
      default:
        print-error(self.filename, self.line, self.column, "expected <string> or '}' but got '%s'\n", dk::buffer(token));
        return null;
    }
    return key;
  }

  /* method */ static object-t get-corresponds-to(object-t self)
  {
    object-t token = perl-parser::lex(self);
    if (null == token) {
      print-error(self.filename, self.line, self.column, "incomplete table\n");
      return null;
    }
    if (dk::tokenid(token) != ':') {
      print-error(self.filename, self.line, self.column, "expected ':' but got '%s'\n", dk::buffer(token));
      return null;
    }
    return make(string::klass, $bytes : dk::buffer(token));
  }

  /* method */ static object-t get-value(object-t self)
  { // get table value - value is NOT optional
    object-t token = perl-parser::lex(self);
    if (null == token) {
      print-error(self.filename, self.line, self.column, "incomplete table\n");
      return null;
    }
    object-t value;
    switch (dk::tokenid(token))
    {
      case 'undf':
        value = null; // undef
        break;
      case 'sqst':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'dqst':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'st':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case '{':
        value = perl-parser::get-table(self);
        break;
      case '[':
        value = perl-parser::get-vector(self);
        break;
      default:
        print-error(self.filename, self.line, self.column, "expected <string> or 'undef' or '{' or '[' but got '%s'\n", dk::buffer(token));
        return null;
    }
    return value;
  }

  /* method */ static object-t element(object-t self)
  { // get vector element - element is optional
    object-t token = perl-parser::lex(self);
    if (null == token) {
      print-error(self.filename, self.line, self.column, "incomplete table\n");
      return null;
    }
    object-t value;
    switch (dk::tokenid(token))
    {
      case 'undf':
        value = null; // undef
        break;
      case 'sqst':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'dqst':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case 'st':
        value = make(string::klass, $bytes : dk::buffer(token));
        break;
      case '{':
        value = perl-parser::get-table(self);
        break;
      case '[':
        value = perl-parser::get-vector(self);
        break;
      case ']': // only difference from get-value()
        return null;
      default:
        print-error(self.filename, self.line, self.column, "expected <string> or 'undef' or '{' or '[' or ']' but got '%s'\n", dk::buffer(token));
        return null;
    }
    return value;
  }

  /* method */ static object-t get-table-pair(object-t self)
  {
    object-t key = perl-parser::key(self);
    if (null == key)
      return nullptr;
    object-t corresponds-to = perl-parser::get-corresponds-to(self);
    if (null == corresponds-to)
      return nullptr;
    object-t value = perl-parser::get-value(self);
    if (null == value)
      return nullptr;
    return assoc::box({key, value});
  }

  // hackhack - multiple return statements
  /* method */ noexport object-t get-vector(object-t self)
  {
    object-t vector = make(vector::klass);
    object-t token;
    do {
      object-t value = perl-parser::element(self);
      if (null == value)
        return vector;

      // add 'value' to 'vector'
      dk::add-last(vector, value);

      token = perl-parser::lex(self);
      if (null == token) {
        print-error(self.filename, self.line, self.column, "incomplete vector\n");
        return null; // undef
      }
    } while (',' == dk::tokenid(token));
      
      
    if (']' != dk::tokenid(token)) {
      print-error(self.filename, self.line, self.column, "expected ',' or ']' but got '%s'\n", dk::buffer(token));
      return null; // undef
    }
    return vector;
  }

  /* method */ noexport object-t get-table(object-t self)
  {
    object-t table = make(hashed-table::klass);
    object-t token;
    do {
      object-t table-pair = perl-parser::get-table-pair(self);
      if (nullptr == table-pair)
        return table;

      // add 'table-pair' to 'table'
      dk::add(table, table-pair);

      token = perl-parser::lex(self);
      if (null == token) {
        print-error(self.filename, self.line, self.column, "incomplete table\n");
        return null;
      }
    } while (',' == dk::tokenid(token));
      
    if ('}' != dk::tokenid(token)) {
      print-error(self.filename, self.line, self.column, "expected ',' or '}' but got '%s'\n", dk::buffer(token));
      return null; // undef
    }
    return table;
  }
    
  //      method object-t _read-property-list(object-t self)
  //      {
  //        object-t token;
  //        while (null != (token = perl-parser::lex(self)))
  //          dk::token::print(token, stdout);
  //        return null;
  //      }

  method object-t read-property-list(object-t self)
  {

    object-t token = perl-parser::lex(self);
    if (null == token)
      return null; // undef

    switch (dk::tokenid(token))
    {
      case 'undf':
        return null; // undef
      case 'sqst':
        return make(string::klass, $bytes : dk::buffer(token));
      case 'dqst':
        return make(string::klass, $bytes : dk::buffer(token));
      case 'st':
        return make(string::klass, $bytes : dk::buffer(token));
      case '{':
        return perl-parser::get-table(self);
      case '[':
        return perl-parser::get-vector(self);
      default:
        print-error(self.filename, self.line, self.column, "expected <string> or 'undef' or '{' or '[' but got '%s'\n", dk::buffer(token));
        return null; // undef
    }
  }
}
