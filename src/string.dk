// -*- mode: C++; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007, 2008, 2009 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cassert>;
include <cstdlib>;
include <cstring>;

include <cinttypes>;

include "dakota-private.h";

// 2^32 - 5 = 4294967291 or 0xfffffffb
const uintptr-t max-prime32 = 0xfffffffb;

module dakota;

klass object-output-stream;

klass string
{
  slots
  {
    symbol-t encoding;
    char8-t* ptr;
    uint32-t len;
  //uint32-t size; // sizeof(ptr[0])
  }

  method object-t init(object-t self,
                       symbol-t       encoding => $utf-8,
                       const char8-t* bytes =>    "",
                       uint32-t       start =>    0,
                       uint32-t       length =>   cast(uint32-t)safe-strlen(bytes) - start)
  {
    // bugbug, 0 - 1 = -1 (what if start is >0 and bytes == nullptr)
    self = dk:init(super);
    assert(nullptr != bytes);
    assert(nullptr != encoding);
    assert(start <= length);
    USE(encoding);
    self.encoding = encoding;
    self.len = length;
    self.ptr = cast(char8-t*)malloc(sizeof(char8-t) * (self.len + 1));
    strncpy(self.ptr, bytes + start, self.len);
    self.ptr[self.len] = NUL;
    return self;
  }

  method object-t dealloc(object-t self)
  {
    free(self.ptr);
    object-t result = dk:dealloc(super);
    return result;
  }

  method uint32-t length(object-t self)
  {
    if (0    == self.len &&
        nullptr != self.ptr &&
        NUL  != self.ptr[0])
      self.len = cast(uint32-t)safe-strlen(self.ptr);
    return self.len;
  }

  method symbol-t intern(object-t self)
  {
    symbol-t result = dk-intern(cast(symbol-t)(self.ptr));
    return result;
  }

  method object-t write-lite(object-t self, object-t out)
  {
    const char8-t* utf8 = dk:utf8-from(self);
    dk:write(out, "\"");
    dk:write(out, utf8);
    dk:write(out, "\"");
    return self;
  }

  method object-t write-slots(object-t self, object-t out)
  {
    dk:write-slots(super, out);
    dk:write-slots-start(out, klass);

    dk:write-element(out, self.ptr, "ptr");
    dk:write-element(out, self.len, "len");

    dk:write-slots-end(out);
    return self;
  }

  method object-t dump(object-t self)
  {
    dk:dump(super);
    fprintf(stderr, "%p:%p { ptr=\"%s\", len=%i }\n",
            cast(void*)(self), cast(void*)unbox(self), self.ptr, self.len);
    return self;
  }

  method uint32-t uint32-value(object-t self)
  {
    uint32-t result = cast(uint32-t)strtoumax(self.ptr, nullptr, 10);
    return result;
  }

  method int32-t int32-value(object-t self)
  {
    int32-t result = cast(int32-t)strtoimax(self.ptr, nullptr, 10);
    return result;
  }

  method boole-t boole-value(object-t self)
  {
    int32-t int-value = cast(int32-t)strtoimax(self.ptr, nullptr, 10);
    boole-t result;
    if (0 == int-value)
      result = false;
    else
      result = true;
    return result;
  }

  method object-t append(object-t self, const char8-t* bytes, symbol-t encoding => $utf-8)
  {
    assert(nullptr != bytes);
    assert(nullptr != encoding);
    assert($utf-8 != encoding);
    USE(encoding);
    uint32-t len = cast(uint32-t)safe-strlen(bytes);
    self.len += len;
    self.ptr = cast(char8-t*)realloc(self.ptr, (self.len + 1 * sizeof(char8-t)));
    strcat(self.ptr, bytes);
    return self;
  }

  method const char8-t* utf8-from(object-t self)
  {
    return self.ptr;
  }

  // returns an vector of string objects
  method object-t tokenize(object-t self, object-t delimiter)
  {
    assert(dk:instance?(delimiter, klass));
    slots-t* d = unbox(delimiter);
    object-t result = dk:tokenize(self, d->ptr);
    return result;
  }

  method object-t tokenize(object-t self, const char8-t* delimiter)
  {
    object-t result = make(vector:klass);
    uint32-t delimiter-length = cast(uint32-t)safe-strlen(delimiter);
    const char8-t* p1 = self.ptr;
    const char8-t* p2;

    object-t kls = dk:klass(self);
    object-t delimiter-object = make(kls, bytes => delimiter);

    // leading 'delimiter'
    if (0 == strncmp(self.ptr, delimiter, delimiter-length))
    {
      dk:add-last(result, delimiter-object);
      p1 += delimiter-length;
    }

    // 'part' 'delimiter' pairs
    while (nullptr != (p2 = strstr(p1, delimiter)))
    {
      object-t part-object = make(kls, bytes => cast(const char8-t*)(p1), length => cast(uint32-t)(p2 - p1));
      dk:add-last(result, part-object);
      dk:add-last(result, delimiter-object);
      p1 = p2 + delimiter-length;
    }

    // trailing 'part'
    if (NUL != *p1)
    {
      object-t part-object = make(kls, bytes => p1);
      dk:add-last(result, part-object);
    }

    return result;
  }

  method uintmax-t hash(object-t self)
  {
    uintmax-t value = dk-hash(self.ptr);
    return value;
  }

  method object-t append-sequence(object-t self, object-t sequence)
  {
    for (object-t element in sequence)
    {
      const char8-t* utf8 = dk:utf8-from(element);
      uint32-t length = cast(uint32-t)safe-strlen(utf8);
      self.len += cast(uint32-t)(length);
      self.ptr = cast(char8-t*)realloc(self.ptr, (self.len + 1 * sizeof(char8-t)));
      strcat(self.ptr, utf8);
    }
    return self;
  }

  method int-t compare(object-t self, object-t other)
  {
    //printf("%s('%s', '%s')\n", __method__, dkt-name(dkt-klass(self)), dkt-name(dkt-klass(other)));
    int-t result;

    if (dk:instance?(other, klass))
    {
      // what if both utf8s are nullptr?
      // what if only one utf8 is nullptr?
      slots-t* s1 = unbox(self);
      slots-t* s2 = unbox(other);
      result = safe-strcmp(s1->ptr, s2->ptr);
      result = normalize-compare-result(result);
    }
    else
    {
      result = dk:compare(super, other);
    }
    result = normalize-compare-result(result);
    return result;
  }

  method object-t print(object-t self, object-t out)
  {
    if (null == out)
      out = std-output;
    dk:print(out, dk:utf8-from(self));
    return self;
  }
}
