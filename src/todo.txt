add trailing ! to more dangerous version of methods (returns nullptr)
add safer versions of ! methods (throw exception)

at!(object-t self, object-t key, object-t default-element); // may return nullptr if default-element is nullptr
at(object-t self, object-t key, object-t default-element);  // will throw exception rather than return nullptr

at!(object-t self, object-t key); // return nullptr if not found
at(object-t self, object-t key);  // throws exception if not found

sort out mutable/immutable design

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert
lexical syntax of lhs vs rhs?)

refactoring tools

automate dk-klass-for-name(#someklass) in initialize(object-t) which
is currently (manually) handled by the consumer

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

flush out signal-exception klasses (move/reorg some code from dakota.dk)

selector in every method (like _cmd in objective-c) like __method__ which
is a signature (which is like __func__) name would likely __selector__

support #'abcd'

in perl:
  my $len = $$info{size}{len}
in dakota:
  int-t len = info@size@len;

object-t info = #{ #size : ${ #len : as(uint32)42, #width : as(uint32)84 }}
int-t len = info@#size@#len;
=>
int-t len = info.$at(#size).$at(#len);
int-t len = $at($at(info, #size), #len);

also

info@#size@#len = 42; // +=, -=, |=, ^=, &=, ||=, &&=, ...

= info@size
=>
= $at(info, size)

info@size = expr
=>
$set-at(info, size, expr)

#`...`  make(process::klass, #path : ..., #args : ..., #vars : ...).$exec()

allow tracing on specific generics

consider slot-at() and set-slot-at() generated funcs

selector in every method (like _cmd in objective-c) like __method__
which is a signature (which is like __func__)

warn if something is exported in a module description that is not in
the compiled image it represents

allow const on property::element; must supply no-op box() so it does
not generate a box that won't compile

add null/std-{input,output,error} to the readonly pages

check sorted order of named-info/property data structures in rt/*.cc
if not need be sorted, maybe convert from a named-info-t seq to a regular named-info-t
which is sorted, and with no sentinal.

fix padding for rt/*.cc imported-klasses[]

add to macro system the abilty to write and use "context" macros (like
"klass context" or "slots context" or "method context")

generate a naming summary (for example)
  every unique method/gf signature and number across klasses
  every unique keyword name (within a specific generic basename or across all generics) and its type across klasses
  name of slots members and its type across klasses
  the name of (eventual) subklass of 'klass' end with -klass (klass boole-klass { superklass klass; ... })

module defn should allow us to specify methods/generics by arity  add(2), add(3) (assume both object-t and super-t)

consider := operator like Dylan (it calls the setter func)?

swap order of args to super {klass, self} or {klass(self), self}

allow super to supply ONE argument (which default to self)
  super(self) is shorthand for super (which converts to super(self=self, klass=klass)

to the macro system add the notion of a zero-width statement boundry ( for example \{|\}|; )

consider dumped (from bin/dakota-info) both init() and va::init() method decls

consider moving methods from input-stream and output-stream up to stream
look at output-file and input-file (currently empty) and see if they, too, need a common parent

deal with input-stream/output-stream have #slots, and their subklasses have #stream for same variable
(maybe one could tag a keyword as an alias to slots (so the generated box would work)

features that show:
  #"..." like symbols, hashes, and keywords
  #'...' instance of some klass of char ... multibyte
  #`...` instance of klass process
  i32, i64, u32, u64
  range (first, last, interval)
  selector in every method body (__selector__)
  as(a-klass) casting syntax

rename various things to consistent kw-args, kw-arg-method..., or simpley keyword

new alias syntax:
  method alias (inside klass defn)
    method push() => add-last();
    // or if add-last(...) is overloaded
    method push() => add-last(object-t, object-t);
  method/generic keyword alias
    method init(slots => stream);
    // or if init() is overloaded
    method init(object-t, int32-t, slots => stream);

from swift:
  case "cucumber", "watercress":
  for e in seq {
  if parens-not-required {
  []:  empty array
  [:]: empty dict
  ??: val-which-might-be-null ?? default-val-if-lhs-is-null
  for (first, last) in table {

o.$m1().$m2()
=>
$m2($m1(o))

o.$m1(a1, a2).$m2(a3)
=>
$m2($m1(o, a1, a2), a3)

o.$m1(a1, a2).$m2(a3, a4).$m3(a5, a6)
=>
$m3($m2($m1(o, a1, a2), a3, a4), a5, a6)

bin/dakota-build --project [project.rep] --jobs 4 ../lib/libdakota.so
  which uses bin/dakota just like make does

convert method [[alias(...)]] to method ...() => ...(...)

create support for keyword aliasing

consider authoring headers in dakota syntax and generating the actual headers

klass::klass-with-trait() could be more efficient with the right data structure

consider modeling module system after http://clang.llvm.org/docs/Modules.html
Remove module ... ; decl in *.dk file and get the information from the module map file
rename module-dakota.dk      dakota.module
rename module-dakota-util.dk dakota-util.module
add to dakota --module=%s

allow more than one module to exists in a single shared library

dakota should accept .cc, .cxx, .cpp, .c++ files (etc)
dakota should accept .hh, .hxx, .hpp, .h++ files (etc)

add support for
[[dk::initializer]] static void my-initializer();
[[dk::finalizer]]   static void my-finalizer();
to be called AFTER the dakota runtime is fully setup, but before main()

fix --precompile option. Any lib/exe depending on something being generated should
instead be able to use the corresponding rep file. This might require some convergence of the respective schemas, or a way to convert from one type of rep file to the other.

support stack based object creation
  make() va stack-make()

make super() take an arg for self (defaults to self of course)

Consider the name of a klass (or trait) is within the klass' (or traits') scope; its name is __klass__.
  should this change? offer __trait__ as an alias to __klass__
  how about __scope-name__ which will work with klasses, traits, namespaces, methods, and potentially even funcs.

convert symbol-from-addr() and related code to a dladdr() compatible interface to be used when dladdr() is missing.

sysconf(_SC_PAGE_SIZE)

add optional index to for/in iterator
add table iteration that is more natural than iterating over the pairs

text-(input,output}-stream is subklass of object-{input,output}-stream?

make sure PS1 is conditionally set
if [ "${PS1+set}" = set ]
then prompt=...
fi

add iter-like interface that takes a lambda func

prefix initialize()/finalize() with 'klass method'

replace visibility comment with [[]]

do  {} catch (...) {}
=>
try {} catch (...) {}

do {} ...
=>
do {} while (0); ...

do {} until (...);
=>
do {} while (!(...));

switch { case: automatically get trailing break added IFF the last token is not nobreak

fix "never" slots (slots which comments indicate will never be something only to have #slots default to set to those never values

current: dkt-get-klass-chain(object-t kls, char8-t* buf, uint32-t buf-len) -> char8-t*;
add:     dkt-get-klass-chain(object-t kls, str-buffer-t str-buf)

consider renaming #items to #objects (or #objects[] ?)

convert code to use intNN-t vs uintNN-t where possible

clean up or remove DKT-WORKAROUND
