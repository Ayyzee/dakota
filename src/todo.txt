add trailing ! to more dangerous version of methods
add safer versions of ! methods

sort out mutable/immutable design

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert
lexical syntax of lhs vs rhs?)

refactoring tools

automate dk-klass-for-name(#someklass) in initialize(object-t) which
is currently (manually) handled by the consumer

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

flush out signal-exception klasses (move/reorg some code from dakota.dk)

selector in every method (like _cmd in objective-c) like __method__ which
is a signature (which is like __func__) name would likely __selector__

support something like perl's map function
my       @doubles = map { $_ * 2 } @numbers;
object-t  doubles = map {  _ * 2 }  numbers;

support #'abcd', #true, #false

in perl:
  my $len = $$info{size}{len}
in dakota:
  int-t len = info@size@len;

object-t info = #{ #size : ${ #len : as(uint32)42, #width : as(uint32)84 }}
int-t len = info@#size@#len;
=>
int-t len = info.$at(#size).$at(#len);
int-t len = $at($at(info, #size), #len);

also

info@#size@#len = 42; // +=, -=, |=, ^=, &=, ||=, &&=, ...

= info@size
=>
= $at(info, size)

info@size = expr
=>
$set-at(info, size, expr)

#`...`  make(process::klass, #path : ..., #args : ..., #vars : ...).$exec()

klass number {
  superklass of all float types, int types, and char types

allow tracing on specific generics

consider slot-at() and set-slot-at() generated funcs

selector in every method (like _cmd in objective-c) like __method__
which is a signature (which is like __func__)

warn if something is exported in a module description that is not in
the compiled image it represents

allow const on property::element; must supply no-op box() so it does
not generate a box that won't compile

add null/#std{in,out,err}/#false/#true to the readonly pages

check sorted order of named-info/property data structures in rt/*.cc

fix padding for rt/*.cc imported-klasses[]

add to macro system the abilty to write and use "context" macros (like
"klass context" or "slots context" or "method context")

generate a naming summary (for example)
  every unique method/gf signature and number across klasses
  every unique keyword name (within a specific generic basename or across all generics) and its type across klasses
  name of slots members and its type across klasses
  the name of (eventual) subklass of 'klass' end with -klass (klass boole-klass { superklass klass; ... })

module defn should allow us to specify methods/generics by arity  add(2), add(3) (assume both object-t and super-t)

consider := operator like Dylan (it calls the setter func)?

swap order of args to super {klass, self} or {klass(self), self}

allow supply to supply ONE argument (which default to self)
  super(self) is shorthand for super (which converts to super(self=self, klass=klass)

to the macro system add the notion of a zero-width statement boundry ( for example \{|\}|; )
