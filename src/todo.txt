add trailing ! to more dangerous version of methods
add safer versions of ! methods

sort out mutable/immutable design

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert
lexical syntax of lhs vs rhs?)

refactoring tools

automate dk-klass-for-name(#someklass) in initialize(object-t) which
is currently (manually) handled by the consumer

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

flush out signal-exception klasses (move/reorg some code from dakota.dk)

selector in every method (like _cmd in objective-c) like __method__ which
is a signature (which is like __func__) name would likely __selector__

support something like perl's map function
my       @doubles = map { $_ * 2 } @numbers;
object-t  doubles = map {  _ * 2 }  numbers;

support #'abcd', #true, #false

in perl:
  my $len = $$info{size}{len}
in dakota:
  int-t len = info@size@len;

object-t info = #{ #size : ${ #len : as(uint32)42, #width : as(uint32)84 }}
int-t len = info@#size@#len;
=>
int-t len = info.$at(#size).$at(#len);
int-t len = $at($at(info, #size), #len);

also

info@#size@#len = 42; // +=, -=, |=, ^=, &=, ||=, &&=, ...

= info@size
=>
= $at(info, size)

info@size = expr
=>
$set-at(info, size, expr)

#`...`  make(process::klass, #path : ..., #args : ..., #vars : ...).$exec()

klass number {
  superklass of all float types, int types, and char types

allow tracing on specific generics

consider slot-at() and set-slot-at() generated funcs

selector in every method (like _cmd in objective-c) like __method__
which is a signature (which is like __func__)

warn if something is exported in a module description that is not in
the compiled image it represents

allow const on property::element; must supply no-op box() so it does
not generate a box that won't compile

add null/#std{in,out,err}/#false/#true to the readonly pages

check sorted order of named-info/property data structures in rt/*.cc

fix padding for rt/*.cc imported-klasses[]

add to macro system the abilty to write and use "context" macros (like
"klass context" or "slots context" or "method context")

generate a naming summary (for example)
  every unique method/gf signature and number across klasses
  every unique keyword name (within a specific generic basename or across all generics) and its type across klasses
  name of slots members and its type across klasses
  the name of (eventual) subklass of 'klass' end with -klass (klass boole-klass { superklass klass; ... })

module defn should allow us to specify methods/generics by arity  add(2), add(3) (assume both object-t and super-t)

consider := operator like Dylan (it calls the setter func)?

swap order of args to super {klass, self} or {klass(self), self}

allow supply to supply ONE argument (which default to self)
  super(self) is shorthand for super (which converts to super(self=self, klass=klass)

to the macro system add the notion of a zero-width statement boundry ( for example \{|\}|; )

clean up uses of uintptr-t (should be hash-t)

consider dumped (from bin/dakota-info) both init() and va::init() method decls

we have str/string/cstring. consider removing cstring.

consider moving methods from input-stream and output-stream up to stream
look at output-file and input-file (currently empty) and see if they, too, need a common parent

deal with input-stream/output-stream have #slots, and their subklasses have #stream for same variable
(maybe one could tag a keyword as an alias to slots (so the generated box would work)

features that show:
  #"..." like symbols, hashes, and keywords
  #'...' instance of some klass of char ... multibyte
  #`...` instance of klass process
  i32, i64, u32, u64
  range (first, last, interval)
  #true/#false instance of klass boole
  selector in every method body (__selector__)
  map like in perl (use lambda func)
  as(a klass) casting syntax

echo out method kw-arg defaults when using dakota-info
maybe as a comment? this info is not required for the parser
but it might be nice to suppy it for the user

rename various things to consistent kw-args, kw-arg-method..., or simpley keyword

new alias syntax:
  method alias (inside klass defn)
    method push() => add-last();
    // or if add-last(...) is overloaded
    method push() => add-last(object-t, object-t);
  method/generic keyword alias
    method init(slots => stream);
    // or if init() is overloaded
    method init(object-t, int32-t, slots => stream);

from swift:
  case "cucumber", "watercress":

bin/dakota-build --project [project.rep] --jobs 4 ../lib/libdakota.so
  which uses bin/dakota just like make does

convert non-method functions to the new syntax

convert method [[alias(...)]] to method ...() => ...(...)

create support for keyword aliasing

consider authoring headers in dakota syntax and generating the actual headers

klass::klass-with-trait() could be more efficient with the right data structure

consider modeling module system after http://clang.llvm.org/docs/Modules.html
Remove module ... ; decl in *.dk file and get the information from the module map file
rename module-dakota.dk      dakota.module
rename module-dakota-util.dk dakota-util.module
add to dakota --module=%s
