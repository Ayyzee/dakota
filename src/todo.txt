add trailig ! to more danerous version of methods
add safer versions of ! metthods

sort out mutable/immutable design

fix emacs dakota-mode finding

superklass-of() => dk::superklass()
name-of() =>       dk::name()

convert to use in() and in?() [formally contains?()]

Added leading $ to generic functions and va prefixes
  then using namespace dk brings them all in.
  dk::add() =>      $add()
  dk::va::init() => $va::init()

undef => null

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert lexical syntax of lhs vs rhs?)

refactoring tools

automate klass-for-name(#someklass) in initialize() which is currently (manually) handled by the consumer

warnings/errors on elements in the module import export that don't actually exist.

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

dakota.dk: name-from-address() should also return the shared library name (better error reporting)

make REASSOC-AND-ADD-METHOD-FOR-SELECTOR(3) an inline function

http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html

int l = info@len;
=>
int l = dk::at(info, len);
