add trailing ! to more dangerous version of methods
add safer versions of ! methods

sort out mutable/immutable design

superklass-of() => dk::superklass()
name-of() =>       dk::name()

convert to use in() and in?() [formally contains?()]

Added leading $ to generic functions and va prefixes
  then using namespace dk brings them all in.
  dk::add() =>      $add()
  dk::va::init() => $va::init()

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert lexical syntax of lhs vs rhs?)

refactoring tools

automate dk-klass-for-name(#someklass) in initialize(object-t) which is currently (manually) handled by the consumer

warnings/errors on elements in the module import export that don't actually exist.

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html

in perl: my $len = $$info{size}{len}
int-t len = info@size@len;
=>
int-t len = dk::at(dk::at(info, size), len);
int-t len = $at($at(info, size), len);
int-t len = info.$at(size).$at(len);

flush out signal-exception klasses (move/reorg some code from dakota.dk)

selector in every method (like _cmd in objective-c) like __method__ which is a signature (which is like __func__)
name would likely __selector__

warn if something is exported in a module description that is not in
the compiled image it represents
