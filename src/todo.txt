add trailing ! to more dangerous version of methods (returns nullptr)
add safer versions of ! methods (throw exception)

at!(object-t self, object-t key, object-t default-element); // may return nullptr if default-element is nullptr
at(object-t self, object-t key, object-t default-element);  // will throw exception rather than return nullptr

at!(object-t self, object-t key); // return nullptr if not found
at(object-t self, object-t key);  // throws exception if not found

sort out mutable/immutable design

trait sets-w-pairs

improve the output format of no-such-method-exception

add to table::keys()?
add to counted-set::elements()?
  // , object-t set-klass : superklass-of(klass-of(self))

add to table::elements()?
add to counted-set::counts()?
 // , object-t sequence-klass : vector::klass

--define-macro DKT-NULL-METHOD=dkt-null-method (how should we convert
lexical syntax of lhs vs rhs?)

refactoring tools

automate dk-klass-for-name(#someklass) in initialize(object-t) which
is currently (manually) handled by the consumer

have test/bin/check.pl read dirs from stdin

add --debug=, --optimize= to dakota to pass through to compiler

flush out signal-exception klasses (move/reorg some code from dakota.dk)

selector in every method (like _cmd in objective-c) like __method__ which
is a signature (which is like __func__) name would likely __selector__

support something like perl's map function
my       @doubles = map { $_ * 2 } @numbers;
object-t  doubles = map {  _ * 2 }  numbers;

support #'abcd', #true, #false

in perl:
  my $len = $$info{size}{len}
in dakota:
  int-t len = info@size@len;

object-t info = #{ #size : ${ #len : as(uint32)42, #width : as(uint32)84 }}
int-t len = info@#size@#len;
=>
int-t len = info.$at(#size).$at(#len);
int-t len = $at($at(info, #size), #len);

also

info@#size@#len = 42; // +=, -=, |=, ^=, &=, ||=, &&=, ...

= info@size
=>
= $at(info, size)

info@size = expr
=>
$set-at(info, size, expr)

#`...`  make(process::klass, #path : ..., #args : ..., #vars : ...).$exec()

klass number {
  superklass of all float types, int types, and char types

allow tracing on specific generics

consider slot-at() and set-slot-at() generated funcs

selector in every method (like _cmd in objective-c) like __method__
which is a signature (which is like __func__)

warn if something is exported in a module description that is not in
the compiled image it represents

allow const on property::element; must supply no-op box() so it does
not generate a box that won't compile

add null/#std{in,out,err}/#false/#true to the readonly pages

check sorted order of named-info/property data structures in rt/*.cc
if not need be sorted, maybe convert from a named-info-t seq to a regular named-info-t
which is sorted, and with no sentinal.

fix padding for rt/*.cc imported-klasses[]

add to macro system the abilty to write and use "context" macros (like
"klass context" or "slots context" or "method context")

generate a naming summary (for example)
  every unique method/gf signature and number across klasses
  every unique keyword name (within a specific generic basename or across all generics) and its type across klasses
  name of slots members and its type across klasses
  the name of (eventual) subklass of 'klass' end with -klass (klass boole-klass { superklass klass; ... })

module defn should allow us to specify methods/generics by arity  add(2), add(3) (assume both object-t and super-t)

consider := operator like Dylan (it calls the setter func)?

swap order of args to super {klass, self} or {klass(self), self}

allow super to supply ONE argument (which default to self)
  super(self) is shorthand for super (which converts to super(self=self, klass=klass)

to the macro system add the notion of a zero-width statement boundry ( for example \{|\}|; )

clean up uses of uintptr-t (should be hash-t)

consider dumped (from bin/dakota-info) both init() and va::init() method decls

consider moving methods from input-stream and output-stream up to stream
look at output-file and input-file (currently empty) and see if they, too, need a common parent

deal with input-stream/output-stream have #slots, and their subklasses have #stream for same variable
(maybe one could tag a keyword as an alias to slots (so the generated box would work)

features that show:
  #"..." like symbols, hashes, and keywords
  #'...' instance of some klass of char ... multibyte
  #`...` instance of klass process
  i32, i64, u32, u64
  range (first, last, interval)
  #true/#false instance of klass boole
  selector in every method body (__selector__)
  map like in perl (use lambda func)
  as(a klass) casting syntax

rename various things to consistent kw-args, kw-arg-method..., or simpley keyword

new alias syntax:
  method alias (inside klass defn)
    method push() => add-last();
    // or if add-last(...) is overloaded
    method push() => add-last(object-t, object-t);
  method/generic keyword alias
    method init(slots => stream);
    // or if init() is overloaded
    method init(object-t, int32-t, slots => stream);

from swift:
  case "cucumber", "watercress":

bin/dakota-build --project [project.rep] --jobs 4 ../lib/libdakota.so
  which uses bin/dakota just like make does

convert non-method functions to the new syntax

convert method [[alias(...)]] to method ...() => ...(...)

create support for keyword aliasing

consider authoring headers in dakota syntax and generating the actual headers

klass::klass-with-trait() could be more efficient with the right data structure

consider modeling module system after http://clang.llvm.org/docs/Modules.html
Remove module ... ; decl in *.dk file and get the information from the module map file
rename module-dakota.dk      dakota.module
rename module-dakota-util.dk dakota-util.module
add to dakota --module=%s

allow more than one module to exists in a single shared library

dakota should accept .cc, .cxx, .cpp, .c++ files (etc)
dakota should accept .hh, .hxx, .hpp, .h++ files (etc)

add support for
[[dk::initializer]] static void my-initializer();
[[dk::finalizer]]   static void my-finalizer();
to be called AFTER the dakota runtime is fully setup, but before main()

fix --precompile option. Any lib/exe depending on something being generated should
instead be able to use the corresponding rep file. This might require some convergence of the respective schemas, or a way to convert from one type of rep file to the other.

support stack based object creation
  make() va stack-make()

make super() take an arg for self (defaults to self of course)

dk-intern() should allow to have multiple (unique) tables so one might create a filesystem-only intern table, etc.

Consider the name of a klass (or trait) is within the klass' (or traits') scope; its name is __klass__.
  should this change? offer __trait__ as an alias to __klass__
  how about __scope-name__ which will work with klasses, traits, namespaces, methods, and potentially even funcs.

convert symbol-from-addr() and related code to a dladdr() compatible interface to be used when dladdr() is missing.

nested klass/traits defns (i.e. inner klasses/traits)?

sysconf(_SC_PAGE_SIZE)

when rewriting ...
dynamically generate a pattern for each symbol in __symbol to replace the unneccessary
explicit use of dk-intern()
for example
  { dk-intern ( "strings" ) } => { #strings }
which will later be rewritten to
 __symbol :: _strings_
It might be possible to generate a function-like macro where the double quoted string and the symbol syntax
are variable and the user just passes in a list of compile-time known symbols

0 == symbol::compare(a, b)
or
0 != symbol::compare(a, b)
can be replaced
a == b
or
a != b

generate compile-time symbols for all shared objects only when linking an executable (so ALL compile-time
symbols (and keywords) will be in sorted ascending/decending order so they may be $compare()ed.

add optional offset to iterator

text-(input,output}-stream is subklass of object-{input,output}-stream?

symbol-t sym = "hi fred";
=>
symbol-t sym = #hi20fred;
=>
...

convert generated unbox() of aggregate type to return slots-t& rather than slots-t*
so self.foo becomes unbox(self).foo

search for (*) and convert to auto/trailing-return-type if needed

make sure PS1 is conditionally set
if [ "${PS1+set}" = set ]
then prompt=...
fi
