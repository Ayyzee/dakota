// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

// Copyright (C) 2007 - 2015 Robert Nielsen <robert@dakota.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include <cassert>;
include <cstring>;

include "dakota-private.h";

module dakota-util;

klass object-output-stream;
klass output-stream;
klass str512;
klass tokenid;

klass token
{
  slots
  {
    tokenid-t tokenid;
    uint32-t line;
    uint32-t column;
    str512-t buffer;
    // could include filename
    object-t leading-ws;
  }

  method object-t write-lite(object-t self, object-t out)
  {
    dk:write(out, "\"");
    dk:write(out, self.buffer);
    dk:write(out, "\"");
    return self;
  }

  method object-t write-slots(object-t self, object-t out)
  {
    dk:write-slots(super, out);
    dk:write-slots-start(out, klass);

    dk:write-element(out, self.line,   "line");
    dk:write-element(out, self.column, "column");
    dk:write-element(out, self.buffer, "buffer");

    dk:write-slots-end(out);
    return self;
  }

  method object-t init(object-t self,
                       uint32-t       line =>    0,
                       uint32-t       column =>  0,
                       tokenid-t      tokenid => 0,
                       const char8-t* buffer =>  nullptr)
  {
    self = dk:init(super);
#if 0
    if (0 != tokenid) {
      char8-t[4 + (1)] tokenid-str = "";
      tokenid:str-from(tokenid, tokenid-str, sizeof(tokenid-str));

      printf("{ 'line'=>'%i', 'column'=>'%i', 'tokenid'=>'%s', 'buffer'=>'%s' },\n",
             line, column, tokenid-str, buffer);
    }
#endif
    self.line =    line;
    self.column =  column;
    self.tokenid = tokenid;
    if (nullptr == buffer)
      self.buffer[0] = NUL;
    else
      strcpy(self.buffer, buffer);
    self.leading-ws = nullptr;
    return self;
  }

  method uintmax-t hash(object-t self)
  {
    object-t string = make(string:klass, bytes => cast(const char8-t*)(self.buffer));
    uintmax-t hash = dk:hash(string);
    return hash;
  }

  method boole-t equal?(object-t self, object-t other)
  {
    boole-t state;

    if (dk:instance?(other, klass)) {
      slots-t* t = unbox(other);
      object-t s-string = make(string:klass, bytes => cast(const char8-t*)(self.buffer));
      object-t t-string = make(string:klass, bytes => cast(const char8-t*)(t->buffer));
      state = dk:equal?(s-string, t-string);
    } else {
      state = false;
    }
    return state;
  }

  method boole-t empty?(object-t self)
  {
    boole-t result = false;
    if (NUL == self.buffer[0])
      result = true;
    return result;
  }

  method object-t empty(object-t self)
  {
    self.line =      0;
    self.column =    0;
    self.tokenid =   0;
    self.buffer[0] = NUL;
    return self;
  }

  method boole-t tokenid?(object-t self, tokenid-t tokenid)
  {
    boole-t result;
    if (self.tokenid == tokenid)
      result = true;
    else
      result = false;
    return result;
  }

  method object-t set-tokenid(object-t self, tokenid-t tokenid)
  {
    self.tokenid = tokenid;
    return self;
  }

  method tokenid-t tokenid(object-t self)
  {
    tokenid-t result = self.tokenid;
    return result;
  }

  method object-t set-leading-ws(object-t self, object-t leading-ws)
  {
    assert(nullptr == self.leading-ws);
    self.leading-ws = leading-ws;
    return self;
  }

  method boole-t leading-ws?(object-t self)
  {
    boole-t result;
    if (nullptr == self.leading-ws)
      result = false;
    else
      result = true;
    return result;
  }

  method object-t leading-ws(object-t self)
  {
    return self.leading-ws;
  }

  method uint32-t line(object-t self)
  {
    return self.line;
  }

  method uint32-t column(object-t self)
  {
    return self.column;
  }

  method const char8-t* buffer(object-t self)
  {
    return cast(const char8-t*)(self.buffer);
  }

  method char8-t first-char8(object-t self)
  {
    const char8-t result = self.buffer[0];
    return result;
  }

  // this should be merged with buffer - this is a hackhack
  method const char8-t* utf8-from(object-t self)
  {
    const char8-t* buffer = dk:buffer(self);
    return buffer;
  }

  method object-t dump-shallow(object-t self)
  {
#if 0
    if (0 != self.tokenid)
      fprintf(stderr, "%s\n", self.buffer);
    return self;
#else
//     fprintf(stderr, "%p:%p { line=%i, buffer=\"",
//             cast(void*)(self), cast(void*)unbox(self), self.line);

    for (uint32-t i = 0; NUL != self.buffer[i]; i++) {
      switch (self.buffer[i])
      {
        case '\n':
          fprintf(stderr, "\\n");
          break;
        case '\t':
          fprintf(stderr, "\\t");
          break;
        default:
          fprintf(stderr, "%c", self.buffer[i]);
      }
    }

//     fprintf(stderr, "\" }");
    fprintf(stderr, "\n");
    return self;
#endif
  }

  method object-t dump(object-t self)
  {
    dk:dump(super);
    fprintf(stderr, "%p:%p { buffer=\"%s\" }\n",
            cast(void*)(self), cast(void*)unbox(self), self.buffer);
    return self;
  }

  method object-t print(object-t self, object-t out)
  {
    if (null == out)
      out = std-output;
    dk:print(out, dk:utf8-from(self));
    return self;
  }

  // should be in superklass string??
  method object-t append(object-t self, uint32-t c)
  {
    assert(nullptr != self.buffer);
    uint32-t len = cast(uint32-t)safe-strlen(self.buffer);
    self.buffer[len] =     cast(char8-t)(c);
    self.buffer[len + 1] = NUL;
    return self;
  }

  method int-t compare(object-t self, object-t other)
  {
  //fprintf(stderr, "%s <=> %s\n", unbox(self)->buffer, unbox(other)->buffer);
    int-t result = safe-strcmp(unbox(self)->buffer, unbox(other)->buffer);
    result = dkt-normalize-compare-result(result);
    return result;
  }
}
