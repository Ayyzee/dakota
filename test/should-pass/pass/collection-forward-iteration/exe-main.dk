// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

#include <stdio.h>
#include <assert.h>
#include <string.h>

klass deque;
klass hashed-set;
klass size;
klass sorted-set;
klass vector;

enum collection-type-t
{
  NONE    = 0,
  ORDERED = 1 << 0,
  SORTED  = 1 << 1
//MUMBLE  = 1 << 2,
}

static int-t check-collection(object-t klass, collection-type-t collection-type, size-t count)
{
  assert(0xff >= count); // 2 hex digits wide max
  object-t collection = make(klass);
  size-t width = (count * (1 + 2)) + (1);
  char8-t* lhs = (char8-t*)malloc(sizeof(char8-t) * width);
  char8-t* rhs = (char8-t*)malloc(sizeof(char8-t) * width);
  lhs[0] = (char8-t)0;
  rhs[0] = (char8-t)0;
  int-t offset;

  offset = 0;
  for (size-t i = 0; i < count; i++) {
    object-t e = size::box(i);
    offset += sprintf(lhs + offset, "/%zx", *size::unbox(e));
    if (ORDERED & collection-type)
      $add-last(collection, e);
    else
      $add(collection, e);
//     size-t size = $size(collection);
//     printf("1 + %i == %i\n", i, size);
  }

  offset = 0;
  for (object-t e in collection)
    offset += sprintf(rhs + offset, "/%zx", *size::unbox(e));

  printf("  \"%s\" == \"%s\"\n", lhs, rhs);
  int-t result = 0;
  
  if (ORDERED & collection-type || SORTED & collection-type) {
    if (0 != strcmp(lhs, rhs)) {
      fprintf(stderr, "  FAILED: strcmp(\"%s\", \"%s\")\n", lhs, rhs);
      result = 1;
    }
  } else {
    if (strlen(lhs) != strlen(rhs)) {
      fprintf(stderr, " FAILED: strlen(\"%s\") == strlen(\"%s\")\n", lhs, rhs);
      result = 1;
    }
  }
  return result;
}

static int-t check-collection(object-t klass, collection-type-t collection-type)
{
  int-t result = 0;
  fprintf(stderr, "%s:\n", name-of(klass));
  for (size-t i = 1; i < 5; i++)
    result += check-collection(klass, collection-type, i);
  return result;
}

int-t main()
{
  int-t r1 = check-collection(vector::klass, ORDERED);
  int-t r2 = check-collection(deque::klass,  ORDERED);

  int-t r3 = check-collection(sorted-set::klass, SORTED);
  int-t r4 = check-collection(hashed-set::klass, NONE);

//   check-collection(sorted-counted-set::klass, SORTED);
//   check-collection(hashed-counted-set::klass, NONE);

  return r1 || r2 || r3 || r4;
}
