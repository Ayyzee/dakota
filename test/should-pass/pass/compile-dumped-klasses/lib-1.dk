//arg=/usr/local/lib/libdakota-util.dylib
//name=/usr/local/lib/libdakota.dylib
//arg=/usr/local/lib/libdakota-util.dylib
//name=/usr/local/lib/libdakota-util.dylib
module dakota-util;

generic object-t $init(object-t,object-t info:{0},str-t digits:{0});

klass ascii-number-klass
{
  superklass klass;
  
//method object-t init(object-t,object-t info:{0},str-t digits:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method digits(object-t) -> str-t;
}
generic object-t $init(object-t,int32-t number:{0});

klass ascii-number
{
//method object-t  init(object-t,int32-t number:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method ascii-string(object-t) -> str-t;
  method compare(object-t,object-t) -> int-t;
  method dealloc(object-t) -> object-t;
  method equal?(object-t,object-t) -> boole-t;
  method hash(object-t) -> uintmax-t;
}
generic object-t $init(object-t,uint32-t capacity:{0});

klass cstring
{
  slots
  {
    char8-t* ptr;
    uint32-t len;
    uint32-t capacity;
  }
//method object-t init(object-t,uint32-t capacity:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method compare(object-t,object-t) -> int-t;
  method concat(object-t,char8-t) -> object-t;
  method dealloc(object-t) -> object-t;
  method dump(object-t) -> object-t;
  method length(object-t) -> uint32-t;
  method write-slots(object-t,object-t) -> object-t;
}
klass dimension
{
  slots
  {
    int32-t width;
    int32-t height;
  }
}
klass features
{
  slots enum : uint32-t
  {
    k-none             = 0,
    k-indent           = 1<<0,
    k-leading-newline  = 1<<1,
    k-trailing-newline = 1<<2,
    k-leading-ws       = 1<<3,
    k-trailing-ws      = 1<<4,
  }
}
klass float32
{
  slots float;
}
klass float64
{
  slots double;
}
generic object-t $init(object-t,equal-predicate-t equal?:{0},hash-t hash:{0});

klass hashed-counted-set
{
  superklass hashed-set;
  trait counted-set;
  
//method object-t init(object-t,equal-predicate-t equal?:{0},hash-t hash:{0});
  method va::init(object-t,va-list-t) -> object-t;
}
generic object-t $init(object-t,hash-t hash:{0},equal-predicate-t equal?:{0},object-t elements:{0},object-t[] items:{0});

klass hashed-set
{
  superklass collection;
  trait set;
  
//method object-t init(object-t,hash-t hash:{0},equal-predicate-t equal?:{0},object-t elements:{0},object-t[] items:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method add(object-t,object-t) -> object-t;
  method at(object-t,object-t,object-t) -> object-t;
  method contains?(object-t,object-t) -> boole-t;
  method copy-shallow(object-t) -> object-t;
  method dump(object-t) -> object-t;
  method empty(object-t) -> object-t;
  method empty?(object-t) -> boole-t;
  method forward-iterator(object-t) -> object-t;
  method remove(object-t,object-t) -> object-t;
  method size(object-t) -> uint32-t;
  method write-slots(object-t,object-t) -> object-t;
}
generic object-t $init(object-t,equal-predicate-t equal?:{0},hash-t hash:{0},object-t elements:{0},object-t* items:{0});

klass hashed-table
{
  superklass hashed-set;
  trait table;
  
//method object-t init(object-t,equal-predicate-t equal?:{0},hash-t hash:{0},object-t elements:{0},object-t* items:{0});
  method va::init(object-t,va-list-t) -> object-t;
}
generic object-t $init(object-t,file-t file:{0},str-t filename:{0});

klass input-file
{
//method object-t init(object-t,file-t file:{0},str-t filename:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method dealloc(object-t) -> object-t;
  method filename(object-t) -> str-t;
  method get-char8(object-t) -> char8-t;
  method put-char8(object-t,char8-t) -> object-t;
  method split(object-t,type-predicate-t) -> object-t;
}
generic object-t $init(object-t,file-t file:{0},str-t filename:{0});

klass lexer
{
//method object-t init(object-t,file-t file:{0},str-t filename:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method dealloc(object-t) -> object-t;
  method filename(object-t) -> str-t;
  method lex(object-t) -> object-t;
  method tokenize(object-t) -> object-t;
}
klass open-token
{
  superklass token;
  
  method va::init(object-t,va-list-t) -> object-t;
  method close-token(object-t) -> object-t;
  method set-close-token(object-t,object-t) -> object-t;
  method write-slots(object-t,object-t) -> object-t;
}
generic object-t $init(object-t,object-t first:{},object-t last:{});

klass pair
{
  slots
  {
    object-t first;
    object-t last;
  }
//method object-t init(object-t,object-t first:{},object-t last:{});
  method va::init(object-t,va-list-t) -> object-t;
  method first(object-t) -> object-t;
  method last(object-t) -> object-t;
}
generic object-t $init(object-t,file-t file:{0});

klass json-object-output-stream
{
  superklass text-output-stream;
  
//method object-t init(object-t,file-t file:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method write-element(object-t,int32-t,str-t) -> object-t;
  method write-element(object-t,str-t,str-t) -> object-t;
  method write-element(object-t,uint32-t,str-t) -> object-t;
  method write-sequence-end(object-t) -> object-t;
  method write-sequence-start(object-t,str-t) -> object-t;
  method write-table-end(object-t) -> object-t;
  method write-table-start(object-t,str-t) -> object-t;
}
generic object-t $init(object-t,file-t file:{0},str-t filename:{0});

klass json-parser
{
//method object-t init(object-t,file-t file:{0},str-t filename:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method read(object-t,void*,uint32-t,uint32-t) -> uint32-t;
  method read-property-list(object-t) -> object-t;
}
klass point
{
  slots
  {
    int32-t x;
    int32-t y;
  }
}
klass rect
{
  slots
  {
    point::slots-t     point;
    dimension::slots-t dimension;
  }
  method equal?(object-t,object-t) -> boole-t;
}
klass slot-info
{
  slots
  {
    symbol-t type;
    uint32-t size;
  }
}
generic object-t $init(object-t,object-t token:{},str-t filename:{},str-t message:{0});

klass syntax-exception
{
  superklass exception;
  
//method object-t init(object-t,object-t token:{},str-t filename:{},str-t message:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method print(object-t,object-t) -> object-t;
  method print-shallow(object-t,object-t) -> object-t;
}
generic object-t $init(object-t,file-t file:{0});

klass text-output-stream
{
  superklass object-output-stream;
  
//method object-t init(object-t,file-t file:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method column-decr(object-t) -> object-t;
  method column-incr(object-t) -> object-t;
  method write(object-t,str-t,features-t) -> object-t;
}
generic object-t $init(object-t,uint32-t line:{0},uint32-t column:{0},tokenid-t tokenid:{0},str-t buffer:{0});

klass token
{
//method object-t  init(object-t,uint32-t line:{0},uint32-t column:{0},tokenid-t tokenid:{0},str-t buffer:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method append(object-t,uint32-t) -> object-t;
  method buffer(object-t) -> str-t;
  method column(object-t) -> uint32-t;
  method compare(object-t,object-t) -> int-t;
  method dump(object-t) -> object-t;
  method dump-shallow(object-t) -> object-t;
  method empty(object-t) -> object-t;
  method empty?(object-t) -> boole-t;
  method equal?(object-t,object-t) -> boole-t;
  method first-char8(object-t) -> char8-t;
  method hash(object-t) -> uintmax-t;
  method leading-ws(object-t) -> object-t;
  method leading-ws?(object-t) -> boole-t;
  method line(object-t) -> uint32-t;
  method print(object-t,object-t) -> object-t;
  method set-leading-ws(object-t,object-t) -> object-t;
  method set-tokenid(object-t,tokenid-t) -> object-t;
  method tokenid(object-t) -> tokenid-t;
  method tokenid?(object-t,tokenid-t) -> boole-t;
  method utf8-from(object-t) -> str-t;
  method write-lite(object-t,object-t) -> object-t;
  method write-slots(object-t,object-t) -> object-t;
}
klass tokenid
{
  slots uint32-t;
  method str-from(object-t,char8-t*,uint32-t) -> char8-t*;
}
klass type-predicate
{
  slots boole-t(*)(int-t);
}
generic object-t $init(object-t,file-t file:{0});

klass xml-object-output-stream
{
  superklass text-output-stream;
  
//method object-t init(object-t,file-t file:{0});
  method va::init(object-t,va-list-t) -> object-t;
  method write-element(object-t,int32-t,str-t) -> object-t;
  method write-element(object-t,str-t,str-t) -> object-t;
  method write-element(object-t,uint32-t,str-t) -> object-t;
  method write-sequence-end(object-t) -> object-t;
  method write-sequence-start(object-t,str-t) -> object-t;
  method write-table-end(object-t) -> object-t;
  method write-table-start(object-t,str-t) -> object-t;
}
module dakota-util export
  ascii-number-klass,
  ascii-number-klass::slots-t,
  ascii-number,
  ascii-number::slots-t,
  cstring,
  cstring::slots-t,
  dimension,
  dimension::slots-t,
  features,
  features::slots-t,
  float32,
  float32::slots-t,
  float64,
  float64::slots-t,
  hashed-counted-set,
  hashed-set-forward-iterator,
  hashed-set-forward-iterator::slots-t,
  hashed-set,
  hashed-set::slots-t,
  hashed-table,
  input-file,
  input-file::slots-t,
  lexer,
  lexer::slots-t,
  open-token,
  open-token::slots-t,
  pair,
  pair::slots-t,
  json-object-output-stream,
  json-object-output-stream::slots-t,
  json-parser,
  json-parser::slots-t,
  point,
  point::slots-t,
  rect,
  rect::slots-t,
  slot-info,
  slot-info::slots-t,
  syntax-exception,
  syntax-exception::slots-t,
  text-output-stream,
  text-output-stream::slots-t,
  token,
  token::slots-t,
  tokenid,
  tokenid::slots-t,
  type-predicate,
  type-predicate::slots-t,
  xml-object-output-stream,
  xml-object-output-stream::slots-t;
