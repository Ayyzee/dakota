// -*- mode: Dakota; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*-

klass features; // hackhack
klass json-object-output-stream;

klass k1
{
  superklass object;
  slots
  {
    int32-t value1;
    int32-t value2;
  }

  method object-t write-part(object-t self, object-t out)
  {
    $write-slots(super, out);
    $write-slots-start(out, klass);
    $write-element(out, self.value1, "value1");
    $write-element(out, self.value2, "value2");
    $write-slots-end(out);
    return self;
  }
}

klass k2
{
  superklass k1;
  slots
  {
    int32-t value1;
    int32-t value2;
    int32-t value3;
  }
  method object-t write-slots(object-t self, object-t out)
  {
    $write-slots(super, out);
    $write-slots-start(out, klass);
    $write-element(out, self.value1, "value1");
    $write-element(out, self.value2, "value2");
    $write-element(out, self.value3, "value3");
    $write-slots-end(out);
    return self;
  }
}

klass k3
{
  superklass k2;
  slots
  {
    object-t object;
  }
  method object-t init(object-t self)
  {
    self = $init(super);
    self.object = k2::klass;
    return self;
  }

  method object-t write-slots(object-t self, object-t out)
  {
    $write-slots(super, out);
    $write-slots-start(out, klass);
    $write-element-idref(out, self.object, "object");
    $write-slots-end(out);
    return self;
  }
}

int-t main()
{
  object-t i = make(k3::klass);

//   object-t ooutput-stream = make(xml-object-output-stream::klass);
//   $write(ooutput-stream, i);

  object-t poutput-stream = make(json-object-output-stream::klass);
  $write(poutput-stream, i);
  $close(poutput-stream);
  return 0;
}
